package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.35

import (
	"context"
	"whale/pkg/dbquery"
	"whale/pkg/loader"
	"whale/pkg/models"
	"whale/pkg/whalecode"

	"github.com/letjoy-club/mida-tool/dbutil"
	"github.com/letjoy-club/mida-tool/graphqlutil"
	"github.com/letjoy-club/mida-tool/midacode"
	"github.com/letjoy-club/mida-tool/midacontext"
)

// LikeMatching is the resolver for the likeMatching field.
func (r *mutationResolver) LikeMatching(ctx context.Context, userID *string, matchingID string) (string, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsAdmin() && !token.IsUser() {
		return "", midacode.ErrNotPermitted
	}
	uid := graphqlutil.GetID(token, userID)
	if uid == "" {
		return "", whalecode.ErrUserIDCannotBeEmpty
	}
	thunk := midacontext.GetLoader[loader.Loader](ctx).Matching.Load(ctx, matchingID)
	matching, err := thunk()
	if err != nil {
		return "", err
	}
	db := dbutil.GetDB(ctx)
	UserLikeMatching := dbquery.Use(db).UserLikeMatching
	err = UserLikeMatching.WithContext(ctx).Create(&models.UserLikeMatching{
		ToMatchingID: matchingID,
		ToUserID:     matching.UserID,
		UserID:       uid,
	})
	if err != nil {
		return "", midacode.ItemMayExist(err)
	}
	midacontext.GetLoader[loader.Loader](ctx).UserLikeMatching.Clear(ctx, uid)
	return "", err
}

// UnlikeMatching is the resolver for the unlikeMatching field.
func (r *mutationResolver) UnlikeMatching(ctx context.Context, userID *string, matchingID string) (string, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsAdmin() && !token.IsUser() {
		return "", midacode.ErrNotPermitted
	}
	uid := graphqlutil.GetID(token, userID)
	if uid == "" {
		return "", whalecode.ErrUserIDCannotBeEmpty
	}
	db := dbutil.GetDB(ctx)
	UserLikeMatching := dbquery.Use(db).UserLikeMatching
	rx, err := UserLikeMatching.WithContext(ctx).Where(UserLikeMatching.UserID.Eq(uid), UserLikeMatching.ToMatchingID.Eq(matchingID)).Delete()
	if err != nil {
		return "", err
	}
	if rx.RowsAffected == 0 {
		return "", midacode.ErrItemNotFound
	}
	midacontext.GetLoader[loader.Loader](ctx).UserLikeMatching.Clear(ctx, uid)
	return "", nil
}

// LikedMatchings is the resolver for the likedMatchings field.
func (r *queryResolver) LikedMatchings(ctx context.Context, userID *string, paginator *graphqlutil.GraphQLPaginator) ([]*models.UserLikeMatching, error) {
	thunk := midacontext.GetLoader[loader.Loader](ctx).UserLikeMatching.Load(ctx, *userID)
	likes, err := thunk()
	if err != nil {
		return nil, err
	}
	pager := graphqlutil.GetPager(paginator)
	if pager.Limit() >= 15 {
		pager.Size = 15
	}
	return likes.Slice(pager.Offset(), pager.Limit()), nil
}

// LikedMatchingCount is the resolver for the likedMatchingCount field.
func (r *queryResolver) LikedMatchingCount(ctx context.Context, userID *string) (*models.Summary, error) {
	thunk := midacontext.GetLoader[loader.Loader](ctx).UserLikeMatching.Load(ctx, *userID)
	likes, err := thunk()
	if err != nil {
		return nil, err
	}
	return &models.Summary{Count: likes.LikeNum()}, nil
}

// User is the resolver for the user field.
func (r *userLikeMatchingResolver) User(ctx context.Context, obj *models.UserLikeMatching) (*models.User, error) {
	return &models.User{ID: obj.UserID}, nil
}

// Matching is the resolver for the matching field.
func (r *userLikeMatchingResolver) Matching(ctx context.Context, obj *models.UserLikeMatching) (*models.Matching, error) {
	thunk := midacontext.GetLoader[loader.Loader](ctx).Matching.Load(ctx, obj.ToMatchingID)
	return thunk()
}

// UserLikeMatching returns UserLikeMatchingResolver implementation.
func (r *Resolver) UserLikeMatching() UserLikeMatchingResolver { return &userLikeMatchingResolver{r} }

type userLikeMatchingResolver struct{ *Resolver }

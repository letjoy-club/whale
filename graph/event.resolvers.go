package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.35

import (
	"context"
	"whale/pkg/dbquery"
	"whale/pkg/loader"
	"whale/pkg/models"
	"whale/pkg/modelutil"
	"whale/pkg/utils"
	"whale/pkg/whalecode"

	"github.com/letjoy-club/mida-tool/dbutil"
	"github.com/letjoy-club/mida-tool/graphqlutil"
	"github.com/letjoy-club/mida-tool/midacode"
	"github.com/letjoy-club/mida-tool/midacontext"
	"github.com/samber/lo"
)

// Joined is the resolver for the joined field.
func (r *eventProposalResolver) Joined(ctx context.Context, obj *models.EventProposal) (bool, error) {
	loader := midacontext.GetLoader[loader.Loader](ctx)
	token := midacontext.GetClientToken(ctx)
	if token.IsUser() {
		participants, err := loader.EventProposalParticipants.Load(ctx, obj.ID)()
		if err != nil {
			return false, err
		}
		return participants.HasActiveUser(token.UserID()), nil
	}
	return false, nil
}

// Joinable is the resolver for the joinable field.
func (r *eventProposalResolver) Joinable(ctx context.Context, obj *models.EventProposal) (bool, error) {
	loader := midacontext.GetLoader[loader.Loader](ctx)
	token := midacontext.GetClientToken(ctx)
	if token.IsUser() {
		participants, err := loader.EventProposalParticipants.Load(ctx, obj.ID)()
		if err != nil {
			return false, err
		}
		return participants.HasUser(token.UserID()), nil
	}
	return false, nil
}

// JoinedUsers is the resolver for the joinedUsers field.
func (r *eventProposalResolver) JoinedUsers(ctx context.Context, obj *models.EventProposal) ([]*models.User, error) {
	loader := midacontext.GetLoader[loader.Loader](ctx)
	participants, err := loader.EventProposalParticipants.Load(ctx, obj.ID)()
	if err != nil {
		return nil, err
	}
	userIDs := participants.ActiveUserIDs()
	return lo.Map(userIDs, func(id string, i int) *models.User {
		return &models.User{ID: id}
	}), nil
}

// User is the resolver for the user field.
func (r *eventProposalResolver) User(ctx context.Context, obj *models.EventProposal) (*models.User, error) {
	return &models.User{ID: obj.UserID}, nil
}

// Topic is the resolver for the topic field.
func (r *eventProposalResolver) Topic(ctx context.Context, obj *models.EventProposal) (*models.Topic, error) {
	return &models.Topic{ID: obj.TopicID}, nil
}

// City is the resolver for the city field.
func (r *eventProposalResolver) City(ctx context.Context, obj *models.EventProposal) (*models.Area, error) {
	return &models.Area{Code: obj.CityID}, nil
}

// JoinEventProposal is the resolver for the joinEventProposal field.
func (r *mutationResolver) JoinEventProposal(ctx context.Context, userID *string, eventID string) (*string, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsAdmin() && !token.IsUser() {
		return nil, midacode.ErrNotPermitted
	}
	uid := graphqlutil.GetID(token, userID)
	if uid == "" {
		return nil, whalecode.ErrUserIDCannotBeEmpty
	}
	return nil, modelutil.JoinEventProposal(ctx, uid, eventID)
}

// LeaveEventProposal is the resolver for the leaveEventProposal field.
func (r *mutationResolver) LeaveEventProposal(ctx context.Context, userID *string, eventID string) (*string, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsAdmin() && !token.IsUser() {
		return nil, midacode.ErrNotPermitted
	}
	uid := graphqlutil.GetID(token, userID)
	if uid == "" {
		return nil, whalecode.ErrUserIDCannotBeEmpty
	}
	return nil, modelutil.LeaveEventProposal(ctx, uid, eventID)
}

// KickOutUserFromEventProposal is the resolver for the kickOutUserFromEventProposal field.
func (r *mutationResolver) KickOutUserFromEventProposal(ctx context.Context, targetUserID string, eventID string) (*string, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsUser() && !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}
	return nil, modelutil.KickOutFromEventProposal(ctx, eventID, token.UserID(), targetUserID)
}

// CloseEventProposal is the resolver for the closeEventProposal field.
func (r *mutationResolver) CloseEventProposal(ctx context.Context, userID *string, eventID string) (*string, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsUser() && !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}
	return nil, modelutil.CloseEventProposal(ctx, eventID, token.UserID(), false)
}

// CreateEventProposal is the resolver for the createEventProposal field.
func (r *mutationResolver) CreateEventProposal(ctx context.Context, userID *string, param models.CreateEventProposalParam) (*models.EventProposal, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsUser() && !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}
	uid := graphqlutil.GetID(token, userID)
	if uid == "" {
		return nil, whalecode.ErrUserIDCannotBeEmpty
	}
	return modelutil.CreateEventProposal(ctx, uid, param)
}

// DiscoverLatestEventProposals is the resolver for the discoverLatestEventProposals field.
func (r *queryResolver) DiscoverLatestEventProposals(ctx context.Context, filter models.DiscoverEventProposalFilter, lastID *string) ([]*models.EventProposal, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsUser() && !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}

	if filter.CategoryID == "" {
		filter.CategoryID = loader.AllCategoryID
	}

	loader := midacontext.GetLoader[loader.Loader](ctx)
	loader.AllEventProposalLoader.Load(ctx)

	lID := ""
	if lastID != nil {
		lID = *lastID
	}

	ids := loader.AllEventProposalLoader.GetOrdered(ctx, filter.CategoryID, filter.TopicIds, filter.CityID, lID, 6)

	thunk := loader.EventProposal.LoadMany(ctx, ids)
	return utils.ReturnThunk(thunk)
}

// UserJoinedEventProposals is the resolver for the userJoinedEventProposals field.
func (r *queryResolver) UserJoinedEventProposals(ctx context.Context, userID *string) ([]*models.UserJoinEventProposal, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsUser() && !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}
	uid := graphqlutil.GetID(token, userID)
	if uid == "" {
		return nil, whalecode.ErrUserIDCannotBeEmpty
	}
	db := dbutil.GetDB(ctx)
	UserJoinEventProposal := dbquery.Use(db).UserJoinEventProposal
	proposals, err := UserJoinEventProposal.WithContext(ctx).Where(UserJoinEventProposal.UserID.Eq(uid)).Find()
	return proposals, err
}

// MyEventProposals is the resolver for the myEventProposals field.
func (r *queryResolver) MyEventProposals(ctx context.Context, userID *string) ([]*models.EventProposal, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsUser() && !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}
	uid := graphqlutil.GetID(token, userID)
	if uid == "" {
		return nil, whalecode.ErrUserIDCannotBeEmpty
	}

	db := dbutil.GetDB(ctx)
	EventProposal := dbquery.Use(db).EventProposal
	proposal, err := EventProposal.WithContext(ctx).Where(EventProposal.UserID.Eq(uid)).Find()
	if err != nil {
		return nil, err
	}
	return proposal, nil
}

// EventProposal is the resolver for the eventProposal field.
func (r *queryResolver) EventProposal(ctx context.Context, id string) (*models.EventProposal, error) {
	loader := midacontext.GetLoader[loader.Loader](ctx)
	thunk := loader.EventProposal.Load(ctx, id)
	return thunk()
}

// EventProposals is the resolver for the eventProposals field.
func (r *queryResolver) EventProposals(ctx context.Context, filter models.EventProposalFilter, paginator *graphqlutil.GraphQLPaginator) ([]*models.EventProposal, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}
	pager := graphqlutil.GetPager(paginator)
	db := dbutil.GetDB(ctx)
	EventProposal := dbquery.Use(db).EventProposal
	query := EventProposal.WithContext(ctx)
	if filter.CityID != nil {
		query = query.Where(EventProposal.CityID.Eq(*filter.CityID))
	}
	if filter.UserID != nil {
		query = query.Where(EventProposal.UserID.Eq(*filter.UserID))
	}
	if len(filter.TopicIds) > 0 {
		query = query.Where(EventProposal.TopicID.In(filter.TopicIds...))
	}
	proposals, err := query.Order(EventProposal.ID.Desc()).Offset(pager.Offset()).Limit(pager.Limit()).Find()
	return proposals, err
}

// EventProposalParticipants is the resolver for the eventProposalParticipants field.
func (r *queryResolver) EventProposalParticipants(ctx context.Context, eventID string, all *bool) ([]*models.UserJoinEventProposal, error) {
	loader := midacontext.GetLoader[loader.Loader](ctx)
	participants, err := loader.EventProposalParticipants.Load(ctx, eventID)()
	if err != nil {
		return nil, err
	}
	if all != nil && *all {
		return participants.Events, nil
	}
	return participants.ActiveEvents(), nil
}

// EventProposalsCount is the resolver for the eventProposalsCount field.
func (r *queryResolver) EventProposalsCount(ctx context.Context, filter models.EventProposalFilter) (*models.Summary, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}
	db := dbutil.GetDB(ctx)
	EventProposal := dbquery.Use(db).EventProposal
	query := EventProposal.WithContext(ctx)
	if filter.CityID != nil {
		query = query.Where(EventProposal.CityID.Eq(*filter.CityID))
	}
	if filter.UserID != nil {
		query = query.Where(EventProposal.UserID.Eq(*filter.UserID))
	}
	if len(filter.TopicIds) > 0 {
		query = query.Where(EventProposal.TopicID.In(filter.TopicIds...))
	}
	count, err := query.Count()
	return &models.Summary{Count: int(count)}, err
}

// State is the resolver for the state field.
func (r *userJoinEventProposalResolver) State(ctx context.Context, obj *models.UserJoinEventProposal) (models.JoinEventState, error) {
	return models.JoinEventState(obj.State), nil
}

// EventProposal is the resolver for the eventProposal field.
func (r *userJoinEventProposalResolver) EventProposal(ctx context.Context, obj *models.UserJoinEventProposal) (*models.EventProposal, error) {
	return &models.EventProposal{ID: obj.EventID}, nil
}

// User is the resolver for the user field.
func (r *userJoinEventProposalResolver) User(ctx context.Context, obj *models.UserJoinEventProposal) (*models.User, error) {
	return &models.User{ID: obj.UserID}, nil
}

// EventProposal returns EventProposalResolver implementation.
func (r *Resolver) EventProposal() EventProposalResolver { return &eventProposalResolver{r} }

// UserJoinEventProposal returns UserJoinEventProposalResolver implementation.
func (r *Resolver) UserJoinEventProposal() UserJoinEventProposalResolver {
	return &userJoinEventProposalResolver{r}
}

type eventProposalResolver struct{ *Resolver }
type userJoinEventProposalResolver struct{ *Resolver }

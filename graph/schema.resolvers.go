package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.28

import (
	"context"
	"whale/pkg/dbquery"
	"whale/pkg/loader"
	"whale/pkg/matcher"
	"whale/pkg/models"
	"whale/pkg/modelutil"
	"whale/pkg/whalecode"

	"github.com/letjoy-club/mida-tool/graphqlutil"
	"github.com/letjoy-club/mida-tool/midacode"
	"github.com/letjoy-club/mida-tool/midacontext"
	"github.com/letjoy-club/mida-tool/shortid"
	"github.com/samber/lo"
	"go.uber.org/multierr"
	"gorm.io/gen/field"
	"gorm.io/gorm"
)

// Gender is the resolver for the gender field.
func (r *matchingResolver) Gender(ctx context.Context, obj *models.Matching) (models.Gender, error) {
	return models.Gender(obj.Gender), nil
}

// State is the resolver for the state field.
func (r *matchingResolver) State(ctx context.Context, obj *models.Matching) (models.MatchingState, error) {
	return models.MatchingState(obj.State), nil
}

// ChatGroupState is the resolver for the chatGroupState field.
func (r *matchingResolver) ChatGroupState(ctx context.Context, obj *models.Matching) (models.ChatGroupState, error) {
	return models.ChatGroupState(obj.ChatGroupState), nil
}

// MatchingResult is the resolver for the matchingResult field.
func (r *matchingResolver) MatchingResult(ctx context.Context, obj *models.Matching) (*models.MatchingResult, error) {
	token := midacontext.GetClientToken(ctx)
	if token.IsAnonymous() {
		return nil, midacode.ErrNotPermitted
	}

	if obj.ResultID != 0 {
		thunk := midacontext.GetLoader[loader.Loader](ctx).MatchingResult.Load(ctx, obj.ResultID)
		return thunk()
	}
	return nil, nil
}

// ConfirmStates is the resolver for the confirmStates field.
func (r *matchingResultResolver) ConfirmStates(ctx context.Context, obj *models.MatchingResult) ([]models.MatchingResultConfirmState, error) {
	return lo.Map(obj.ConfirmStates, func(s string, i int) models.MatchingResultConfirmState {
		return models.MatchingResultConfirmState(s)
	}), nil
}

// ChatGroupState is the resolver for the chatGroupState field.
func (r *matchingResultResolver) ChatGroupState(ctx context.Context, obj *models.MatchingResult) (models.ChatGroupState, error) {
	return models.ChatGroupState(obj.ChatGroupState), nil
}

// CreateMatching is the resolver for the createMatching field.
func (r *mutationResolver) CreateMatching(ctx context.Context, userID *string, param models.CreateMatchingParam) (*models.Matching, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsAdmin() && !token.IsUser() {
		return nil, midacode.ErrNotPermitted
	}
	uid := graphqlutil.GetID(token, userID)
	if uid == "" {
		return nil, whalecode.ErrUserIDCannotBeEmpty
	}
	if param.Remark == nil {
		emptyStr := ""
		param.Remark = &emptyStr
	}
	thunk := midacontext.GetLoader[loader.Loader](ctx).MatchingQuota.Load(ctx, uid)
	quota, err := thunk()
	if err != nil {
		return nil, err
	}
	if quota.Remain <= 0 {
		return nil, whalecode.ErrMatchingQuotaNotEnough
	}
	matching := &models.Matching{
		ID:             shortid.New("m_", 8),
		TopicID:        param.TopicID,
		UserID:         uid,
		State:          models.MatchingStateMatching.String(),
		Gender:         param.Gender.String(),
		Remark:         *param.Remark,
		ChatGroupState: string(models.ChatGroupStateUncreated),
	}
	db := midacontext.GetDB(ctx)
	err = db.Transaction(func(tx *gorm.DB) error {
		err = dbquery.Use(tx).Matching.WithContext(ctx).Create(matching)
		if err != nil {
			return err
		}

		MatchingQuota := dbquery.Use(tx).MatchingQuota
		_, err = MatchingQuota.WithContext(ctx).Where(MatchingQuota.UserID.Eq(token.String())).UpdateSimple(MatchingQuota.Remain.Add(-1))
		return err
	})
	midacontext.GetLoader[loader.Loader](ctx).MatchingQuota.Clear(ctx, token.UserID())
	return matching, err
}

// UpdateMatching is the resolver for the updateMatching field.
func (r *mutationResolver) UpdateMatching(ctx context.Context, matchingID string, param models.UpdateMatchingParam) (*models.Matching, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}
	db := midacontext.GetDB(ctx)
	Matching := dbquery.Use(db).Matching
	fields := []field.AssignExpr{}
	if param.AreaIds != nil {
		fields = append(fields, Matching.AreaIDs.Value(graphqlutil.ElementList[string](param.AreaIds)))
	}
	if param.TopicID != nil {
		fields = append(fields, Matching.TopicID.Value(*param.TopicID))
	}
	if param.Gender != nil {
		fields = append(fields, Matching.Gender.Value(param.Gender.String()))
	}
	if param.Deadline != nil {
		fields = append(fields, Matching.Deadline.Value(*param.Deadline))
	}
	_, err := Matching.WithContext(ctx).Where(Matching.ID.Eq(matchingID)).UpdateSimple(fields...)
	return nil, err
}

// ConfirmMatchingResult is the resolver for the confirmMatchingResult field.
func (r *mutationResolver) ConfirmMatchingResult(ctx context.Context, userID *string, matchingID string, reject bool) (*string, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsAdmin() && !token.IsUser() {
		return nil, midacode.ErrNotPermitted
	}

	matchingThunk := midacontext.GetLoader[loader.Loader](ctx).Matching.Load(ctx, matchingID)
	matching, err := matchingThunk()
	if err != nil {
		return nil, err
	}
	if matching == nil {
		return nil, midacode.ErrItemNotFound
	}

	if token.IsUser() {
		if matching.UserID != token.String() {
			return nil, midacode.ErrNotPermitted
		}
	}

	if matching.State != models.MatchingStateMatched.String() {
		return nil, whalecode.ErrMatchingStateShouldBeMatched
	}

	loader := midacontext.GetLoader[loader.Loader](ctx)

	thunk := loader.MatchingResult.Load(ctx, matching.ResultID)
	matchingResult, err := thunk()
	if err != nil {
		return nil, err
	}

	db := midacontext.GetDB(ctx)
	err = db.Transaction(func(tx *gorm.DB) error {
		return modelutil.ConfirmMatching(ctx, tx, matchingResult, matchingID, token.String(), true)
	})
	loader.Matching.Clear(ctx, matchingID)
	return nil, err
}

// CancelMatching is the resolver for the cancelMatching field.
func (r *mutationResolver) CancelMatching(ctx context.Context, matchingID string) (*string, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsAdmin() && !token.IsUser() {
		return nil, midacode.ErrNotPermitted
	}

	matching, err := modelutil.GetMatchingAndCheckUser(ctx, matchingID, token.UserID())
	if err != nil {
		return nil, err
	}

	if matching.State != models.MatchingStateMatching.String() {
		return nil, whalecode.ErrMatchingStateShouldBeMatching
	}

	db := midacontext.GetDB(ctx)
	err = db.Transaction(func(tx *gorm.DB) error {
		Matching := dbquery.Use(db).Matching
		MatchingQuota := dbquery.Use(db).MatchingQuota
		_, err := Matching.WithContext(ctx).Where(Matching.ID.Eq(matchingID)).UpdateSimple(Matching.State.Value(string(models.MatchingStateCanceled)))
		if err != nil {
			return err
		}
		_, err = MatchingQuota.WithContext(ctx).Where(MatchingQuota.UserID.Eq(token.UserID())).UpdateSimple(MatchingQuota.Remain.Add(1))
		return err
	})
	loader := midacontext.GetLoader[loader.Loader](ctx)
	loader.Matching.Clear(ctx, matchingID)
	loader.MatchingQuota.Clear(ctx, token.UserID())
	return nil, err
}

// StartMatching is the resolver for the startMatching field.
func (r *mutationResolver) StartMatching(ctx context.Context) (*string, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}

	matcher := matcher.Matcher{}
	err := matcher.MatchTopics(ctx)
	return nil, err
}

// Matching is the resolver for the matching field.
func (r *queryResolver) Matching(ctx context.Context, id string) (*models.Matching, error) {
	token := midacontext.GetClientToken(ctx)
	if token.IsAnonymous() {
		return nil, midacode.ErrNotPermitted
	}
	thunk := midacontext.GetLoader[loader.Loader](ctx).Matching.Load(ctx, id)
	return thunk()
}

// Matchings is the resolver for the matchings field.
func (r *queryResolver) Matchings(ctx context.Context, filter *models.MatchingFilter, paginator *graphqlutil.GraphQLPaginator) ([]*models.Matching, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}

	db := midacontext.GetDB(ctx)
	Matching := dbquery.Use(db).Matching

	query := Matching.WithContext(ctx)
	if filter != nil {
		if filter.CreateAfter != nil {
			query = query.Where(Matching.CreatedAt.Gt(*filter.CreateAfter))
		}
		if filter.CreateBefore != nil {
			query = query.Where(Matching.CreatedAt.Lt(*filter.CreateBefore))
		}
		if filter.TopicID != nil {
			query = query.Where(Matching.TopicID.Eq(*filter.TopicID))
		}
		if filter.State != nil {
			query = query.Where(Matching.State.Eq(filter.State.String()))
		}
	}
	ids := []string{}
	err := query.Pluck(Matching.ID, &ids)
	if err != nil {
		return nil, err
	}
	thunk := midacontext.GetLoader[loader.Loader](ctx).Matching.LoadMany(ctx, ids)
	matchings, errors := thunk()
	if len(errors) > 0 {
		return nil, multierr.Combine(errors...)
	}
	return matchings, nil
}

// MatchingsCount is the resolver for the matchingsCount field.
func (r *queryResolver) MatchingsCount(ctx context.Context, filter *models.MatchingFilter) (*models.Summary, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}

	db := midacontext.GetDB(ctx)
	Matching := dbquery.Use(db).Matching

	query := Matching.WithContext(ctx)
	if filter != nil {
		if filter.CreateAfter != nil {
			query = query.Where(Matching.CreatedAt.Gt(*filter.CreateAfter))
		}
		if filter.CreateBefore != nil {
			query = query.Where(Matching.CreatedAt.Lt(*filter.CreateBefore))
		}
		if filter.TopicID != nil {
			query = query.Where(Matching.TopicID.Eq(*filter.TopicID))
		}
	}
	count, err := query.Count()
	return &models.Summary{Count: int(count)}, err
}

// UserMatchings is the resolver for the userMatchings field.
func (r *queryResolver) UserMatchings(ctx context.Context, userID *string, filter *models.UserMatchingFilter, paginator *graphqlutil.GraphQLPaginator) ([]*models.Matching, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsUser() && !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}

	uid := graphqlutil.GetID(token, userID)
	if uid == "" {
		return nil, whalecode.ErrUserIDCannotBeEmpty
	}

	db := midacontext.GetDB(ctx)
	Matching := dbquery.Use(db).Matching

	query := Matching.WithContext(ctx).Where(Matching.UserID.Eq(uid))
	if filter != nil {
		if filter.State != nil {
			query = query.Where(Matching.State.Eq(filter.State.String()))
		}
	}
	ids := []string{}
	err := query.Pluck(Matching.ID, &ids)
	if err != nil {
		return nil, err
	}
	thunk := midacontext.GetLoader[loader.Loader](ctx).Matching.LoadMany(ctx, ids)
	matchings, errors := thunk()
	if len(errors) > 0 {
		return nil, multierr.Combine(errors...)
	}
	return matchings, nil
}

// UserMatchingsCount is the resolver for the userMatchingsCount field.
func (r *queryResolver) UserMatchingsCount(ctx context.Context, userID *string, filter *models.UserMatchingFilter) (*models.Summary, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsUser() && !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}

	uid := graphqlutil.GetID(token, userID)
	if uid == "" {
		return nil, whalecode.ErrUserIDCannotBeEmpty
	}

	db := midacontext.GetDB(ctx)
	Matching := dbquery.Use(db).Matching

	query := Matching.WithContext(ctx).Where(Matching.UserID.Eq(uid))
	if filter != nil {
		if filter.State != nil {
			query = query.Where(Matching.State.Eq(filter.State.String()))
		}
	}
	count, err := query.Count()
	return &models.Summary{Count: int(count)}, err
}

// Matching returns MatchingResolver implementation.
func (r *Resolver) Matching() MatchingResolver { return &matchingResolver{r} }

// MatchingResult returns MatchingResultResolver implementation.
func (r *Resolver) MatchingResult() MatchingResultResolver { return &matchingResultResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type matchingResolver struct{ *Resolver }
type matchingResultResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.35

import (
	"context"
	"math/rand"
	"time"
	"whale/pkg/dbquery"
	"whale/pkg/loader"
	"whale/pkg/matcher"
	"whale/pkg/models"
	"whale/pkg/modelutil"
	"whale/pkg/utils"

	"github.com/letjoy-club/mida-tool/dbutil"
	"github.com/letjoy-club/mida-tool/midacode"
	"github.com/letjoy-club/mida-tool/midacontext"
	"github.com/samber/lo"
	"go.uber.org/multierr"
	"gorm.io/gen/field"
)

// Topics is the resolver for the topics field.
func (r *cityTopicsResolver) Topics(ctx context.Context, obj *models.CityTopics) ([]*models.Topic, error) {
	return lo.Map(obj.TopicIDs, func(topicId string, i int) *models.Topic {
		return &models.Topic{ID: topicId}
	}), nil
}

// City is the resolver for the city field.
func (r *cityTopicsResolver) City(ctx context.Context, obj *models.CityTopics) (*models.Area, error) {
	return &models.Area{Code: obj.CityID}, nil
}

// FailedReason is the resolver for the failedReason field.
func (r *evaluatorResultResolver) FailedReason(ctx context.Context, obj *matcher.EvaluatorResult) (string, error) {
	return string(obj.FailedReason), nil
}

// City is the resolver for the city field.
func (r *hotTopicsInAreaResolver) City(ctx context.Context, obj *models.HotTopicsInArea) (*models.Area, error) {
	return &models.Area{Code: obj.CityID}, nil
}

// Gender is the resolver for the gender field.
func (r *matchingResolver) Gender(ctx context.Context, obj *models.Matching) (models.Gender, error) {
	return models.Gender(obj.Gender), nil
}

// State is the resolver for the state field.
func (r *matchingResolver) State(ctx context.Context, obj *models.Matching) (models.MatchingState, error) {
	return models.MatchingState(obj.State), nil
}

// PreferredPeriods is the resolver for the preferredPeriods field.
func (r *matchingResolver) PreferredPeriods(ctx context.Context, obj *models.Matching) ([]models.DatePeriod, error) {
	return lo.Map(obj.PreferredPeriods, func(p string, i int) models.DatePeriod {
		return models.DatePeriod(p)
	}), nil
}

// MatchingResult is the resolver for the matchingResult field.
func (r *matchingResolver) MatchingResult(ctx context.Context, obj *models.Matching) (*models.MatchingResult, error) {
	token := midacontext.GetClientToken(ctx)
	if token.IsAnonymous() {
		return nil, midacode.ErrNotPermitted
	}

	if obj.ResultID != 0 {
		thunk := midacontext.GetLoader[loader.Loader](ctx).MatchingResult.Load(ctx, obj.ResultID)
		return thunk()
	}
	return nil, nil
}

// Reviewed is the resolver for the reviewed field.
func (r *matchingResolver) Reviewed(ctx context.Context, obj *models.Matching) (bool, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsAdmin() && !token.IsUser() {
		return false, midacode.ErrNotPermitted
	}

	if obj.ResultID == 0 || obj.FinishedAt == nil {
		return false, nil
	}

	thunk := midacontext.GetLoader[loader.Loader](ctx).MatchingReviewed.Load(ctx, obj.ID)
	reviewd, err := thunk()
	if err != nil {
		return false, nil
	}
	return reviewd.Reviewed, nil
}

// User is the resolver for the user field.
func (r *matchingResolver) User(ctx context.Context, obj *models.Matching) (*models.User, error) {
	return &models.User{ID: obj.UserID}, nil
}

// Topic is the resolver for the topic field.
func (r *matchingResolver) Topic(ctx context.Context, obj *models.Matching) (*models.Topic, error) {
	return &models.Topic{ID: obj.TopicID}, nil
}

// Area is the resolver for the area field.
func (r *matchingResolver) Areas(ctx context.Context, obj *models.Matching) ([]*models.Area, error) {
	return lo.Map(obj.AreaIDs, func(id string, i int) *models.Area {
		return &models.Area{Code: id}
	}), nil
}

// City is the resolver for the city field.
func (r *matchingResolver) City(ctx context.Context, obj *models.Matching) (*models.Area, error) {
	return &models.Area{Code: obj.CityID}, nil
}

// ConfirmState is the resolver for the confirmState field.
func (r *matchingInvitationResolver) ConfirmState(ctx context.Context, obj *models.MatchingInvitation) (models.InvitationConfirmState, error) {
	return models.InvitationConfirmState(obj.ConfirmState), nil
}

// Invitee is the resolver for the invitee field.
func (r *matchingInvitationResolver) Invitee(ctx context.Context, obj *models.MatchingInvitation) (*models.User, error) {
	return &models.User{ID: obj.InviteeID}, nil
}

// Topic is the resolver for the topic field.
func (r *matchingInvitationResolver) Topic(ctx context.Context, obj *models.MatchingInvitation) (*models.Topic, error) {
	return &models.Topic{ID: obj.TopicID}, nil
}

// Areas is the resolver for the areas field.
func (r *matchingInvitationResolver) Areas(ctx context.Context, obj *models.MatchingInvitation) ([]*models.Area, error) {
	return lo.Map(obj.AreaIDs, func(id string, i int) *models.Area {
		return &models.Area{Code: id}
	}), nil
}

// City is the resolver for the city field.
func (r *matchingInvitationResolver) City(ctx context.Context, obj *models.MatchingInvitation) (*models.Area, error) {
	return &models.Area{Code: obj.CityID}, nil
}

// User is the resolver for the user field.
func (r *matchingInvitationResolver) User(ctx context.Context, obj *models.MatchingInvitation) (*models.User, error) {
	return &models.User{ID: obj.UserID}, nil
}

// MatchingResult is the resolver for the matchingResult field.
func (r *matchingInvitationResolver) MatchingResult(ctx context.Context, obj *models.MatchingInvitation) (*models.MatchingResult, error) {
	if obj.MatchingResultId == 0 {
		return nil, nil
	}
	thunk := midacontext.GetLoader[loader.Loader](ctx).MatchingResult.Load(ctx, obj.MatchingResultId)
	return thunk()
}

// Gender is the resolver for the gender field.
func (r *matchingOfTopicResolver) Gender(ctx context.Context, obj *models.Matching) (models.Gender, error) {
	return models.Gender(obj.Gender), nil
}

// User is the resolver for the user field.
func (r *matchingOfTopicResolver) User(ctx context.Context, obj *models.Matching) (*models.User, error) {
	return &models.User{ID: obj.UserID}, nil
}

// City is the resolver for the city field.
func (r *matchingOfTopicResolver) City(ctx context.Context, obj *models.Matching) (*models.Area, error) {
	return &models.Area{Code: obj.CityID}, nil
}

// AreaIds is the resolver for the areaIds field.
func (r *matchingOfTopicResolver) Areas(ctx context.Context, obj *models.Matching) ([]*models.Area, error) {
	return lo.Map(obj.AreaIDs, func(id string, i int) *models.Area {
		return &models.Area{Code: id}
	}), nil
}

// PreferredPeriods is the resolver for the preferredPeriods field.
func (r *matchingPreviewResolver) PreferredPeriods(ctx context.Context, obj *models.Matching) ([]models.DatePeriod, error) {
	return lo.Map(obj.PreferredPeriods, func(p string, i int) models.DatePeriod {
		return models.DatePeriod(p)
	}), nil
}

// TopicOptionConfig is the resolver for the topicOptionConfig field.
func (r *matchingPreviewResolver) TopicOptionConfig(ctx context.Context, obj *models.Matching) (*models.TopicOptionConfig, error) {
	return &models.TopicOptionConfig{TopicID: obj.TopicID}, nil
}

// User is the resolver for the user field.
func (r *matchingPreviewResolver) User(ctx context.Context, obj *models.Matching) (*models.User, error) {
	return &models.User{ID: obj.UserID}, nil
}

// ConfirmStates is the resolver for the confirmStates field.
func (r *matchingResultResolver) ConfirmStates(ctx context.Context, obj *models.MatchingResult) ([]models.MatchingResultConfirmState, error) {
	return lo.Map(obj.ConfirmStates, func(s string, i int) models.MatchingResultConfirmState {
		return models.MatchingResultConfirmState(s)
	}), nil
}

// UserConfirmStates is the resolver for the userConfirmStates field.
func (r *matchingResultResolver) UserConfirmStates(ctx context.Context, obj *models.MatchingResult) ([]*models.UserConfirmState, error) {
	return lo.Map(obj.ConfirmStates, func(state string, i int) *models.UserConfirmState {
		return &models.UserConfirmState{
			UserID: obj.UserIDs[i],
			State:  models.MatchingResultConfirmState(state),
		}
	}), nil
}

// ChatGroupState is the resolver for the chatGroupState field.
func (r *matchingResultResolver) ChatGroupState(ctx context.Context, obj *models.MatchingResult) (models.ChatGroupState, error) {
	return models.ChatGroupState(obj.ChatGroupState), nil
}

// CreatedBy is the resolver for the createdBy field.
func (r *matchingResultResolver) CreatedBy(ctx context.Context, obj *models.MatchingResult) (models.ResultCreatedBy, error) {
	if obj.CreatedBy == "" {
		return models.ResultCreatedByMatching, nil
	}
	return models.ResultCreatedBy(obj.CreatedBy), nil
}

// Users is the resolver for the users field.
func (r *matchingResultResolver) Users(ctx context.Context, obj *models.MatchingResult) ([]*models.User, error) {
	return lo.Map(obj.UserIDs, func(id string, i int) *models.User {
		return &models.User{ID: id}
	}), nil
}

// DiscoverMotion is the resolver for the discoverMotion field.
func (r *matchingResultResolver) DiscoverMotion(ctx context.Context, obj *models.MatchingResult) ([]*models.Motion, error) {
	if obj.CreatedBy != models.ResultCreatedByOffer.String() {
		return nil, nil
	}
	thunk := midacontext.GetLoader[loader.Loader](ctx).Motion.LoadMany(ctx, obj.MotionIDs)
	return utils.ReturnThunk(thunk)
}

// MatchingPreviews is the resolver for the matchingPreviews field.
func (r *matchingResultResolver) MatchingPreviews(ctx context.Context, obj *models.MatchingResult) ([]*models.Matching, error) {
	if obj.CreatedBy != models.ResultCreatedByMatching.String() && obj.CreatedBy != models.ResultCreatedByInvitation.String() {
		return nil, nil
	}
	thunk := midacontext.GetLoader[loader.Loader](ctx).Matching.LoadMany(ctx, obj.MatchingIDs)
	return utils.ReturnThunk(thunk)
}

// Topic is the resolver for the topic field.
func (r *matchingResultResolver) Topic(ctx context.Context, obj *models.MatchingResult) (*models.Topic, error) {
	return &models.Topic{ID: obj.TopicID}, nil
}

// ChatGroup is the resolver for the chatGroup field.
func (r *matchingResultResolver) ChatGroup(ctx context.Context, obj *models.MatchingResult) (*models.ChatGroup, error) {
	if obj.ChatGroupID == "" {
		return nil, nil
	}
	return &models.ChatGroup{ID: obj.ChatGroupID}, nil
}

// MatchingDegree is the resolver for the matchingDegree field.
func (r *matchingResultResolver) MatchingDegree(ctx context.Context, obj *models.MatchingResult) (int, error) {
	if obj.MatchingScore == 0 {
		return 80, nil
	}
	return 80 + (obj.MatchingScore * 2 / 10), nil
}

// RefreshTopicMetrics is the resolver for the refreshTopicMetrics field.
func (r *mutationResolver) RefreshTopicMetrics(ctx context.Context) (*string, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}

	err := modelutil.RefreshHotTopic(ctx, time.Now().Add(time.Hour*24*-10))
	midacontext.GetLoader[loader.Loader](ctx).HotTopics.ClearAll()
	return nil, err
}

// UpdateDurationConstraint is the resolver for the updateDurationConstraint field.
func (r *mutationResolver) UpdateDurationConstraint(ctx context.Context, userID string, param models.UpdateDurationConstraintParam) (*string, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}
	db := dbutil.GetDB(ctx)
	DurationConstraint := dbquery.Use(db).DurationConstraint

	query := DurationConstraint.WithContext(ctx).Where(DurationConstraint.UserID.Eq(userID), DurationConstraint.StartDate.Lt(time.Now()), DurationConstraint.StopDate.Gt(time.Now()))

	fields := []field.AssignExpr{}
	if param.RemainMotionQuota != nil {
		fields = append(fields, DurationConstraint.RemainMotionQuota.Value(*param.RemainMotionQuota))
	}
	if param.TotalMotionQuota != nil {
		fields = append(fields, DurationConstraint.TotalMotionQuota.Value(*param.TotalMotionQuota))
	}

	if param.StopDate != nil {
		fields = append(fields, DurationConstraint.StopDate.Value(*param.StopDate))
	}
	if param.StopDate != nil {
		fields = append(fields, DurationConstraint.StopDate.Value(*param.StopDate))
	}
	_, err := query.UpdateSimple(fields...)
	if err != nil {
		return nil, err
	}
	midacontext.GetLoader[loader.Loader](ctx).DurationConstraint.Clear(ctx, userID)
	return nil, nil
}

// ChatGroupByResultID is the resolver for the ChatGroupByResultId field.
func (r *queryResolver) ChatGroupByResultID(ctx context.Context, resultID int) (*models.ChatGroup, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}
	thunk := midacontext.GetLoader[loader.Loader](ctx).MatchingResult.Load(ctx, resultID)
	result, err := thunk()
	if err != nil {
		return nil, err
	}
	return &models.ChatGroup{ID: result.ChatGroupID}, nil
}

// GetDurationConstraint is the resolver for the getDurationConstraint field.
func (r *queryResolver) UserDurationConstraint(ctx context.Context, userID string) (*models.DurationConstraint, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}
	thunk := midacontext.GetLoader[loader.Loader](ctx).DurationConstraint.Load(ctx, userID)
	return thunk()
}

// RecentUsers is the resolver for the recentUsers field.
func (r *topicResolver) RecentUsers(ctx context.Context, obj *models.Topic, cityID *string) ([]*models.SimpleAvatarUser, error) {
	db := dbutil.GetDB(ctx)
	UserJoinTopic := dbquery.Use(db).UserJoinTopic

	userIDs := []string{}
	if cityID != nil {
		err := UserJoinTopic.WithContext(ctx).
			Where(UserJoinTopic.CityID.Eq(*cityID)).
			Where(UserJoinTopic.TopicID.Eq(obj.ID)).
			Limit(5).Order(UserJoinTopic.UpdatedAt.Desc()).
			Pluck(UserJoinTopic.UserID, &userIDs)
		if err != nil {
			return nil, err
		}
	}
	if len(userIDs) == 0 {
		err := UserJoinTopic.WithContext(ctx).
			Where(UserJoinTopic.CityID.Eq("310100")).
			Where(UserJoinTopic.TopicID.Eq(obj.ID)).
			Limit(30).Order(UserJoinTopic.UpdatedAt.Desc()).
			Pluck(UserJoinTopic.UserID, &userIDs)
		if err != nil {
			return nil, err
		}
		userIDs = lo.Uniq(userIDs)
	}
	if len(userIDs) != 0 {
		thunk := midacontext.GetLoader[loader.Loader](ctx).UserAvatarNickname.LoadMany(ctx, userIDs)
		avatarNickname, errors := thunk()
		if errors != nil {
			return nil, multierr.Combine(errors...)
		}
		users := lo.Map(avatarNickname, func(u loader.UserAvatarNickname, i int) *models.SimpleAvatarUser {
			return &models.SimpleAvatarUser{
				Avatar:   u.Avatar,
				Nickname: u.Nickname,
			}
		})
		return users, nil
	}
	return []*models.SimpleAvatarUser{}, nil
}

// MatchingNum is the resolver for the matchingNum field.
func (r *topicResolver) MatchingNum(ctx context.Context, obj *models.Topic, cityID *string) (int, error) {
	if cityID == nil {
		sh := "310100"
		cityID = &sh
	}
	thunk := midacontext.GetLoader[loader.Loader](ctx).CityTopicRequestNum.Load(ctx, *cityID)
	requestNum, err := thunk()
	if err != nil {
		return 0, err
	}
	return requestNum.RequestNum[obj.ID], nil
}

// FuzzyMatchingNum is the resolver for the fuzzyMatchingNum field.
func (r *topicResolver) FuzzyMatchingNum(ctx context.Context, obj *models.Topic, cityID *string) (int, error) {
	if cityID == nil {
		sh := "310100"
		cityID = &sh
	}
	thunk := midacontext.GetLoader[loader.Loader](ctx).CityTopicRequestNum.Load(ctx, *cityID)
	requestNum, err := thunk()
	if err != nil {
		return 0, err
	}
	count := requestNum.RequestNum[obj.ID]
	if count <= 3 {
		remain := rand.Int() % 3
		return 3 + remain, nil
	}
	if count >= 1000 {
		return 999, nil
	}

	base := float64(count)
	newCount := base * (1.3 - 3*base*base/10000000)
	if newCount >= 1000 {
		return 999, nil
	}
	return int(newCount), nil
}

// Topic is the resolver for the topic field.
func (r *topicMetricsResolver) Topic(ctx context.Context, obj *models.TopicMetrics) (*models.Topic, error) {
	return &models.Topic{ID: obj.ID}, nil
}

// MatchingQuota is the resolver for the matchingQuota field.
func (r *userResolver) MatchingQuota(ctx context.Context, obj *models.User) (*models.MatchingQuota, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsAdmin() && !token.IsUser() {
		return nil, midacode.ErrNotPermitted
	}
	if token.IsUser() {
		if token.String() != obj.ID {
			return nil, midacode.ErrNotPermitted
		}
	}
	thunk := midacontext.GetLoader[loader.Loader](ctx).MatchingQuota.Load(ctx, obj.ID)
	return thunk()
}

// CityTopics returns CityTopicsResolver implementation.
func (r *Resolver) CityTopics() CityTopicsResolver { return &cityTopicsResolver{r} }

// EvaluatorResult returns EvaluatorResultResolver implementation.
func (r *Resolver) EvaluatorResult() EvaluatorResultResolver { return &evaluatorResultResolver{r} }

// HotTopicsInArea returns HotTopicsInAreaResolver implementation.
func (r *Resolver) HotTopicsInArea() HotTopicsInAreaResolver { return &hotTopicsInAreaResolver{r} }

// Matching returns MatchingResolver implementation.
func (r *Resolver) Matching() MatchingResolver { return &matchingResolver{r} }

// MatchingInvitation returns MatchingInvitationResolver implementation.
func (r *Resolver) MatchingInvitation() MatchingInvitationResolver {
	return &matchingInvitationResolver{r}
}

// MatchingOfTopic returns MatchingOfTopicResolver implementation.
func (r *Resolver) MatchingOfTopic() MatchingOfTopicResolver { return &matchingOfTopicResolver{r} }

// MatchingPreview returns MatchingPreviewResolver implementation.
func (r *Resolver) MatchingPreview() MatchingPreviewResolver { return &matchingPreviewResolver{r} }

// MatchingResult returns MatchingResultResolver implementation.
func (r *Resolver) MatchingResult() MatchingResultResolver { return &matchingResultResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Topic returns TopicResolver implementation.
func (r *Resolver) Topic() TopicResolver { return &topicResolver{r} }

// TopicMetrics returns TopicMetricsResolver implementation.
func (r *Resolver) TopicMetrics() TopicMetricsResolver { return &topicMetricsResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type cityTopicsResolver struct{ *Resolver }
type evaluatorResultResolver struct{ *Resolver }
type hotTopicsInAreaResolver struct{ *Resolver }
type matchingResolver struct{ *Resolver }
type matchingInvitationResolver struct{ *Resolver }
type matchingOfTopicResolver struct{ *Resolver }
type matchingPreviewResolver struct{ *Resolver }
type matchingResultResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type topicResolver struct{ *Resolver }
type topicMetricsResolver struct{ *Resolver }
type userResolver struct{ *Resolver }

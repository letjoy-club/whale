package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.28

import (
	"context"
	"whale/pkg/dbquery"
	"whale/pkg/keyer"
	"whale/pkg/loader"
	"whale/pkg/models"
	"whale/pkg/modelutil"
	"whale/pkg/whalecode"

	"github.com/letjoy-club/mida-tool/dbutil"
	"github.com/letjoy-club/mida-tool/graphqlutil"
	"github.com/letjoy-club/mida-tool/midacode"
	"github.com/letjoy-club/mida-tool/midacontext"
	"go.uber.org/multierr"
	"gorm.io/gen/field"
)

// CreateMatchingInvitation is the resolver for the createMatchingInvitation field.
func (r *mutationResolver) CreateMatchingInvitation(ctx context.Context, userID *string, param models.CreateMatchingInvitationParam) (*models.MatchingInvitation, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsAdmin() && !token.IsUser() {
		return nil, midacode.ErrNotPermitted
	}
	uid := graphqlutil.GetID(token, userID)
	if uid == "" {
		return nil, whalecode.ErrUserIDCannotBeEmpty
	}
	if uid == param.InviteeID {
		return nil, whalecode.ErrCannotInviteSelf
	}
	release, err := keyer.LockAll(ctx, keyer.UserMatching(uid))
	if err != nil {
		return nil, err
	}
	defer release(ctx)
	return modelutil.CreateMatchingInvitation(ctx, uid, param)
}

// CancelMatchingInvitation is the resolver for the cancelMatchingInvitation field.
func (r *mutationResolver) CancelMatchingInvitation(ctx context.Context, invitationID string) (*string, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsAdmin() && !token.IsUser() {
		return nil, midacode.ErrNotPermitted
	}
	uid := ""
	if token.IsUser() {
		uid = token.String()
	}

	release, err := keyer.LockAll(ctx, keyer.UserMatching(uid), keyer.Invitation(invitationID))
	if err != nil {
		return nil, err
	}

	defer release(ctx)
	return nil, modelutil.CancelMatchingInvitation(ctx, uid, invitationID)
}

// ConfirmMatchingInvitation is the resolver for the confirmMatchingInvitation field.
func (r *mutationResolver) ConfirmMatchingInvitation(ctx context.Context, userID *string, invitationID string, confirm bool) (*string, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsAdmin() && !token.IsUser() {
		return nil, midacode.ErrNotPermitted
	}
	thunk := midacontext.GetLoader[loader.Loader](ctx).MatchingInvitation.Load(ctx, invitationID)
	invitation, err := thunk()
	if err != nil {
		return nil, err
	}
	uid := ""
	if token.IsUser() {
		uid = token.String()
		if uid != invitation.InviteeID {
			return nil, err
		}
	}
	release, err := keyer.LockAll(ctx, keyer.UserMatching(uid), keyer.Invitation(invitationID))
	if err != nil {
		return nil, err
	}
	defer release(ctx)

	if confirm {
		return nil, modelutil.AcceptMatchingInvitation(ctx, invitation)
	} else {
		return nil, modelutil.RejectMatchingInvitation(ctx, invitation)
	}
}

// UpdateMatchingInvitation is the resolver for the updateMatchingInvitation field.
func (r *mutationResolver) UpdateMatchingInvitation(ctx context.Context, invitationID string, param models.UpdateMatchingInvitationParam) (*models.MatchingInvitation, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}
	db := dbutil.GetDB(ctx)
	MatchingInvitation := dbquery.Use(db).MatchingInvitation
	fields := []field.AssignExpr{}
	if param.CityID != nil {
		fields = append(fields, MatchingInvitation.CityID.Value(*param.CityID))
	}
	if param.CreatedAt != nil {
		fields = append(fields, MatchingInvitation.CreatedAt.Value(*param.CreatedAt))
	}
	if param.InviteeID != nil {
		fields = append(fields, MatchingInvitation.InviteeID.Value(*param.InviteeID))
	}
	if param.Remark != nil {
		fields = append(fields, MatchingInvitation.Remark.Value(*param.Remark))
	}
	if param.TopicID != nil {
		fields = append(fields, MatchingInvitation.TopicID.Value(*param.TopicID))
	}
	midacontext.GetLoader[loader.Loader](ctx).MatchingInvitation.Clear(ctx, invitationID)
	_, err := MatchingInvitation.WithContext(ctx).Where(MatchingInvitation.ID.Eq(invitationID)).UpdateSimple(fields...)
	if err != nil {
		return nil, err
	}
	thunk := midacontext.GetLoader[loader.Loader](ctx).MatchingInvitation.Load(ctx, invitationID)
	return thunk()
}

// MatchingInvitations is the resolver for the matchingInvitations field.
func (r *queryResolver) MatchingInvitations(ctx context.Context, filter *models.MatchingInvitationFilter, paginator *graphqlutil.GraphQLPaginator) ([]*models.MatchingInvitation, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsUser() && !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}

	pager := graphqlutil.GetPager(paginator)

	db := dbutil.GetDB(ctx)
	MatchingInvitation := dbquery.Use(db).MatchingInvitation
	query := MatchingInvitation.WithContext(ctx)

	if filter.After != nil {
		query = query.Where(MatchingInvitation.CreatedAt.Gt(*filter.After))
	}
	if filter.Before != nil {
		query = query.Where(MatchingInvitation.CreatedAt.Lt(*filter.Before))
	}
	if filter.UserID != nil {
		query = query.Where(MatchingInvitation.UserID.Eq(*filter.UserID))
	}
	invitationIDs := []string{}
	err := query.Limit(pager.Limit()).Offset(pager.Offset()).Order(MatchingInvitation.CreatedAt.Desc()).Pluck(MatchingInvitation.ID, &invitationIDs)
	if err != nil {
		return nil, err
	}

	thunk := midacontext.GetLoader[loader.Loader](ctx).MatchingInvitation.LoadMany(ctx, invitationIDs)
	invitations, errors := thunk()
	if errors != nil {
		return nil, multierr.Combine(errors...)
	}
	return invitations, nil
}

// MatchingInvitationsCount is the resolver for the matchingInvitationsCount field.
func (r *queryResolver) MatchingInvitationsCount(ctx context.Context, filter *models.MatchingInvitationFilter) (*models.Summary, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsUser() && !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}

	db := dbutil.GetDB(ctx)
	MatchingInvitation := dbquery.Use(db).MatchingInvitation
	query := MatchingInvitation.WithContext(ctx)

	if filter.After != nil {
		query = query.Where(MatchingInvitation.CreatedAt.Gt(*filter.After))
	}
	if filter.Before != nil {
		query = query.Where(MatchingInvitation.CreatedAt.Lt(*filter.Before))
	}
	if filter.UserID != nil {
		query = query.Where(MatchingInvitation.UserID.Eq(*filter.UserID))
	}

	count, err := query.Count()
	return &models.Summary{Count: int(count)}, err
}

// Invitations is the resolver for the invitations field.
func (r *queryResolver) Invitations(ctx context.Context, userID *string, paginator *graphqlutil.GraphQLPaginator) ([]*models.MatchingInvitation, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsUser() && !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}
	pager := graphqlutil.GetPager(paginator)
	uid := graphqlutil.GetID(token, userID)
	if uid == "" {
		return nil, whalecode.ErrUserIDCannotBeEmpty
	}

	db := dbutil.GetDB(ctx)
	ids := []string{}
	MatchingInvitation := dbquery.Use(db).MatchingInvitation
	err := MatchingInvitation.WithContext(ctx).
		Where(MatchingInvitation.UserID.Eq(uid)).
		Order(MatchingInvitation.CreatedAt.Desc()).
		Offset(pager.Offset()).
		Limit(pager.Limit()).
		Pluck(MatchingInvitation.ID, &ids)
	if err != nil {
		return nil, err
	}
	thunk := midacontext.GetLoader[loader.Loader](ctx).MatchingInvitation.LoadMany(ctx, ids)
	invitations, errors := thunk()
	if len(errors) > 0 {
		return nil, multierr.Combine(errors...)
	}
	return invitations, nil
}

// Invitation is the resolver for the invitation field.
func (r *queryResolver) Invitation(ctx context.Context, userID *string, id string) (*models.MatchingInvitation, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsUser() && !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}
	thunk := midacontext.GetLoader[loader.Loader](ctx).MatchingInvitation.Load(ctx, id)
	invitation, err := thunk()
	if err != nil {
		return nil, err
	}
	if token.IsUser() {
		if invitation.UserID != token.String() && invitation.InviteeID != token.String() {
			return nil, midacode.ErrNotPermitted
		}
	}
	return invitation, nil
}

// InvitationsCount is the resolver for the invitationsCount field.
func (r *queryResolver) InvitationsCount(ctx context.Context, userID *string) (*models.Summary, error) {
	token := midacontext.GetClientToken(ctx)
	if !token.IsUser() && !token.IsAdmin() {
		return nil, midacode.ErrNotPermitted
	}
	uid := graphqlutil.GetID(token, userID)
	if uid == "" {
		return nil, whalecode.ErrUserIDCannotBeEmpty
	}

	db := dbutil.GetDB(ctx)
	MatchingInvitation := dbquery.Use(db).MatchingInvitation
	count, err := MatchingInvitation.WithContext(ctx).Where(MatchingInvitation.UserID.Eq(uid)).Count()
	if err != nil {
		return nil, err
	}
	return &models.Summary{Count: int(count)}, nil
}

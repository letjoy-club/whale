// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"
	"whale/pkg/matcher"
	"whale/pkg/models"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/99designs/gqlgen/plugin/federation/fedruntime"
	"github.com/letjoy-club/mida-tool/graphqlutil"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	CityToTopicMatching() CityToTopicMatchingResolver
	CityTopics() CityTopicsResolver
	DiscoverMotion() DiscoverMotionResolver
	Entity() EntityResolver
	EvaluatorResult() EvaluatorResultResolver
	HotTopicsInArea() HotTopicsInAreaResolver
	Matching() MatchingResolver
	MatchingInvitation() MatchingInvitationResolver
	MatchingOfTopic() MatchingOfTopicResolver
	MatchingPreview() MatchingPreviewResolver
	MatchingResult() MatchingResultResolver
	Motion() MotionResolver
	MotionOfferRecord() MotionOfferRecordResolver
	Mutation() MutationResolver
	Query() QueryResolver
	RecentMatching() RecentMatchingResolver
	Topic() TopicResolver
	TopicMetrics() TopicMetricsResolver
	TopicToMatching() TopicToMatchingResolver
	User() UserResolver
	UserJoinTopic() UserJoinTopicResolver
	UserLikeMotion() UserLikeMotionResolver
}

type DirectiveRoot struct {
	AdminOnly        func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	ComposeDirective func(ctx context.Context, obj interface{}, next graphql.Resolver, name string) (res interface{}, err error)
	InterfaceObject  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	Area struct {
		Code func(childComplexity int) int
	}

	AvailableMotionOffer struct {
		Motion        func(childComplexity int) int
		NextQuotaTime func(childComplexity int) int
	}

	CalendarEvent struct {
		ChatGroupCreatedAt func(childComplexity int) int
		FinishedAt         func(childComplexity int) int
		MatchedAt          func(childComplexity int) int
		TopicID            func(childComplexity int) int
	}

	ChatGroup struct {
		ID func(childComplexity int) int
	}

	CityToTopicMatching struct {
		City   func(childComplexity int) int
		CityID func(childComplexity int) int
		Topics func(childComplexity int) int
	}

	CityTopics struct {
		City      func(childComplexity int) int
		CityID    func(childComplexity int) int
		TopicIDs  func(childComplexity int) int
		Topics    func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	CreateMotionOfferResult struct {
		ChatGroupID func(childComplexity int) int
	}

	DiscoverMotion struct {
		AreaIDs           func(childComplexity int) int
		Areas             func(childComplexity int) int
		City              func(childComplexity int) int
		CityID            func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		DayRange          func(childComplexity int) int
		Gender            func(childComplexity int) int
		ID                func(childComplexity int) int
		LikeCount         func(childComplexity int) int
		Liked             func(childComplexity int, userID *string) int
		PreferredPeriods  func(childComplexity int) int
		Properties        func(childComplexity int) int
		Remark            func(childComplexity int) int
		Submitted         func(childComplexity int, userID *string) int
		ThumbsUp          func(childComplexity int, userID *string) int
		ThumbsUpCount     func(childComplexity int) int
		Topic             func(childComplexity int) int
		TopicID           func(childComplexity int) int
		TopicOptionConfig func(childComplexity int) int
		User              func(childComplexity int) int
		UserID            func(childComplexity int) int
		ViewCount         func(childComplexity int) int
	}

	DiscoverMotionResult struct {
		Motions   func(childComplexity int) int
		NextToken func(childComplexity int) int
	}

	DurationConstraint struct {
		RemainMotionQuota func(childComplexity int) int
		StartDate         func(childComplexity int) int
		StopDate          func(childComplexity int) int
		TotalMotionQuota  func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
		UserID            func(childComplexity int) int
	}

	Entity struct {
		FindLevelRightsByLevel    func(childComplexity int, level int) int
		FindMatchingByID          func(childComplexity int, id string) int
		FindMatchingQuotaByUserID func(childComplexity int, userID string) int
		FindTopicByID             func(childComplexity int, id string) int
		FindUserByID              func(childComplexity int, id string) int
	}

	EvaluatorResult struct {
		FailedReason func(childComplexity int) int
		Properties   func(childComplexity int) int
		Score        func(childComplexity int) int
		TimeScore    func(childComplexity int) int
	}

	HotTopicsInArea struct {
		City         func(childComplexity int) int
		CityID       func(childComplexity int) int
		TopicMetrics func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
	}

	LevelRights struct {
		Level                      func(childComplexity int) int
		MatchingDurationConstraint func(childComplexity int) int
		MatchingQuota              func(childComplexity int) int
	}

	Matching struct {
		AreaIDs          func(childComplexity int) int
		Areas            func(childComplexity int) int
		City             func(childComplexity int) int
		CityID           func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		DayRange         func(childComplexity int) int
		Deadline         func(childComplexity int) int
		Gender           func(childComplexity int) int
		ID               func(childComplexity int) int
		InChatGroup      func(childComplexity int) int
		MatchingResult   func(childComplexity int) int
		PreferredPeriods func(childComplexity int) int
		Properties       func(childComplexity int) int
		RejectedUserIDs  func(childComplexity int) int
		Remark           func(childComplexity int) int
		Reviewed         func(childComplexity int) int
		StartMatchingAt  func(childComplexity int) int
		State            func(childComplexity int) int
		Topic            func(childComplexity int) int
		TopicID          func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
		User             func(childComplexity int) int
		UserID           func(childComplexity int) int
	}

	MatchingDurationConstraint struct {
		Remain    func(childComplexity int) int
		StartDate func(childComplexity int) int
		StopDate  func(childComplexity int) int
		Total     func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	MatchingInvitation struct {
		AreaIDs          func(childComplexity int) int
		Areas            func(childComplexity int) int
		City             func(childComplexity int) int
		CityID           func(childComplexity int) int
		ConfirmState     func(childComplexity int) int
		ConfirmedAt      func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		ID               func(childComplexity int) int
		Invitee          func(childComplexity int) int
		InviteeID        func(childComplexity int) int
		MatchingIds      func(childComplexity int) int
		MatchingResult   func(childComplexity int) int
		MatchingResultId func(childComplexity int) int
		Remark           func(childComplexity int) int
		Topic            func(childComplexity int) int
		TopicID          func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
		User             func(childComplexity int) int
		UserID           func(childComplexity int) int
	}

	MatchingOfTopic struct {
		AreaIDs   func(childComplexity int) int
		Areas     func(childComplexity int) int
		City      func(childComplexity int) int
		CityID    func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		Gender    func(childComplexity int) int
		Remark    func(childComplexity int) int
		User      func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	MatchingPreview struct {
		DayRange          func(childComplexity int) int
		PreferredPeriods  func(childComplexity int) int
		Properties        func(childComplexity int) int
		Remark            func(childComplexity int) int
		TopicOptionConfig func(childComplexity int) int
		User              func(childComplexity int) int
		UserID            func(childComplexity int) int
	}

	MatchingProperty struct {
		ID     func(childComplexity int) int
		Values func(childComplexity int) int
	}

	MatchingQuota struct {
		CreatedAt   func(childComplexity int) int
		MatchingNum func(childComplexity int) int
		Remain      func(childComplexity int) int
		Total       func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		UserID      func(childComplexity int) int
	}

	MatchingResult struct {
		ChatGroup         func(childComplexity int) int
		ChatGroupID       func(childComplexity int) int
		ChatGroupState    func(childComplexity int) int
		Closed            func(childComplexity int) int
		ConfirmStates     func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		CreatedBy         func(childComplexity int) int
		DiscoverMotion    func(childComplexity int) int
		FinishedAt        func(childComplexity int) int
		ID                func(childComplexity int) int
		MatchingDegree    func(childComplexity int) int
		MatchingIDs       func(childComplexity int) int
		MatchingPreviews  func(childComplexity int) int
		MatchingScore     func(childComplexity int) int
		MotionIDs         func(childComplexity int) int
		Topic             func(childComplexity int) int
		TopicID           func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
		UserConfirmStates func(childComplexity int) int
		UserIDs           func(childComplexity int) int
		Users             func(childComplexity int) int
	}

	MatchingResultConfirmAction struct {
		Confirmed        func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		ID               func(childComplexity int) int
		MatchingResultID func(childComplexity int) int
		UserID           func(childComplexity int) int
	}

	Motion struct {
		Active            func(childComplexity int) int
		ActiveNum         func(childComplexity int) int
		Areas             func(childComplexity int) int
		City              func(childComplexity int) int
		CityID            func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		DayRange          func(childComplexity int) int
		Discoverable      func(childComplexity int) int
		Gender            func(childComplexity int) int
		ID                func(childComplexity int) int
		InOfferNum        func(childComplexity int) int
		LikeCount         func(childComplexity int) int
		Liked             func(childComplexity int) int
		OutOfferNum       func(childComplexity int) int
		PendingInNum      func(childComplexity int) int
		PendingOutNum     func(childComplexity int) int
		PreferredPeriods  func(childComplexity int) int
		Properties        func(childComplexity int) int
		RelatedMatchingID func(childComplexity int) int
		Remark            func(childComplexity int) int
		ThumbsUp          func(childComplexity int) int
		ThumbsUpCount     func(childComplexity int) int
		Topic             func(childComplexity int) int
		TopicOptionConfig func(childComplexity int) int
		User              func(childComplexity int) int
		UserID            func(childComplexity int) int
		ViewCount         func(childComplexity int) int
	}

	MotionOfferRecord struct {
		ChatChance func(childComplexity int) int
		CreatedAt  func(childComplexity int) int
		ID         func(childComplexity int) int
		Motion     func(childComplexity int) int
		MotionID   func(childComplexity int) int
		ReactAt    func(childComplexity int) int
		Remark     func(childComplexity int) int
		Reviewed   func(childComplexity int, userID *string) int
		State      func(childComplexity int) int
		ToMotion   func(childComplexity int) int
		ToMotionID func(childComplexity int) int
	}

	MotionProperty struct {
		ID     func(childComplexity int) int
		Values func(childComplexity int) int
	}

	Mutation struct {
		AcceptMotionOffer                func(childComplexity int, myMotionID string, targetMotionID string) int
		AddMatchingToRecent              func(childComplexity int, matchingID string) int
		CancelMatching                   func(childComplexity int, matchingID string) int
		CancelMatchingInvitation         func(childComplexity int, invitationID string) int
		CancelMotionOffer                func(childComplexity int, myMotionID string, targetMotionID string) int
		CancelThumbsUpMotion             func(childComplexity int, userID *string, motionID string) int
		CloseMotion                      func(childComplexity int, id string) int
		ConfirmMatchingInvitation        func(childComplexity int, userID *string, invitationID string, confirm bool) int
		ConfirmMatchingResult            func(childComplexity int, userID *string, matchingID string, reject bool) int
		ConfirmMatchingResultV2          func(childComplexity int, userID *string, matchingID string, confirm bool) int
		CreateCityTopics                 func(childComplexity int, param models.CreateCityTopicParam) int
		CreateMatching                   func(childComplexity int, userID *string, param models.CreateMatchingParam) int
		CreateMatchingInvitation         func(childComplexity int, userID *string, param models.CreateMatchingInvitationParam) int
		CreateMatchingV2                 func(childComplexity int, userID *string, param models.CreateMatchingParamV2) int
		CreateMotion                     func(childComplexity int, userID *string, param models.CreateMotionParam) int
		CreateMotionOffer                func(childComplexity int, myMotionID string, targetMotionID string) int
		CreateUserJoinTopic              func(childComplexity int, param models.CreateUserJoinTopicParam) int
		FinishMatching                   func(childComplexity int, matchingID string) int
		FinishMotionOffer                func(childComplexity int, fromMotionID string, toMotionID string) int
		GetAvailableMotionOffer          func(childComplexity int, userID *string, targetMotionID string) int
		GetMatchingScore                 func(childComplexity int, id1 string, id2 string) int
		LikeMotion                       func(childComplexity int, userID *string, motionID string) int
		NotifyNewMotionOffer             func(childComplexity int, param *models.NotifyNewMotionOfferMessageParam) int
		RefreshTopicMetrics              func(childComplexity int) int
		RejectMotionOffer                func(childComplexity int, myMotionID string, targetMotionID string) int
		ReviewMatching                   func(childComplexity int, matchingID string, param models.ReviewMatchingParam) int
		ReviewMotionOffer                func(childComplexity int, userID *string, fromMotionID string, toMotionID string, param models.ReviewMotionParam) int
		SendChatInOffer                  func(childComplexity int, myMotionID string, targetMotionID string, sentence string) int
		SendMotionOfferAcceptMessage     func(childComplexity int, id int) int
		StartMatching                    func(childComplexity int) int
		ThumbsUpMotion                   func(childComplexity int, userID *string, motionID string) int
		ThumbsUpMotions                  func(childComplexity int, userID *string, paginator *graphqlutil.GraphQLPaginator) int
		ThumbsUpMotionsCount             func(childComplexity int, userID *string) int
		UnlikeMotion                     func(childComplexity int, userID *string, motionID string) int
		UpdateCityTopics                 func(childComplexity int, cityID string, param models.UpdateCityTopicParam) int
		UpdateDurationConstraint         func(childComplexity int, userID string, param models.UpdateDurationConstraintParam) int
		UpdateHotTopicsInArea            func(childComplexity int, cityID string, param models.UpdateHotTopicParam) int
		UpdateMatching                   func(childComplexity int, matchingID string, param models.UpdateMatchingParam) int
		UpdateMatchingDurationConstraint func(childComplexity int, userID string, param models.UpdateMatchingDurationConstraintParam) int
		UpdateMatchingInvitation         func(childComplexity int, invitationID string, param models.UpdateMatchingInvitationParam) int
		UpdateMatchingQuota              func(childComplexity int, userID string, param models.UpdateMatchingQuotaParam) int
		UpdateMotion                     func(childComplexity int, id string, param models.UpdateMotionParam) int
		UpdateRecentMatching             func(childComplexity int, id string, param models.UpdateRecentMatchingParam) int
		UpdateUserJoinTopic              func(childComplexity int, id int, param models.UpdateUserJoinTopicParam) int
		UserUpdateMotion                 func(childComplexity int, myMotionID string, param models.UserUpdateMotionParam) int
	}

	Query struct {
		ActiveMotions                 func(childComplexity int, userID *string) int
		ChatGroupByResultID           func(childComplexity int, resultID int) int
		CitiesTopics                  func(childComplexity int, filter *models.CitiesTopicsFilter, paginator *graphqlutil.GraphQLPaginator) int
		CitiesTopicsCount             func(childComplexity int, filter *models.CitiesTopicsFilter) int
		CityDistribution              func(childComplexity int) int
		CityTopics                    func(childComplexity int, cityID string) int
		DiscoverCategoryMotions       func(childComplexity int, userID *string, filter *models.DiscoverTopicCategoryMotionFilter, topicCategoryID string, nextToken *string) int
		DiscoverLatestCategoryMotions func(childComplexity int, filter models.DiscoverTopicCategoryMotionFilter, topicCategoryID string, lastID *string) int
		GetDiscoverMotion             func(childComplexity int, motionID string) int
		GetMotionOffer                func(childComplexity int, motionID string, toMotionID string) int
		HotTopics                     func(childComplexity int, filter *models.HotTopicsFilter, paginator *graphqlutil.GraphQLPaginator) int
		HotTopicsCount                func(childComplexity int, filter *models.HotTopicsFilter) int
		HotTopicsInArea               func(childComplexity int, cityID *string) int
		InMotionOffers                func(childComplexity int, motionID string) int
		Invitation                    func(childComplexity int, userID *string, id string) int
		Invitations                   func(childComplexity int, userID *string, paginator *graphqlutil.GraphQLPaginator) int
		InvitationsCount              func(childComplexity int, userID *string) int
		LikedMotions                  func(childComplexity int, userID *string, paginator *graphqlutil.GraphQLPaginator) int
		LikedMotionsCount             func(childComplexity int, userID *string) int
		Matching                      func(childComplexity int, id string) int
		MatchingDurationConstraints   func(childComplexity int, userID string) int
		MatchingInvitations           func(childComplexity int, filter *models.MatchingInvitationFilter, paginator *graphqlutil.GraphQLPaginator) int
		MatchingInvitationsCount      func(childComplexity int, filter *models.MatchingInvitationFilter) int
		MatchingResult                func(childComplexity int, id int) int
		MatchingResultByChatGroupID   func(childComplexity int, userID *string, chatGroupID string) int
		MatchingResults               func(childComplexity int, filter *models.MatchingResultFilter, paginator *graphqlutil.GraphQLPaginator) int
		MatchingResultsCount          func(childComplexity int, filter *models.MatchingResultFilter) int
		Matchings                     func(childComplexity int, filter *models.MatchingFilter, paginator *graphqlutil.GraphQLPaginator) int
		MatchingsCount                func(childComplexity int, filter *models.MatchingFilter) int
		Motion                        func(childComplexity int, id string) int
		MotionSummary                 func(childComplexity int) int
		Motions                       func(childComplexity int, filter *models.MotionFilter, paginator *graphqlutil.GraphQLPaginator) int
		MotionsCount                  func(childComplexity int, filter *models.MotionFilter) int
		OutMotionOffers               func(childComplexity int, motionID string) int
		PreviewMatchingsOfTopic       func(childComplexity int, cityID string, topicID string, limit *int) int
		RecentMatching                func(childComplexity int, id string) int
		RecentMatchings               func(childComplexity int, filter *models.RecentMatchingFilter, paginator *graphqlutil.GraphQLPaginator) int
		RecentMatchingsCount          func(childComplexity int, filter *models.RecentMatchingFilter) int
		TopicDistribution             func(childComplexity int) int
		UnconfirmedInvitationCount    func(childComplexity int, userID *string) int
		UnconfirmedInvitations        func(childComplexity int, userID *string) int
		UnconfirmedUserMatchings      func(childComplexity int, userID *string) int
		UserDurationConstraint        func(childComplexity int, userID string) int
		UserJoinTopic                 func(childComplexity int, id int) int
		UserJoinTopics                func(childComplexity int, filter *models.UserJoinTopicFilter, paginator *graphqlutil.GraphQLPaginator) int
		UserJoinTopicsCount           func(childComplexity int, filter *models.UserJoinTopicFilter) int
		UserMatchingCalendar          func(childComplexity int, userID *string, param models.UserMatchingCalenderParam) int
		UserMatchingQuota             func(childComplexity int, userID string) int
		UserMatchings                 func(childComplexity int, userID *string, filter *models.UserMatchingFilter, paginator *graphqlutil.GraphQLPaginator) int
		UserMatchingsCount            func(childComplexity int, userID *string, filter *models.UserMatchingFilter) int
		UserMatchingsInTheDay         func(childComplexity int, userID *string, param models.UserMatchingInTheDayParam) int
		UserMotions                   func(childComplexity int, userID *string, paginator *graphqlutil.GraphQLPaginator) int
		UserMotionsCount              func(childComplexity int, userID *string) int
		YesterdayMatchingCount        func(childComplexity int) int
		__resolve__service            func(childComplexity int) int
		__resolve_entities            func(childComplexity int, representations []map[string]interface{}) int
	}

	RecentMatching struct {
		City        func(childComplexity int) int
		CityID      func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		MatchingIDs func(childComplexity int) int
		Matchings   func(childComplexity int) int
		Topic       func(childComplexity int) int
		TopicID     func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	SimpleAvatarUser struct {
		Avatar   func(childComplexity int) int
		Nickname func(childComplexity int) int
	}

	Summary struct {
		Count func(childComplexity int) int
	}

	Topic struct {
		FuzzyMatchingNum func(childComplexity int, cityID *string) int
		ID               func(childComplexity int) int
		MatchingNum      func(childComplexity int, cityID *string) int
		RecentUsers      func(childComplexity int, cityID *string) int
	}

	TopicMetrics struct {
		Heat     func(childComplexity int) int
		ID       func(childComplexity int) int
		Matched  func(childComplexity int) int
		Matching func(childComplexity int) int
		Topic    func(childComplexity int) int
	}

	TopicOptionConfig struct {
		TopicID func(childComplexity int) int
	}

	TopicToMatching struct {
		MatchingIds func(childComplexity int) int
		Topic       func(childComplexity int) int
		TopicID     func(childComplexity int) int
	}

	User struct {
		ID            func(childComplexity int) int
		MatchingQuota func(childComplexity int) int
	}

	UserConfirmState struct {
		State  func(childComplexity int) int
		UserID func(childComplexity int) int
	}

	UserJoinTopic struct {
		City             func(childComplexity int) int
		CityID           func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		ID               func(childComplexity int) int
		LatestMatchingID func(childComplexity int) int
		Matching         func(childComplexity int) int
		Topic            func(childComplexity int) int
		TopicID          func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
		User             func(childComplexity int) int
		UserID           func(childComplexity int) int
	}

	UserLikeMotion struct {
		CreatedAt  func(childComplexity int) int
		Motion     func(childComplexity int) int
		ToMotionID func(childComplexity int) int
		ToUserID   func(childComplexity int) int
		UserID     func(childComplexity int) int
	}

	UserThumbsUpMotion struct {
		CreatedAt  func(childComplexity int) int
		ToMotionID func(childComplexity int) int
		UserID     func(childComplexity int) int
	}

	_Service struct {
		SDL func(childComplexity int) int
	}
}

type CityToTopicMatchingResolver interface {
	City(ctx context.Context, obj *models.CityToTopicMatching) (*models.Area, error)
}
type CityTopicsResolver interface {
	Topics(ctx context.Context, obj *models.CityTopics) ([]*models.Topic, error)
	City(ctx context.Context, obj *models.CityTopics) (*models.Area, error)
}
type DiscoverMotionResolver interface {
	Gender(ctx context.Context, obj *models.Motion) (models.Gender, error)

	PreferredPeriods(ctx context.Context, obj *models.Motion) ([]models.DatePeriod, error)

	Liked(ctx context.Context, obj *models.Motion, userID *string) (bool, error)
	Submitted(ctx context.Context, obj *models.Motion, userID *string) (bool, error)
	ThumbsUp(ctx context.Context, obj *models.Motion, userID *string) (bool, error)
	Topic(ctx context.Context, obj *models.Motion) (*models.Topic, error)
	TopicOptionConfig(ctx context.Context, obj *models.Motion) (*models.TopicOptionConfig, error)
	User(ctx context.Context, obj *models.Motion) (*models.User, error)
	City(ctx context.Context, obj *models.Motion) (*models.Area, error)
	Areas(ctx context.Context, obj *models.Motion) ([]*models.Area, error)
}
type EntityResolver interface {
	FindLevelRightsByLevel(ctx context.Context, level int) (*models.LevelRights, error)
	FindMatchingByID(ctx context.Context, id string) (*models.Matching, error)
	FindMatchingQuotaByUserID(ctx context.Context, userID string) (*models.MatchingQuota, error)
	FindTopicByID(ctx context.Context, id string) (*models.Topic, error)
	FindUserByID(ctx context.Context, id string) (*models.User, error)
}
type EvaluatorResultResolver interface {
	FailedReason(ctx context.Context, obj *matcher.EvaluatorResult) (string, error)
}
type HotTopicsInAreaResolver interface {
	City(ctx context.Context, obj *models.HotTopicsInArea) (*models.Area, error)
}
type MatchingResolver interface {
	Gender(ctx context.Context, obj *models.Matching) (models.Gender, error)
	State(ctx context.Context, obj *models.Matching) (models.MatchingState, error)

	PreferredPeriods(ctx context.Context, obj *models.Matching) ([]models.DatePeriod, error)

	MatchingResult(ctx context.Context, obj *models.Matching) (*models.MatchingResult, error)
	Reviewed(ctx context.Context, obj *models.Matching) (bool, error)
	User(ctx context.Context, obj *models.Matching) (*models.User, error)
	Topic(ctx context.Context, obj *models.Matching) (*models.Topic, error)
	Areas(ctx context.Context, obj *models.Matching) ([]*models.Area, error)
	City(ctx context.Context, obj *models.Matching) (*models.Area, error)
}
type MatchingInvitationResolver interface {
	ConfirmState(ctx context.Context, obj *models.MatchingInvitation) (models.InvitationConfirmState, error)

	Invitee(ctx context.Context, obj *models.MatchingInvitation) (*models.User, error)
	Topic(ctx context.Context, obj *models.MatchingInvitation) (*models.Topic, error)
	Areas(ctx context.Context, obj *models.MatchingInvitation) ([]*models.Area, error)
	City(ctx context.Context, obj *models.MatchingInvitation) (*models.Area, error)
	User(ctx context.Context, obj *models.MatchingInvitation) (*models.User, error)
	MatchingResult(ctx context.Context, obj *models.MatchingInvitation) (*models.MatchingResult, error)
}
type MatchingOfTopicResolver interface {
	Gender(ctx context.Context, obj *models.Matching) (models.Gender, error)

	User(ctx context.Context, obj *models.Matching) (*models.User, error)
	City(ctx context.Context, obj *models.Matching) (*models.Area, error)
	Areas(ctx context.Context, obj *models.Matching) ([]*models.Area, error)
}
type MatchingPreviewResolver interface {
	PreferredPeriods(ctx context.Context, obj *models.Matching) ([]models.DatePeriod, error)
	TopicOptionConfig(ctx context.Context, obj *models.Matching) (*models.TopicOptionConfig, error)
	User(ctx context.Context, obj *models.Matching) (*models.User, error)
}
type MatchingResultResolver interface {
	ConfirmStates(ctx context.Context, obj *models.MatchingResult) ([]models.MatchingResultConfirmState, error)
	UserConfirmStates(ctx context.Context, obj *models.MatchingResult) ([]*models.UserConfirmState, error)

	ChatGroupState(ctx context.Context, obj *models.MatchingResult) (models.ChatGroupState, error)

	CreatedBy(ctx context.Context, obj *models.MatchingResult) (models.ResultCreatedBy, error)
	Users(ctx context.Context, obj *models.MatchingResult) ([]*models.User, error)
	DiscoverMotion(ctx context.Context, obj *models.MatchingResult) ([]*models.Motion, error)
	MatchingPreviews(ctx context.Context, obj *models.MatchingResult) ([]*models.Matching, error)
	Topic(ctx context.Context, obj *models.MatchingResult) (*models.Topic, error)
	ChatGroup(ctx context.Context, obj *models.MatchingResult) (*models.ChatGroup, error)
	MatchingDegree(ctx context.Context, obj *models.MatchingResult) (int, error)
}
type MotionResolver interface {
	PreferredPeriods(ctx context.Context, obj *models.Motion) ([]models.DatePeriod, error)
	Gender(ctx context.Context, obj *models.Motion) (models.Gender, error)

	Liked(ctx context.Context, obj *models.Motion) (bool, error)

	ThumbsUp(ctx context.Context, obj *models.Motion) (bool, error)
	Topic(ctx context.Context, obj *models.Motion) (*models.Topic, error)
	TopicOptionConfig(ctx context.Context, obj *models.Motion) (*models.TopicOptionConfig, error)
	User(ctx context.Context, obj *models.Motion) (*models.User, error)
	City(ctx context.Context, obj *models.Motion) (*models.Area, error)
	Areas(ctx context.Context, obj *models.Motion) ([]*models.Area, error)
}
type MotionOfferRecordResolver interface {
	State(ctx context.Context, obj *models.MotionOfferRecord) (models.MotionOfferState, error)

	Reviewed(ctx context.Context, obj *models.MotionOfferRecord, userID *string) (bool, error)
	ToMotion(ctx context.Context, obj *models.MotionOfferRecord) (*models.Motion, error)
	Motion(ctx context.Context, obj *models.MotionOfferRecord) (*models.Motion, error)
}
type MutationResolver interface {
	RefreshTopicMetrics(ctx context.Context) (*string, error)
	UpdateDurationConstraint(ctx context.Context, userID string, param models.UpdateDurationConstraintParam) (*string, error)
	CreateMatchingInvitation(ctx context.Context, userID *string, param models.CreateMatchingInvitationParam) (*models.MatchingInvitation, error)
	CancelMatchingInvitation(ctx context.Context, invitationID string) (*string, error)
	ConfirmMatchingInvitation(ctx context.Context, userID *string, invitationID string, confirm bool) (*string, error)
	UpdateMatchingInvitation(ctx context.Context, invitationID string, param models.UpdateMatchingInvitationParam) (*models.MatchingInvitation, error)
	CreateMatching(ctx context.Context, userID *string, param models.CreateMatchingParam) (*models.Matching, error)
	CreateMatchingV2(ctx context.Context, userID *string, param models.CreateMatchingParamV2) (*models.Matching, error)
	UpdateMatching(ctx context.Context, matchingID string, param models.UpdateMatchingParam) (*models.Matching, error)
	UpdateMatchingQuota(ctx context.Context, userID string, param models.UpdateMatchingQuotaParam) (string, error)
	UpdateMatchingDurationConstraint(ctx context.Context, userID string, param models.UpdateMatchingDurationConstraintParam) (string, error)
	ConfirmMatchingResult(ctx context.Context, userID *string, matchingID string, reject bool) (*string, error)
	ConfirmMatchingResultV2(ctx context.Context, userID *string, matchingID string, confirm bool) (*string, error)
	CancelMatching(ctx context.Context, matchingID string) (*string, error)
	StartMatching(ctx context.Context) (*string, error)
	FinishMatching(ctx context.Context, matchingID string) (*string, error)
	ReviewMatching(ctx context.Context, matchingID string, param models.ReviewMatchingParam) (*string, error)
	UpdateRecentMatching(ctx context.Context, id string, param models.UpdateRecentMatchingParam) (*models.RecentMatching, error)
	AddMatchingToRecent(ctx context.Context, matchingID string) (*models.RecentMatching, error)
	GetMatchingScore(ctx context.Context, id1 string, id2 string) (*matcher.EvaluatorResult, error)
	GetAvailableMotionOffer(ctx context.Context, userID *string, targetMotionID string) (*models.AvailableMotionOffer, error)
	CreateMotionOffer(ctx context.Context, myMotionID string, targetMotionID string) (*models.CreateMotionOfferResult, error)
	CancelMotionOffer(ctx context.Context, myMotionID string, targetMotionID string) (*string, error)
	AcceptMotionOffer(ctx context.Context, myMotionID string, targetMotionID string) (*string, error)
	RejectMotionOffer(ctx context.Context, myMotionID string, targetMotionID string) (*string, error)
	SendChatInOffer(ctx context.Context, myMotionID string, targetMotionID string, sentence string) (*string, error)
	FinishMotionOffer(ctx context.Context, fromMotionID string, toMotionID string) (*string, error)
	NotifyNewMotionOffer(ctx context.Context, param *models.NotifyNewMotionOfferMessageParam) (*string, error)
	SendMotionOfferAcceptMessage(ctx context.Context, id int) (*string, error)
	CreateMotion(ctx context.Context, userID *string, param models.CreateMotionParam) (*models.Motion, error)
	UpdateMotion(ctx context.Context, id string, param models.UpdateMotionParam) (*models.Motion, error)
	UserUpdateMotion(ctx context.Context, myMotionID string, param models.UserUpdateMotionParam) (*models.Motion, error)
	CloseMotion(ctx context.Context, id string) (*string, error)
	ReviewMotionOffer(ctx context.Context, userID *string, fromMotionID string, toMotionID string, param models.ReviewMotionParam) (*string, error)
	CreateCityTopics(ctx context.Context, param models.CreateCityTopicParam) (*models.CityTopics, error)
	UpdateCityTopics(ctx context.Context, cityID string, param models.UpdateCityTopicParam) (*models.CityTopics, error)
	UpdateHotTopicsInArea(ctx context.Context, cityID string, param models.UpdateHotTopicParam) (*models.HotTopicsInArea, error)
	UpdateUserJoinTopic(ctx context.Context, id int, param models.UpdateUserJoinTopicParam) (*models.UserJoinTopic, error)
	CreateUserJoinTopic(ctx context.Context, param models.CreateUserJoinTopicParam) (*models.UserJoinTopic, error)
	LikeMotion(ctx context.Context, userID *string, motionID string) (int, error)
	UnlikeMotion(ctx context.Context, userID *string, motionID string) (int, error)
	ThumbsUpMotion(ctx context.Context, userID *string, motionID string) (*string, error)
	CancelThumbsUpMotion(ctx context.Context, userID *string, motionID string) (*string, error)
	ThumbsUpMotions(ctx context.Context, userID *string, paginator *graphqlutil.GraphQLPaginator) ([]*models.UserThumbsUpMotion, error)
	ThumbsUpMotionsCount(ctx context.Context, userID *string) (*models.Summary, error)
}
type QueryResolver interface {
	ChatGroupByResultID(ctx context.Context, resultID int) (*models.ChatGroup, error)
	UserDurationConstraint(ctx context.Context, userID string) (*models.DurationConstraint, error)
	YesterdayMatchingCount(ctx context.Context) (int, error)
	MotionSummary(ctx context.Context) (map[string]interface{}, error)
	MatchingInvitations(ctx context.Context, filter *models.MatchingInvitationFilter, paginator *graphqlutil.GraphQLPaginator) ([]*models.MatchingInvitation, error)
	MatchingInvitationsCount(ctx context.Context, filter *models.MatchingInvitationFilter) (*models.Summary, error)
	Invitations(ctx context.Context, userID *string, paginator *graphqlutil.GraphQLPaginator) ([]*models.MatchingInvitation, error)
	Invitation(ctx context.Context, userID *string, id string) (*models.MatchingInvitation, error)
	InvitationsCount(ctx context.Context, userID *string) (*models.Summary, error)
	Matching(ctx context.Context, id string) (*models.Matching, error)
	UserMatchingQuota(ctx context.Context, userID string) (*models.MatchingQuota, error)
	UserMatchingCalendar(ctx context.Context, userID *string, param models.UserMatchingCalenderParam) ([]*models.CalendarEvent, error)
	UserMatchingsInTheDay(ctx context.Context, userID *string, param models.UserMatchingInTheDayParam) ([]*models.MatchingResult, error)
	MatchingResultByChatGroupID(ctx context.Context, userID *string, chatGroupID string) (*models.MatchingResult, error)
	Matchings(ctx context.Context, filter *models.MatchingFilter, paginator *graphqlutil.GraphQLPaginator) ([]*models.Matching, error)
	MatchingsCount(ctx context.Context, filter *models.MatchingFilter) (*models.Summary, error)
	MatchingResult(ctx context.Context, id int) (*models.MatchingResult, error)
	MatchingResults(ctx context.Context, filter *models.MatchingResultFilter, paginator *graphqlutil.GraphQLPaginator) ([]*models.MatchingResult, error)
	MatchingResultsCount(ctx context.Context, filter *models.MatchingResultFilter) (*models.Summary, error)
	UserMatchings(ctx context.Context, userID *string, filter *models.UserMatchingFilter, paginator *graphqlutil.GraphQLPaginator) ([]*models.Matching, error)
	UnconfirmedUserMatchings(ctx context.Context, userID *string) ([]*models.Matching, error)
	UserMatchingsCount(ctx context.Context, userID *string, filter *models.UserMatchingFilter) (*models.Summary, error)
	PreviewMatchingsOfTopic(ctx context.Context, cityID string, topicID string, limit *int) ([]*models.Matching, error)
	UnconfirmedInvitations(ctx context.Context, userID *string) ([]*models.MatchingInvitation, error)
	UnconfirmedInvitationCount(ctx context.Context, userID *string) (*models.Summary, error)
	RecentMatchings(ctx context.Context, filter *models.RecentMatchingFilter, paginator *graphqlutil.GraphQLPaginator) ([]*models.RecentMatching, error)
	RecentMatchingsCount(ctx context.Context, filter *models.RecentMatchingFilter) (*models.Summary, error)
	RecentMatching(ctx context.Context, id string) (*models.RecentMatching, error)
	TopicDistribution(ctx context.Context) ([]*models.TopicToMatching, error)
	CityDistribution(ctx context.Context) ([]*models.CityToTopicMatching, error)
	MatchingDurationConstraints(ctx context.Context, userID string) (*models.MatchingDurationConstraint, error)
	DiscoverCategoryMotions(ctx context.Context, userID *string, filter *models.DiscoverTopicCategoryMotionFilter, topicCategoryID string, nextToken *string) (*models.DiscoverMotionResult, error)
	DiscoverLatestCategoryMotions(ctx context.Context, filter models.DiscoverTopicCategoryMotionFilter, topicCategoryID string, lastID *string) ([]*models.Motion, error)
	GetDiscoverMotion(ctx context.Context, motionID string) (*models.Motion, error)
	OutMotionOffers(ctx context.Context, motionID string) ([]*models.MotionOfferRecord, error)
	InMotionOffers(ctx context.Context, motionID string) ([]*models.MotionOfferRecord, error)
	GetMotionOffer(ctx context.Context, motionID string, toMotionID string) (*models.MotionOfferRecord, error)
	Motion(ctx context.Context, id string) (*models.Motion, error)
	UserMotions(ctx context.Context, userID *string, paginator *graphqlutil.GraphQLPaginator) ([]*models.Motion, error)
	UserMotionsCount(ctx context.Context, userID *string) (*models.Summary, error)
	ActiveMotions(ctx context.Context, userID *string) ([]*models.Motion, error)
	Motions(ctx context.Context, filter *models.MotionFilter, paginator *graphqlutil.GraphQLPaginator) ([]*models.Motion, error)
	MotionsCount(ctx context.Context, filter *models.MotionFilter) (*models.Summary, error)
	CityTopics(ctx context.Context, cityID string) (*models.CityTopics, error)
	CitiesTopics(ctx context.Context, filter *models.CitiesTopicsFilter, paginator *graphqlutil.GraphQLPaginator) ([]*models.CityTopics, error)
	CitiesTopicsCount(ctx context.Context, filter *models.CitiesTopicsFilter) (*models.Summary, error)
	HotTopicsInArea(ctx context.Context, cityID *string) (*models.HotTopicsInArea, error)
	HotTopics(ctx context.Context, filter *models.HotTopicsFilter, paginator *graphqlutil.GraphQLPaginator) ([]*models.HotTopicsInArea, error)
	HotTopicsCount(ctx context.Context, filter *models.HotTopicsFilter) (*models.Summary, error)
	UserJoinTopics(ctx context.Context, filter *models.UserJoinTopicFilter, paginator *graphqlutil.GraphQLPaginator) ([]*models.UserJoinTopic, error)
	UserJoinTopicsCount(ctx context.Context, filter *models.UserJoinTopicFilter) (*models.Summary, error)
	UserJoinTopic(ctx context.Context, id int) (*models.UserJoinTopic, error)
	LikedMotions(ctx context.Context, userID *string, paginator *graphqlutil.GraphQLPaginator) ([]*models.UserLikeMotion, error)
	LikedMotionsCount(ctx context.Context, userID *string) (*models.Summary, error)
}
type RecentMatchingResolver interface {
	Topic(ctx context.Context, obj *models.RecentMatching) (*models.Topic, error)
	City(ctx context.Context, obj *models.RecentMatching) (*models.Area, error)
	Matchings(ctx context.Context, obj *models.RecentMatching) ([]*models.Matching, error)
}
type TopicResolver interface {
	RecentUsers(ctx context.Context, obj *models.Topic, cityID *string) ([]*models.SimpleAvatarUser, error)
	MatchingNum(ctx context.Context, obj *models.Topic, cityID *string) (int, error)
	FuzzyMatchingNum(ctx context.Context, obj *models.Topic, cityID *string) (int, error)
}
type TopicMetricsResolver interface {
	Topic(ctx context.Context, obj *models.TopicMetrics) (*models.Topic, error)
}
type TopicToMatchingResolver interface {
	Topic(ctx context.Context, obj *models.TopicToMatching) (*models.Topic, error)
}
type UserResolver interface {
	MatchingQuota(ctx context.Context, obj *models.User) (*models.MatchingQuota, error)
}
type UserJoinTopicResolver interface {
	Topic(ctx context.Context, obj *models.UserJoinTopic) (*models.Topic, error)
	City(ctx context.Context, obj *models.UserJoinTopic) (*models.Area, error)
	User(ctx context.Context, obj *models.UserJoinTopic) (*models.User, error)
	Matching(ctx context.Context, obj *models.UserJoinTopic) (*models.Matching, error)
}
type UserLikeMotionResolver interface {
	Motion(ctx context.Context, obj *models.UserLikeMotion) (*models.Motion, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Area.code":
		if e.complexity.Area.Code == nil {
			break
		}

		return e.complexity.Area.Code(childComplexity), true

	case "AvailableMotionOffer.motion":
		if e.complexity.AvailableMotionOffer.Motion == nil {
			break
		}

		return e.complexity.AvailableMotionOffer.Motion(childComplexity), true

	case "AvailableMotionOffer.nextQuotaTime":
		if e.complexity.AvailableMotionOffer.NextQuotaTime == nil {
			break
		}

		return e.complexity.AvailableMotionOffer.NextQuotaTime(childComplexity), true

	case "CalendarEvent.chatGroupCreatedAt":
		if e.complexity.CalendarEvent.ChatGroupCreatedAt == nil {
			break
		}

		return e.complexity.CalendarEvent.ChatGroupCreatedAt(childComplexity), true

	case "CalendarEvent.finishedAt":
		if e.complexity.CalendarEvent.FinishedAt == nil {
			break
		}

		return e.complexity.CalendarEvent.FinishedAt(childComplexity), true

	case "CalendarEvent.matchedAt":
		if e.complexity.CalendarEvent.MatchedAt == nil {
			break
		}

		return e.complexity.CalendarEvent.MatchedAt(childComplexity), true

	case "CalendarEvent.topicId":
		if e.complexity.CalendarEvent.TopicID == nil {
			break
		}

		return e.complexity.CalendarEvent.TopicID(childComplexity), true

	case "ChatGroup.id":
		if e.complexity.ChatGroup.ID == nil {
			break
		}

		return e.complexity.ChatGroup.ID(childComplexity), true

	case "CityToTopicMatching.city":
		if e.complexity.CityToTopicMatching.City == nil {
			break
		}

		return e.complexity.CityToTopicMatching.City(childComplexity), true

	case "CityToTopicMatching.cityId":
		if e.complexity.CityToTopicMatching.CityID == nil {
			break
		}

		return e.complexity.CityToTopicMatching.CityID(childComplexity), true

	case "CityToTopicMatching.topics":
		if e.complexity.CityToTopicMatching.Topics == nil {
			break
		}

		return e.complexity.CityToTopicMatching.Topics(childComplexity), true

	case "CityTopics.city":
		if e.complexity.CityTopics.City == nil {
			break
		}

		return e.complexity.CityTopics.City(childComplexity), true

	case "CityTopics.cityId":
		if e.complexity.CityTopics.CityID == nil {
			break
		}

		return e.complexity.CityTopics.CityID(childComplexity), true

	case "CityTopics.topicIds":
		if e.complexity.CityTopics.TopicIDs == nil {
			break
		}

		return e.complexity.CityTopics.TopicIDs(childComplexity), true

	case "CityTopics.topics":
		if e.complexity.CityTopics.Topics == nil {
			break
		}

		return e.complexity.CityTopics.Topics(childComplexity), true

	case "CityTopics.updatedAt":
		if e.complexity.CityTopics.UpdatedAt == nil {
			break
		}

		return e.complexity.CityTopics.UpdatedAt(childComplexity), true

	case "CreateMotionOfferResult.chatGroupId":
		if e.complexity.CreateMotionOfferResult.ChatGroupID == nil {
			break
		}

		return e.complexity.CreateMotionOfferResult.ChatGroupID(childComplexity), true

	case "DiscoverMotion.areaIds":
		if e.complexity.DiscoverMotion.AreaIDs == nil {
			break
		}

		return e.complexity.DiscoverMotion.AreaIDs(childComplexity), true

	case "DiscoverMotion.areas":
		if e.complexity.DiscoverMotion.Areas == nil {
			break
		}

		return e.complexity.DiscoverMotion.Areas(childComplexity), true

	case "DiscoverMotion.city":
		if e.complexity.DiscoverMotion.City == nil {
			break
		}

		return e.complexity.DiscoverMotion.City(childComplexity), true

	case "DiscoverMotion.cityId":
		if e.complexity.DiscoverMotion.CityID == nil {
			break
		}

		return e.complexity.DiscoverMotion.CityID(childComplexity), true

	case "DiscoverMotion.createdAt":
		if e.complexity.DiscoverMotion.CreatedAt == nil {
			break
		}

		return e.complexity.DiscoverMotion.CreatedAt(childComplexity), true

	case "DiscoverMotion.dayRange":
		if e.complexity.DiscoverMotion.DayRange == nil {
			break
		}

		return e.complexity.DiscoverMotion.DayRange(childComplexity), true

	case "DiscoverMotion.gender":
		if e.complexity.DiscoverMotion.Gender == nil {
			break
		}

		return e.complexity.DiscoverMotion.Gender(childComplexity), true

	case "DiscoverMotion.id":
		if e.complexity.DiscoverMotion.ID == nil {
			break
		}

		return e.complexity.DiscoverMotion.ID(childComplexity), true

	case "DiscoverMotion.likeCount":
		if e.complexity.DiscoverMotion.LikeCount == nil {
			break
		}

		return e.complexity.DiscoverMotion.LikeCount(childComplexity), true

	case "DiscoverMotion.liked":
		if e.complexity.DiscoverMotion.Liked == nil {
			break
		}

		args, err := ec.field_DiscoverMotion_liked_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DiscoverMotion.Liked(childComplexity, args["userId"].(*string)), true

	case "DiscoverMotion.preferredPeriods":
		if e.complexity.DiscoverMotion.PreferredPeriods == nil {
			break
		}

		return e.complexity.DiscoverMotion.PreferredPeriods(childComplexity), true

	case "DiscoverMotion.properties":
		if e.complexity.DiscoverMotion.Properties == nil {
			break
		}

		return e.complexity.DiscoverMotion.Properties(childComplexity), true

	case "DiscoverMotion.remark":
		if e.complexity.DiscoverMotion.Remark == nil {
			break
		}

		return e.complexity.DiscoverMotion.Remark(childComplexity), true

	case "DiscoverMotion.submitted":
		if e.complexity.DiscoverMotion.Submitted == nil {
			break
		}

		args, err := ec.field_DiscoverMotion_submitted_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DiscoverMotion.Submitted(childComplexity, args["userId"].(*string)), true

	case "DiscoverMotion.thumbsUp":
		if e.complexity.DiscoverMotion.ThumbsUp == nil {
			break
		}

		args, err := ec.field_DiscoverMotion_thumbsUp_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DiscoverMotion.ThumbsUp(childComplexity, args["userId"].(*string)), true

	case "DiscoverMotion.thumbsUpCount":
		if e.complexity.DiscoverMotion.ThumbsUpCount == nil {
			break
		}

		return e.complexity.DiscoverMotion.ThumbsUpCount(childComplexity), true

	case "DiscoverMotion.topic":
		if e.complexity.DiscoverMotion.Topic == nil {
			break
		}

		return e.complexity.DiscoverMotion.Topic(childComplexity), true

	case "DiscoverMotion.topicId":
		if e.complexity.DiscoverMotion.TopicID == nil {
			break
		}

		return e.complexity.DiscoverMotion.TopicID(childComplexity), true

	case "DiscoverMotion.topicOptionConfig":
		if e.complexity.DiscoverMotion.TopicOptionConfig == nil {
			break
		}

		return e.complexity.DiscoverMotion.TopicOptionConfig(childComplexity), true

	case "DiscoverMotion.user":
		if e.complexity.DiscoverMotion.User == nil {
			break
		}

		return e.complexity.DiscoverMotion.User(childComplexity), true

	case "DiscoverMotion.userId":
		if e.complexity.DiscoverMotion.UserID == nil {
			break
		}

		return e.complexity.DiscoverMotion.UserID(childComplexity), true

	case "DiscoverMotion.viewCount":
		if e.complexity.DiscoverMotion.ViewCount == nil {
			break
		}

		return e.complexity.DiscoverMotion.ViewCount(childComplexity), true

	case "DiscoverMotionResult.motions":
		if e.complexity.DiscoverMotionResult.Motions == nil {
			break
		}

		return e.complexity.DiscoverMotionResult.Motions(childComplexity), true

	case "DiscoverMotionResult.nextToken":
		if e.complexity.DiscoverMotionResult.NextToken == nil {
			break
		}

		return e.complexity.DiscoverMotionResult.NextToken(childComplexity), true

	case "DurationConstraint.remainMotionQuota":
		if e.complexity.DurationConstraint.RemainMotionQuota == nil {
			break
		}

		return e.complexity.DurationConstraint.RemainMotionQuota(childComplexity), true

	case "DurationConstraint.startDate":
		if e.complexity.DurationConstraint.StartDate == nil {
			break
		}

		return e.complexity.DurationConstraint.StartDate(childComplexity), true

	case "DurationConstraint.stopDate":
		if e.complexity.DurationConstraint.StopDate == nil {
			break
		}

		return e.complexity.DurationConstraint.StopDate(childComplexity), true

	case "DurationConstraint.totalMotionQuota":
		if e.complexity.DurationConstraint.TotalMotionQuota == nil {
			break
		}

		return e.complexity.DurationConstraint.TotalMotionQuota(childComplexity), true

	case "DurationConstraint.updatedAt":
		if e.complexity.DurationConstraint.UpdatedAt == nil {
			break
		}

		return e.complexity.DurationConstraint.UpdatedAt(childComplexity), true

	case "DurationConstraint.userId":
		if e.complexity.DurationConstraint.UserID == nil {
			break
		}

		return e.complexity.DurationConstraint.UserID(childComplexity), true

	case "Entity.findLevelRightsByLevel":
		if e.complexity.Entity.FindLevelRightsByLevel == nil {
			break
		}

		args, err := ec.field_Entity_findLevelRightsByLevel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Entity.FindLevelRightsByLevel(childComplexity, args["level"].(int)), true

	case "Entity.findMatchingByID":
		if e.complexity.Entity.FindMatchingByID == nil {
			break
		}

		args, err := ec.field_Entity_findMatchingByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Entity.FindMatchingByID(childComplexity, args["id"].(string)), true

	case "Entity.findMatchingQuotaByUserID":
		if e.complexity.Entity.FindMatchingQuotaByUserID == nil {
			break
		}

		args, err := ec.field_Entity_findMatchingQuotaByUserID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Entity.FindMatchingQuotaByUserID(childComplexity, args["userID"].(string)), true

	case "Entity.findTopicByID":
		if e.complexity.Entity.FindTopicByID == nil {
			break
		}

		args, err := ec.field_Entity_findTopicByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Entity.FindTopicByID(childComplexity, args["id"].(string)), true

	case "Entity.findUserByID":
		if e.complexity.Entity.FindUserByID == nil {
			break
		}

		args, err := ec.field_Entity_findUserByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Entity.FindUserByID(childComplexity, args["id"].(string)), true

	case "EvaluatorResult.failedReason":
		if e.complexity.EvaluatorResult.FailedReason == nil {
			break
		}

		return e.complexity.EvaluatorResult.FailedReason(childComplexity), true

	case "EvaluatorResult.properties":
		if e.complexity.EvaluatorResult.Properties == nil {
			break
		}

		return e.complexity.EvaluatorResult.Properties(childComplexity), true

	case "EvaluatorResult.score":
		if e.complexity.EvaluatorResult.Score == nil {
			break
		}

		return e.complexity.EvaluatorResult.Score(childComplexity), true

	case "EvaluatorResult.timeScore":
		if e.complexity.EvaluatorResult.TimeScore == nil {
			break
		}

		return e.complexity.EvaluatorResult.TimeScore(childComplexity), true

	case "HotTopicsInArea.city":
		if e.complexity.HotTopicsInArea.City == nil {
			break
		}

		return e.complexity.HotTopicsInArea.City(childComplexity), true

	case "HotTopicsInArea.cityId":
		if e.complexity.HotTopicsInArea.CityID == nil {
			break
		}

		return e.complexity.HotTopicsInArea.CityID(childComplexity), true

	case "HotTopicsInArea.topicMetrics":
		if e.complexity.HotTopicsInArea.TopicMetrics == nil {
			break
		}

		return e.complexity.HotTopicsInArea.TopicMetrics(childComplexity), true

	case "HotTopicsInArea.updatedAt":
		if e.complexity.HotTopicsInArea.UpdatedAt == nil {
			break
		}

		return e.complexity.HotTopicsInArea.UpdatedAt(childComplexity), true

	case "LevelRights.level":
		if e.complexity.LevelRights.Level == nil {
			break
		}

		return e.complexity.LevelRights.Level(childComplexity), true

	case "LevelRights.matchingDurationConstraint":
		if e.complexity.LevelRights.MatchingDurationConstraint == nil {
			break
		}

		return e.complexity.LevelRights.MatchingDurationConstraint(childComplexity), true

	case "LevelRights.matchingQuota":
		if e.complexity.LevelRights.MatchingQuota == nil {
			break
		}

		return e.complexity.LevelRights.MatchingQuota(childComplexity), true

	case "Matching.areaIds":
		if e.complexity.Matching.AreaIDs == nil {
			break
		}

		return e.complexity.Matching.AreaIDs(childComplexity), true

	case "Matching.areas":
		if e.complexity.Matching.Areas == nil {
			break
		}

		return e.complexity.Matching.Areas(childComplexity), true

	case "Matching.city":
		if e.complexity.Matching.City == nil {
			break
		}

		return e.complexity.Matching.City(childComplexity), true

	case "Matching.cityId":
		if e.complexity.Matching.CityID == nil {
			break
		}

		return e.complexity.Matching.CityID(childComplexity), true

	case "Matching.createdAt":
		if e.complexity.Matching.CreatedAt == nil {
			break
		}

		return e.complexity.Matching.CreatedAt(childComplexity), true

	case "Matching.dayRange":
		if e.complexity.Matching.DayRange == nil {
			break
		}

		return e.complexity.Matching.DayRange(childComplexity), true

	case "Matching.deadline":
		if e.complexity.Matching.Deadline == nil {
			break
		}

		return e.complexity.Matching.Deadline(childComplexity), true

	case "Matching.gender":
		if e.complexity.Matching.Gender == nil {
			break
		}

		return e.complexity.Matching.Gender(childComplexity), true

	case "Matching.id":
		if e.complexity.Matching.ID == nil {
			break
		}

		return e.complexity.Matching.ID(childComplexity), true

	case "Matching.inChatGroup":
		if e.complexity.Matching.InChatGroup == nil {
			break
		}

		return e.complexity.Matching.InChatGroup(childComplexity), true

	case "Matching.matchingResult":
		if e.complexity.Matching.MatchingResult == nil {
			break
		}

		return e.complexity.Matching.MatchingResult(childComplexity), true

	case "Matching.preferredPeriods":
		if e.complexity.Matching.PreferredPeriods == nil {
			break
		}

		return e.complexity.Matching.PreferredPeriods(childComplexity), true

	case "Matching.properties":
		if e.complexity.Matching.Properties == nil {
			break
		}

		return e.complexity.Matching.Properties(childComplexity), true

	case "Matching.rejectedUserIds":
		if e.complexity.Matching.RejectedUserIDs == nil {
			break
		}

		return e.complexity.Matching.RejectedUserIDs(childComplexity), true

	case "Matching.remark":
		if e.complexity.Matching.Remark == nil {
			break
		}

		return e.complexity.Matching.Remark(childComplexity), true

	case "Matching.reviewed":
		if e.complexity.Matching.Reviewed == nil {
			break
		}

		return e.complexity.Matching.Reviewed(childComplexity), true

	case "Matching.startMatchingAt":
		if e.complexity.Matching.StartMatchingAt == nil {
			break
		}

		return e.complexity.Matching.StartMatchingAt(childComplexity), true

	case "Matching.state":
		if e.complexity.Matching.State == nil {
			break
		}

		return e.complexity.Matching.State(childComplexity), true

	case "Matching.topic":
		if e.complexity.Matching.Topic == nil {
			break
		}

		return e.complexity.Matching.Topic(childComplexity), true

	case "Matching.topicId":
		if e.complexity.Matching.TopicID == nil {
			break
		}

		return e.complexity.Matching.TopicID(childComplexity), true

	case "Matching.updatedAt":
		if e.complexity.Matching.UpdatedAt == nil {
			break
		}

		return e.complexity.Matching.UpdatedAt(childComplexity), true

	case "Matching.user":
		if e.complexity.Matching.User == nil {
			break
		}

		return e.complexity.Matching.User(childComplexity), true

	case "Matching.userId":
		if e.complexity.Matching.UserID == nil {
			break
		}

		return e.complexity.Matching.UserID(childComplexity), true

	case "MatchingDurationConstraint.remain":
		if e.complexity.MatchingDurationConstraint.Remain == nil {
			break
		}

		return e.complexity.MatchingDurationConstraint.Remain(childComplexity), true

	case "MatchingDurationConstraint.startDate":
		if e.complexity.MatchingDurationConstraint.StartDate == nil {
			break
		}

		return e.complexity.MatchingDurationConstraint.StartDate(childComplexity), true

	case "MatchingDurationConstraint.stopDate":
		if e.complexity.MatchingDurationConstraint.StopDate == nil {
			break
		}

		return e.complexity.MatchingDurationConstraint.StopDate(childComplexity), true

	case "MatchingDurationConstraint.total":
		if e.complexity.MatchingDurationConstraint.Total == nil {
			break
		}

		return e.complexity.MatchingDurationConstraint.Total(childComplexity), true

	case "MatchingDurationConstraint.updatedAt":
		if e.complexity.MatchingDurationConstraint.UpdatedAt == nil {
			break
		}

		return e.complexity.MatchingDurationConstraint.UpdatedAt(childComplexity), true

	case "MatchingInvitation.areaIds":
		if e.complexity.MatchingInvitation.AreaIDs == nil {
			break
		}

		return e.complexity.MatchingInvitation.AreaIDs(childComplexity), true

	case "MatchingInvitation.areas":
		if e.complexity.MatchingInvitation.Areas == nil {
			break
		}

		return e.complexity.MatchingInvitation.Areas(childComplexity), true

	case "MatchingInvitation.city":
		if e.complexity.MatchingInvitation.City == nil {
			break
		}

		return e.complexity.MatchingInvitation.City(childComplexity), true

	case "MatchingInvitation.cityId":
		if e.complexity.MatchingInvitation.CityID == nil {
			break
		}

		return e.complexity.MatchingInvitation.CityID(childComplexity), true

	case "MatchingInvitation.confirmState":
		if e.complexity.MatchingInvitation.ConfirmState == nil {
			break
		}

		return e.complexity.MatchingInvitation.ConfirmState(childComplexity), true

	case "MatchingInvitation.confirmedAt":
		if e.complexity.MatchingInvitation.ConfirmedAt == nil {
			break
		}

		return e.complexity.MatchingInvitation.ConfirmedAt(childComplexity), true

	case "MatchingInvitation.createdAt":
		if e.complexity.MatchingInvitation.CreatedAt == nil {
			break
		}

		return e.complexity.MatchingInvitation.CreatedAt(childComplexity), true

	case "MatchingInvitation.id":
		if e.complexity.MatchingInvitation.ID == nil {
			break
		}

		return e.complexity.MatchingInvitation.ID(childComplexity), true

	case "MatchingInvitation.invitee":
		if e.complexity.MatchingInvitation.Invitee == nil {
			break
		}

		return e.complexity.MatchingInvitation.Invitee(childComplexity), true

	case "MatchingInvitation.inviteeId":
		if e.complexity.MatchingInvitation.InviteeID == nil {
			break
		}

		return e.complexity.MatchingInvitation.InviteeID(childComplexity), true

	case "MatchingInvitation.matchingIds":
		if e.complexity.MatchingInvitation.MatchingIds == nil {
			break
		}

		return e.complexity.MatchingInvitation.MatchingIds(childComplexity), true

	case "MatchingInvitation.matchingResult":
		if e.complexity.MatchingInvitation.MatchingResult == nil {
			break
		}

		return e.complexity.MatchingInvitation.MatchingResult(childComplexity), true

	case "MatchingInvitation.matchingResultId":
		if e.complexity.MatchingInvitation.MatchingResultId == nil {
			break
		}

		return e.complexity.MatchingInvitation.MatchingResultId(childComplexity), true

	case "MatchingInvitation.remark":
		if e.complexity.MatchingInvitation.Remark == nil {
			break
		}

		return e.complexity.MatchingInvitation.Remark(childComplexity), true

	case "MatchingInvitation.topic":
		if e.complexity.MatchingInvitation.Topic == nil {
			break
		}

		return e.complexity.MatchingInvitation.Topic(childComplexity), true

	case "MatchingInvitation.topicId":
		if e.complexity.MatchingInvitation.TopicID == nil {
			break
		}

		return e.complexity.MatchingInvitation.TopicID(childComplexity), true

	case "MatchingInvitation.updatedAt":
		if e.complexity.MatchingInvitation.UpdatedAt == nil {
			break
		}

		return e.complexity.MatchingInvitation.UpdatedAt(childComplexity), true

	case "MatchingInvitation.user":
		if e.complexity.MatchingInvitation.User == nil {
			break
		}

		return e.complexity.MatchingInvitation.User(childComplexity), true

	case "MatchingInvitation.userId":
		if e.complexity.MatchingInvitation.UserID == nil {
			break
		}

		return e.complexity.MatchingInvitation.UserID(childComplexity), true

	case "MatchingOfTopic.areaIds":
		if e.complexity.MatchingOfTopic.AreaIDs == nil {
			break
		}

		return e.complexity.MatchingOfTopic.AreaIDs(childComplexity), true

	case "MatchingOfTopic.areas":
		if e.complexity.MatchingOfTopic.Areas == nil {
			break
		}

		return e.complexity.MatchingOfTopic.Areas(childComplexity), true

	case "MatchingOfTopic.city":
		if e.complexity.MatchingOfTopic.City == nil {
			break
		}

		return e.complexity.MatchingOfTopic.City(childComplexity), true

	case "MatchingOfTopic.cityId":
		if e.complexity.MatchingOfTopic.CityID == nil {
			break
		}

		return e.complexity.MatchingOfTopic.CityID(childComplexity), true

	case "MatchingOfTopic.createdAt":
		if e.complexity.MatchingOfTopic.CreatedAt == nil {
			break
		}

		return e.complexity.MatchingOfTopic.CreatedAt(childComplexity), true

	case "MatchingOfTopic.gender":
		if e.complexity.MatchingOfTopic.Gender == nil {
			break
		}

		return e.complexity.MatchingOfTopic.Gender(childComplexity), true

	case "MatchingOfTopic.remark":
		if e.complexity.MatchingOfTopic.Remark == nil {
			break
		}

		return e.complexity.MatchingOfTopic.Remark(childComplexity), true

	case "MatchingOfTopic.user":
		if e.complexity.MatchingOfTopic.User == nil {
			break
		}

		return e.complexity.MatchingOfTopic.User(childComplexity), true

	case "MatchingOfTopic.userId":
		if e.complexity.MatchingOfTopic.UserID == nil {
			break
		}

		return e.complexity.MatchingOfTopic.UserID(childComplexity), true

	case "MatchingPreview.dayRange":
		if e.complexity.MatchingPreview.DayRange == nil {
			break
		}

		return e.complexity.MatchingPreview.DayRange(childComplexity), true

	case "MatchingPreview.preferredPeriods":
		if e.complexity.MatchingPreview.PreferredPeriods == nil {
			break
		}

		return e.complexity.MatchingPreview.PreferredPeriods(childComplexity), true

	case "MatchingPreview.properties":
		if e.complexity.MatchingPreview.Properties == nil {
			break
		}

		return e.complexity.MatchingPreview.Properties(childComplexity), true

	case "MatchingPreview.remark":
		if e.complexity.MatchingPreview.Remark == nil {
			break
		}

		return e.complexity.MatchingPreview.Remark(childComplexity), true

	case "MatchingPreview.topicOptionConfig":
		if e.complexity.MatchingPreview.TopicOptionConfig == nil {
			break
		}

		return e.complexity.MatchingPreview.TopicOptionConfig(childComplexity), true

	case "MatchingPreview.user":
		if e.complexity.MatchingPreview.User == nil {
			break
		}

		return e.complexity.MatchingPreview.User(childComplexity), true

	case "MatchingPreview.userId":
		if e.complexity.MatchingPreview.UserID == nil {
			break
		}

		return e.complexity.MatchingPreview.UserID(childComplexity), true

	case "MatchingProperty.id":
		if e.complexity.MatchingProperty.ID == nil {
			break
		}

		return e.complexity.MatchingProperty.ID(childComplexity), true

	case "MatchingProperty.values":
		if e.complexity.MatchingProperty.Values == nil {
			break
		}

		return e.complexity.MatchingProperty.Values(childComplexity), true

	case "MatchingQuota.createdAt":
		if e.complexity.MatchingQuota.CreatedAt == nil {
			break
		}

		return e.complexity.MatchingQuota.CreatedAt(childComplexity), true

	case "MatchingQuota.matchingNum":
		if e.complexity.MatchingQuota.MatchingNum == nil {
			break
		}

		return e.complexity.MatchingQuota.MatchingNum(childComplexity), true

	case "MatchingQuota.remain":
		if e.complexity.MatchingQuota.Remain == nil {
			break
		}

		return e.complexity.MatchingQuota.Remain(childComplexity), true

	case "MatchingQuota.total":
		if e.complexity.MatchingQuota.Total == nil {
			break
		}

		return e.complexity.MatchingQuota.Total(childComplexity), true

	case "MatchingQuota.updatedAt":
		if e.complexity.MatchingQuota.UpdatedAt == nil {
			break
		}

		return e.complexity.MatchingQuota.UpdatedAt(childComplexity), true

	case "MatchingQuota.userId":
		if e.complexity.MatchingQuota.UserID == nil {
			break
		}

		return e.complexity.MatchingQuota.UserID(childComplexity), true

	case "MatchingResult.chatGroup":
		if e.complexity.MatchingResult.ChatGroup == nil {
			break
		}

		return e.complexity.MatchingResult.ChatGroup(childComplexity), true

	case "MatchingResult.chatGroupId":
		if e.complexity.MatchingResult.ChatGroupID == nil {
			break
		}

		return e.complexity.MatchingResult.ChatGroupID(childComplexity), true

	case "MatchingResult.chatGroupState":
		if e.complexity.MatchingResult.ChatGroupState == nil {
			break
		}

		return e.complexity.MatchingResult.ChatGroupState(childComplexity), true

	case "MatchingResult.closed":
		if e.complexity.MatchingResult.Closed == nil {
			break
		}

		return e.complexity.MatchingResult.Closed(childComplexity), true

	case "MatchingResult.confirmStates":
		if e.complexity.MatchingResult.ConfirmStates == nil {
			break
		}

		return e.complexity.MatchingResult.ConfirmStates(childComplexity), true

	case "MatchingResult.createdAt":
		if e.complexity.MatchingResult.CreatedAt == nil {
			break
		}

		return e.complexity.MatchingResult.CreatedAt(childComplexity), true

	case "MatchingResult.createdBy":
		if e.complexity.MatchingResult.CreatedBy == nil {
			break
		}

		return e.complexity.MatchingResult.CreatedBy(childComplexity), true

	case "MatchingResult.discoverMotion":
		if e.complexity.MatchingResult.DiscoverMotion == nil {
			break
		}

		return e.complexity.MatchingResult.DiscoverMotion(childComplexity), true

	case "MatchingResult.finishedAt":
		if e.complexity.MatchingResult.FinishedAt == nil {
			break
		}

		return e.complexity.MatchingResult.FinishedAt(childComplexity), true

	case "MatchingResult.id":
		if e.complexity.MatchingResult.ID == nil {
			break
		}

		return e.complexity.MatchingResult.ID(childComplexity), true

	case "MatchingResult.matchingDegree":
		if e.complexity.MatchingResult.MatchingDegree == nil {
			break
		}

		return e.complexity.MatchingResult.MatchingDegree(childComplexity), true

	case "MatchingResult.matchingIds":
		if e.complexity.MatchingResult.MatchingIDs == nil {
			break
		}

		return e.complexity.MatchingResult.MatchingIDs(childComplexity), true

	case "MatchingResult.matchingPreviews":
		if e.complexity.MatchingResult.MatchingPreviews == nil {
			break
		}

		return e.complexity.MatchingResult.MatchingPreviews(childComplexity), true

	case "MatchingResult.matchingScore":
		if e.complexity.MatchingResult.MatchingScore == nil {
			break
		}

		return e.complexity.MatchingResult.MatchingScore(childComplexity), true

	case "MatchingResult.motionIds":
		if e.complexity.MatchingResult.MotionIDs == nil {
			break
		}

		return e.complexity.MatchingResult.MotionIDs(childComplexity), true

	case "MatchingResult.topic":
		if e.complexity.MatchingResult.Topic == nil {
			break
		}

		return e.complexity.MatchingResult.Topic(childComplexity), true

	case "MatchingResult.topicId":
		if e.complexity.MatchingResult.TopicID == nil {
			break
		}

		return e.complexity.MatchingResult.TopicID(childComplexity), true

	case "MatchingResult.updatedAt":
		if e.complexity.MatchingResult.UpdatedAt == nil {
			break
		}

		return e.complexity.MatchingResult.UpdatedAt(childComplexity), true

	case "MatchingResult.userConfirmStates":
		if e.complexity.MatchingResult.UserConfirmStates == nil {
			break
		}

		return e.complexity.MatchingResult.UserConfirmStates(childComplexity), true

	case "MatchingResult.userIds":
		if e.complexity.MatchingResult.UserIDs == nil {
			break
		}

		return e.complexity.MatchingResult.UserIDs(childComplexity), true

	case "MatchingResult.users":
		if e.complexity.MatchingResult.Users == nil {
			break
		}

		return e.complexity.MatchingResult.Users(childComplexity), true

	case "MatchingResultConfirmAction.confirmed":
		if e.complexity.MatchingResultConfirmAction.Confirmed == nil {
			break
		}

		return e.complexity.MatchingResultConfirmAction.Confirmed(childComplexity), true

	case "MatchingResultConfirmAction.createdAt":
		if e.complexity.MatchingResultConfirmAction.CreatedAt == nil {
			break
		}

		return e.complexity.MatchingResultConfirmAction.CreatedAt(childComplexity), true

	case "MatchingResultConfirmAction.id":
		if e.complexity.MatchingResultConfirmAction.ID == nil {
			break
		}

		return e.complexity.MatchingResultConfirmAction.ID(childComplexity), true

	case "MatchingResultConfirmAction.matchingResultId":
		if e.complexity.MatchingResultConfirmAction.MatchingResultID == nil {
			break
		}

		return e.complexity.MatchingResultConfirmAction.MatchingResultID(childComplexity), true

	case "MatchingResultConfirmAction.userId":
		if e.complexity.MatchingResultConfirmAction.UserID == nil {
			break
		}

		return e.complexity.MatchingResultConfirmAction.UserID(childComplexity), true

	case "Motion.active":
		if e.complexity.Motion.Active == nil {
			break
		}

		return e.complexity.Motion.Active(childComplexity), true

	case "Motion.activeNum":
		if e.complexity.Motion.ActiveNum == nil {
			break
		}

		return e.complexity.Motion.ActiveNum(childComplexity), true

	case "Motion.areas":
		if e.complexity.Motion.Areas == nil {
			break
		}

		return e.complexity.Motion.Areas(childComplexity), true

	case "Motion.city":
		if e.complexity.Motion.City == nil {
			break
		}

		return e.complexity.Motion.City(childComplexity), true

	case "Motion.cityId":
		if e.complexity.Motion.CityID == nil {
			break
		}

		return e.complexity.Motion.CityID(childComplexity), true

	case "Motion.createdAt":
		if e.complexity.Motion.CreatedAt == nil {
			break
		}

		return e.complexity.Motion.CreatedAt(childComplexity), true

	case "Motion.dayRange":
		if e.complexity.Motion.DayRange == nil {
			break
		}

		return e.complexity.Motion.DayRange(childComplexity), true

	case "Motion.discoverable":
		if e.complexity.Motion.Discoverable == nil {
			break
		}

		return e.complexity.Motion.Discoverable(childComplexity), true

	case "Motion.gender":
		if e.complexity.Motion.Gender == nil {
			break
		}

		return e.complexity.Motion.Gender(childComplexity), true

	case "Motion.id":
		if e.complexity.Motion.ID == nil {
			break
		}

		return e.complexity.Motion.ID(childComplexity), true

	case "Motion.inOfferNum":
		if e.complexity.Motion.InOfferNum == nil {
			break
		}

		return e.complexity.Motion.InOfferNum(childComplexity), true

	case "Motion.likeCount":
		if e.complexity.Motion.LikeCount == nil {
			break
		}

		return e.complexity.Motion.LikeCount(childComplexity), true

	case "Motion.liked":
		if e.complexity.Motion.Liked == nil {
			break
		}

		return e.complexity.Motion.Liked(childComplexity), true

	case "Motion.outOfferNum":
		if e.complexity.Motion.OutOfferNum == nil {
			break
		}

		return e.complexity.Motion.OutOfferNum(childComplexity), true

	case "Motion.pendingInNum":
		if e.complexity.Motion.PendingInNum == nil {
			break
		}

		return e.complexity.Motion.PendingInNum(childComplexity), true

	case "Motion.pendingOutNum":
		if e.complexity.Motion.PendingOutNum == nil {
			break
		}

		return e.complexity.Motion.PendingOutNum(childComplexity), true

	case "Motion.preferredPeriods":
		if e.complexity.Motion.PreferredPeriods == nil {
			break
		}

		return e.complexity.Motion.PreferredPeriods(childComplexity), true

	case "Motion.properties":
		if e.complexity.Motion.Properties == nil {
			break
		}

		return e.complexity.Motion.Properties(childComplexity), true

	case "Motion.relatedMatchingId":
		if e.complexity.Motion.RelatedMatchingID == nil {
			break
		}

		return e.complexity.Motion.RelatedMatchingID(childComplexity), true

	case "Motion.remark":
		if e.complexity.Motion.Remark == nil {
			break
		}

		return e.complexity.Motion.Remark(childComplexity), true

	case "Motion.thumbsUp":
		if e.complexity.Motion.ThumbsUp == nil {
			break
		}

		return e.complexity.Motion.ThumbsUp(childComplexity), true

	case "Motion.thumbsUpCount":
		if e.complexity.Motion.ThumbsUpCount == nil {
			break
		}

		return e.complexity.Motion.ThumbsUpCount(childComplexity), true

	case "Motion.topic":
		if e.complexity.Motion.Topic == nil {
			break
		}

		return e.complexity.Motion.Topic(childComplexity), true

	case "Motion.topicOptionConfig":
		if e.complexity.Motion.TopicOptionConfig == nil {
			break
		}

		return e.complexity.Motion.TopicOptionConfig(childComplexity), true

	case "Motion.user":
		if e.complexity.Motion.User == nil {
			break
		}

		return e.complexity.Motion.User(childComplexity), true

	case "Motion.userId":
		if e.complexity.Motion.UserID == nil {
			break
		}

		return e.complexity.Motion.UserID(childComplexity), true

	case "Motion.viewCount":
		if e.complexity.Motion.ViewCount == nil {
			break
		}

		return e.complexity.Motion.ViewCount(childComplexity), true

	case "MotionOfferRecord.chatChance":
		if e.complexity.MotionOfferRecord.ChatChance == nil {
			break
		}

		return e.complexity.MotionOfferRecord.ChatChance(childComplexity), true

	case "MotionOfferRecord.createdAt":
		if e.complexity.MotionOfferRecord.CreatedAt == nil {
			break
		}

		return e.complexity.MotionOfferRecord.CreatedAt(childComplexity), true

	case "MotionOfferRecord.id":
		if e.complexity.MotionOfferRecord.ID == nil {
			break
		}

		return e.complexity.MotionOfferRecord.ID(childComplexity), true

	case "MotionOfferRecord.motion":
		if e.complexity.MotionOfferRecord.Motion == nil {
			break
		}

		return e.complexity.MotionOfferRecord.Motion(childComplexity), true

	case "MotionOfferRecord.motionId":
		if e.complexity.MotionOfferRecord.MotionID == nil {
			break
		}

		return e.complexity.MotionOfferRecord.MotionID(childComplexity), true

	case "MotionOfferRecord.reactAt":
		if e.complexity.MotionOfferRecord.ReactAt == nil {
			break
		}

		return e.complexity.MotionOfferRecord.ReactAt(childComplexity), true

	case "MotionOfferRecord.remark":
		if e.complexity.MotionOfferRecord.Remark == nil {
			break
		}

		return e.complexity.MotionOfferRecord.Remark(childComplexity), true

	case "MotionOfferRecord.reviewed":
		if e.complexity.MotionOfferRecord.Reviewed == nil {
			break
		}

		args, err := ec.field_MotionOfferRecord_reviewed_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.MotionOfferRecord.Reviewed(childComplexity, args["userId"].(*string)), true

	case "MotionOfferRecord.state":
		if e.complexity.MotionOfferRecord.State == nil {
			break
		}

		return e.complexity.MotionOfferRecord.State(childComplexity), true

	case "MotionOfferRecord.toMotion":
		if e.complexity.MotionOfferRecord.ToMotion == nil {
			break
		}

		return e.complexity.MotionOfferRecord.ToMotion(childComplexity), true

	case "MotionOfferRecord.toMotionId":
		if e.complexity.MotionOfferRecord.ToMotionID == nil {
			break
		}

		return e.complexity.MotionOfferRecord.ToMotionID(childComplexity), true

	case "MotionProperty.id":
		if e.complexity.MotionProperty.ID == nil {
			break
		}

		return e.complexity.MotionProperty.ID(childComplexity), true

	case "MotionProperty.values":
		if e.complexity.MotionProperty.Values == nil {
			break
		}

		return e.complexity.MotionProperty.Values(childComplexity), true

	case "Mutation.acceptMotionOffer":
		if e.complexity.Mutation.AcceptMotionOffer == nil {
			break
		}

		args, err := ec.field_Mutation_acceptMotionOffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AcceptMotionOffer(childComplexity, args["myMotionId"].(string), args["targetMotionId"].(string)), true

	case "Mutation.addMatchingToRecent":
		if e.complexity.Mutation.AddMatchingToRecent == nil {
			break
		}

		args, err := ec.field_Mutation_addMatchingToRecent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddMatchingToRecent(childComplexity, args["matchingId"].(string)), true

	case "Mutation.cancelMatching":
		if e.complexity.Mutation.CancelMatching == nil {
			break
		}

		args, err := ec.field_Mutation_cancelMatching_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelMatching(childComplexity, args["matchingId"].(string)), true

	case "Mutation.cancelMatchingInvitation":
		if e.complexity.Mutation.CancelMatchingInvitation == nil {
			break
		}

		args, err := ec.field_Mutation_cancelMatchingInvitation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelMatchingInvitation(childComplexity, args["invitationId"].(string)), true

	case "Mutation.cancelMotionOffer":
		if e.complexity.Mutation.CancelMotionOffer == nil {
			break
		}

		args, err := ec.field_Mutation_cancelMotionOffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelMotionOffer(childComplexity, args["myMotionId"].(string), args["targetMotionId"].(string)), true

	case "Mutation.cancelThumbsUpMotion":
		if e.complexity.Mutation.CancelThumbsUpMotion == nil {
			break
		}

		args, err := ec.field_Mutation_cancelThumbsUpMotion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelThumbsUpMotion(childComplexity, args["userId"].(*string), args["motionId"].(string)), true

	case "Mutation.closeMotion":
		if e.complexity.Mutation.CloseMotion == nil {
			break
		}

		args, err := ec.field_Mutation_closeMotion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CloseMotion(childComplexity, args["id"].(string)), true

	case "Mutation.confirmMatchingInvitation":
		if e.complexity.Mutation.ConfirmMatchingInvitation == nil {
			break
		}

		args, err := ec.field_Mutation_confirmMatchingInvitation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfirmMatchingInvitation(childComplexity, args["userId"].(*string), args["invitationId"].(string), args["confirm"].(bool)), true

	case "Mutation.confirmMatchingResult":
		if e.complexity.Mutation.ConfirmMatchingResult == nil {
			break
		}

		args, err := ec.field_Mutation_confirmMatchingResult_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfirmMatchingResult(childComplexity, args["userId"].(*string), args["matchingId"].(string), args["reject"].(bool)), true

	case "Mutation.confirmMatchingResultV2":
		if e.complexity.Mutation.ConfirmMatchingResultV2 == nil {
			break
		}

		args, err := ec.field_Mutation_confirmMatchingResultV2_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfirmMatchingResultV2(childComplexity, args["userId"].(*string), args["matchingId"].(string), args["confirm"].(bool)), true

	case "Mutation.createCityTopics":
		if e.complexity.Mutation.CreateCityTopics == nil {
			break
		}

		args, err := ec.field_Mutation_createCityTopics_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCityTopics(childComplexity, args["param"].(models.CreateCityTopicParam)), true

	case "Mutation.createMatching":
		if e.complexity.Mutation.CreateMatching == nil {
			break
		}

		args, err := ec.field_Mutation_createMatching_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMatching(childComplexity, args["userId"].(*string), args["param"].(models.CreateMatchingParam)), true

	case "Mutation.createMatchingInvitation":
		if e.complexity.Mutation.CreateMatchingInvitation == nil {
			break
		}

		args, err := ec.field_Mutation_createMatchingInvitation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMatchingInvitation(childComplexity, args["userId"].(*string), args["param"].(models.CreateMatchingInvitationParam)), true

	case "Mutation.createMatchingV2":
		if e.complexity.Mutation.CreateMatchingV2 == nil {
			break
		}

		args, err := ec.field_Mutation_createMatchingV2_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMatchingV2(childComplexity, args["userId"].(*string), args["param"].(models.CreateMatchingParamV2)), true

	case "Mutation.createMotion":
		if e.complexity.Mutation.CreateMotion == nil {
			break
		}

		args, err := ec.field_Mutation_createMotion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMotion(childComplexity, args["userId"].(*string), args["param"].(models.CreateMotionParam)), true

	case "Mutation.createMotionOffer":
		if e.complexity.Mutation.CreateMotionOffer == nil {
			break
		}

		args, err := ec.field_Mutation_createMotionOffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMotionOffer(childComplexity, args["myMotionId"].(string), args["targetMotionId"].(string)), true

	case "Mutation.createUserJoinTopic":
		if e.complexity.Mutation.CreateUserJoinTopic == nil {
			break
		}

		args, err := ec.field_Mutation_createUserJoinTopic_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUserJoinTopic(childComplexity, args["param"].(models.CreateUserJoinTopicParam)), true

	case "Mutation.finishMatching":
		if e.complexity.Mutation.FinishMatching == nil {
			break
		}

		args, err := ec.field_Mutation_finishMatching_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FinishMatching(childComplexity, args["matchingId"].(string)), true

	case "Mutation.finishMotionOffer":
		if e.complexity.Mutation.FinishMotionOffer == nil {
			break
		}

		args, err := ec.field_Mutation_finishMotionOffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FinishMotionOffer(childComplexity, args["fromMotionId"].(string), args["toMotionId"].(string)), true

	case "Mutation.getAvailableMotionOffer":
		if e.complexity.Mutation.GetAvailableMotionOffer == nil {
			break
		}

		args, err := ec.field_Mutation_getAvailableMotionOffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GetAvailableMotionOffer(childComplexity, args["userId"].(*string), args["targetMotionId"].(string)), true

	case "Mutation.getMatchingScore":
		if e.complexity.Mutation.GetMatchingScore == nil {
			break
		}

		args, err := ec.field_Mutation_getMatchingScore_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GetMatchingScore(childComplexity, args["id1"].(string), args["id2"].(string)), true

	case "Mutation.likeMotion":
		if e.complexity.Mutation.LikeMotion == nil {
			break
		}

		args, err := ec.field_Mutation_likeMotion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.LikeMotion(childComplexity, args["userId"].(*string), args["motionId"].(string)), true

	case "Mutation.notifyNewMotionOffer":
		if e.complexity.Mutation.NotifyNewMotionOffer == nil {
			break
		}

		args, err := ec.field_Mutation_notifyNewMotionOffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.NotifyNewMotionOffer(childComplexity, args["param"].(*models.NotifyNewMotionOfferMessageParam)), true

	case "Mutation.refreshTopicMetrics":
		if e.complexity.Mutation.RefreshTopicMetrics == nil {
			break
		}

		return e.complexity.Mutation.RefreshTopicMetrics(childComplexity), true

	case "Mutation.rejectMotionOffer":
		if e.complexity.Mutation.RejectMotionOffer == nil {
			break
		}

		args, err := ec.field_Mutation_rejectMotionOffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RejectMotionOffer(childComplexity, args["myMotionId"].(string), args["targetMotionId"].(string)), true

	case "Mutation.reviewMatching":
		if e.complexity.Mutation.ReviewMatching == nil {
			break
		}

		args, err := ec.field_Mutation_reviewMatching_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ReviewMatching(childComplexity, args["matchingId"].(string), args["param"].(models.ReviewMatchingParam)), true

	case "Mutation.reviewMotionOffer":
		if e.complexity.Mutation.ReviewMotionOffer == nil {
			break
		}

		args, err := ec.field_Mutation_reviewMotionOffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ReviewMotionOffer(childComplexity, args["userId"].(*string), args["fromMotionId"].(string), args["toMotionId"].(string), args["param"].(models.ReviewMotionParam)), true

	case "Mutation.sendChatInOffer":
		if e.complexity.Mutation.SendChatInOffer == nil {
			break
		}

		args, err := ec.field_Mutation_sendChatInOffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SendChatInOffer(childComplexity, args["myMotionId"].(string), args["targetMotionId"].(string), args["sentence"].(string)), true

	case "Mutation.sendMotionOfferAcceptMessage":
		if e.complexity.Mutation.SendMotionOfferAcceptMessage == nil {
			break
		}

		args, err := ec.field_Mutation_sendMotionOfferAcceptMessage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SendMotionOfferAcceptMessage(childComplexity, args["id"].(int)), true

	case "Mutation.startMatching":
		if e.complexity.Mutation.StartMatching == nil {
			break
		}

		return e.complexity.Mutation.StartMatching(childComplexity), true

	case "Mutation.thumbsUpMotion":
		if e.complexity.Mutation.ThumbsUpMotion == nil {
			break
		}

		args, err := ec.field_Mutation_thumbsUpMotion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ThumbsUpMotion(childComplexity, args["userId"].(*string), args["motionId"].(string)), true

	case "Mutation.thumbsUpMotions":
		if e.complexity.Mutation.ThumbsUpMotions == nil {
			break
		}

		args, err := ec.field_Mutation_thumbsUpMotions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ThumbsUpMotions(childComplexity, args["userId"].(*string), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Mutation.thumbsUpMotionsCount":
		if e.complexity.Mutation.ThumbsUpMotionsCount == nil {
			break
		}

		args, err := ec.field_Mutation_thumbsUpMotionsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ThumbsUpMotionsCount(childComplexity, args["userId"].(*string)), true

	case "Mutation.unlikeMotion":
		if e.complexity.Mutation.UnlikeMotion == nil {
			break
		}

		args, err := ec.field_Mutation_unlikeMotion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnlikeMotion(childComplexity, args["userId"].(*string), args["motionId"].(string)), true

	case "Mutation.updateCityTopics":
		if e.complexity.Mutation.UpdateCityTopics == nil {
			break
		}

		args, err := ec.field_Mutation_updateCityTopics_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCityTopics(childComplexity, args["cityId"].(string), args["param"].(models.UpdateCityTopicParam)), true

	case "Mutation.updateDurationConstraint":
		if e.complexity.Mutation.UpdateDurationConstraint == nil {
			break
		}

		args, err := ec.field_Mutation_updateDurationConstraint_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateDurationConstraint(childComplexity, args["userId"].(string), args["param"].(models.UpdateDurationConstraintParam)), true

	case "Mutation.updateHotTopicsInArea":
		if e.complexity.Mutation.UpdateHotTopicsInArea == nil {
			break
		}

		args, err := ec.field_Mutation_updateHotTopicsInArea_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateHotTopicsInArea(childComplexity, args["cityId"].(string), args["param"].(models.UpdateHotTopicParam)), true

	case "Mutation.updateMatching":
		if e.complexity.Mutation.UpdateMatching == nil {
			break
		}

		args, err := ec.field_Mutation_updateMatching_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMatching(childComplexity, args["matchingId"].(string), args["param"].(models.UpdateMatchingParam)), true

	case "Mutation.updateMatchingDurationConstraint":
		if e.complexity.Mutation.UpdateMatchingDurationConstraint == nil {
			break
		}

		args, err := ec.field_Mutation_updateMatchingDurationConstraint_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMatchingDurationConstraint(childComplexity, args["userId"].(string), args["param"].(models.UpdateMatchingDurationConstraintParam)), true

	case "Mutation.updateMatchingInvitation":
		if e.complexity.Mutation.UpdateMatchingInvitation == nil {
			break
		}

		args, err := ec.field_Mutation_updateMatchingInvitation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMatchingInvitation(childComplexity, args["invitationId"].(string), args["param"].(models.UpdateMatchingInvitationParam)), true

	case "Mutation.updateMatchingQuota":
		if e.complexity.Mutation.UpdateMatchingQuota == nil {
			break
		}

		args, err := ec.field_Mutation_updateMatchingQuota_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMatchingQuota(childComplexity, args["userId"].(string), args["param"].(models.UpdateMatchingQuotaParam)), true

	case "Mutation.updateMotion":
		if e.complexity.Mutation.UpdateMotion == nil {
			break
		}

		args, err := ec.field_Mutation_updateMotion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMotion(childComplexity, args["id"].(string), args["param"].(models.UpdateMotionParam)), true

	case "Mutation.updateRecentMatching":
		if e.complexity.Mutation.UpdateRecentMatching == nil {
			break
		}

		args, err := ec.field_Mutation_updateRecentMatching_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRecentMatching(childComplexity, args["id"].(string), args["param"].(models.UpdateRecentMatchingParam)), true

	case "Mutation.updateUserJoinTopic":
		if e.complexity.Mutation.UpdateUserJoinTopic == nil {
			break
		}

		args, err := ec.field_Mutation_updateUserJoinTopic_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUserJoinTopic(childComplexity, args["id"].(int), args["param"].(models.UpdateUserJoinTopicParam)), true

	case "Mutation.userUpdateMotion":
		if e.complexity.Mutation.UserUpdateMotion == nil {
			break
		}

		args, err := ec.field_Mutation_userUpdateMotion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserUpdateMotion(childComplexity, args["myMotionId"].(string), args["param"].(models.UserUpdateMotionParam)), true

	case "Query.activeMotions":
		if e.complexity.Query.ActiveMotions == nil {
			break
		}

		args, err := ec.field_Query_activeMotions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ActiveMotions(childComplexity, args["userId"].(*string)), true

	case "Query.chatGroupByResultId":
		if e.complexity.Query.ChatGroupByResultID == nil {
			break
		}

		args, err := ec.field_Query_chatGroupByResultId_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ChatGroupByResultID(childComplexity, args["resultId"].(int)), true

	case "Query.citiesTopics":
		if e.complexity.Query.CitiesTopics == nil {
			break
		}

		args, err := ec.field_Query_citiesTopics_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CitiesTopics(childComplexity, args["filter"].(*models.CitiesTopicsFilter), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.citiesTopicsCount":
		if e.complexity.Query.CitiesTopicsCount == nil {
			break
		}

		args, err := ec.field_Query_citiesTopicsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CitiesTopicsCount(childComplexity, args["filter"].(*models.CitiesTopicsFilter)), true

	case "Query.cityDistribution":
		if e.complexity.Query.CityDistribution == nil {
			break
		}

		return e.complexity.Query.CityDistribution(childComplexity), true

	case "Query.cityTopics":
		if e.complexity.Query.CityTopics == nil {
			break
		}

		args, err := ec.field_Query_cityTopics_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CityTopics(childComplexity, args["cityId"].(string)), true

	case "Query.discoverCategoryMotions":
		if e.complexity.Query.DiscoverCategoryMotions == nil {
			break
		}

		args, err := ec.field_Query_discoverCategoryMotions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DiscoverCategoryMotions(childComplexity, args["userId"].(*string), args["filter"].(*models.DiscoverTopicCategoryMotionFilter), args["topicCategoryId"].(string), args["nextToken"].(*string)), true

	case "Query.discoverLatestCategoryMotions":
		if e.complexity.Query.DiscoverLatestCategoryMotions == nil {
			break
		}

		args, err := ec.field_Query_discoverLatestCategoryMotions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DiscoverLatestCategoryMotions(childComplexity, args["filter"].(models.DiscoverTopicCategoryMotionFilter), args["topicCategoryId"].(string), args["lastId"].(*string)), true

	case "Query.getDiscoverMotion":
		if e.complexity.Query.GetDiscoverMotion == nil {
			break
		}

		args, err := ec.field_Query_getDiscoverMotion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetDiscoverMotion(childComplexity, args["motionId"].(string)), true

	case "Query.getMotionOffer":
		if e.complexity.Query.GetMotionOffer == nil {
			break
		}

		args, err := ec.field_Query_getMotionOffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMotionOffer(childComplexity, args["motionId"].(string), args["toMotionId"].(string)), true

	case "Query.hotTopics":
		if e.complexity.Query.HotTopics == nil {
			break
		}

		args, err := ec.field_Query_hotTopics_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HotTopics(childComplexity, args["filter"].(*models.HotTopicsFilter), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.hotTopicsCount":
		if e.complexity.Query.HotTopicsCount == nil {
			break
		}

		args, err := ec.field_Query_hotTopicsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HotTopicsCount(childComplexity, args["filter"].(*models.HotTopicsFilter)), true

	case "Query.hotTopicsInArea":
		if e.complexity.Query.HotTopicsInArea == nil {
			break
		}

		args, err := ec.field_Query_hotTopicsInArea_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HotTopicsInArea(childComplexity, args["cityId"].(*string)), true

	case "Query.inMotionOffers":
		if e.complexity.Query.InMotionOffers == nil {
			break
		}

		args, err := ec.field_Query_inMotionOffers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.InMotionOffers(childComplexity, args["motionId"].(string)), true

	case "Query.invitation":
		if e.complexity.Query.Invitation == nil {
			break
		}

		args, err := ec.field_Query_invitation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Invitation(childComplexity, args["userId"].(*string), args["id"].(string)), true

	case "Query.invitations":
		if e.complexity.Query.Invitations == nil {
			break
		}

		args, err := ec.field_Query_invitations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Invitations(childComplexity, args["userId"].(*string), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.invitationsCount":
		if e.complexity.Query.InvitationsCount == nil {
			break
		}

		args, err := ec.field_Query_invitationsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.InvitationsCount(childComplexity, args["userId"].(*string)), true

	case "Query.likedMotions":
		if e.complexity.Query.LikedMotions == nil {
			break
		}

		args, err := ec.field_Query_likedMotions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.LikedMotions(childComplexity, args["userId"].(*string), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.likedMotionsCount":
		if e.complexity.Query.LikedMotionsCount == nil {
			break
		}

		args, err := ec.field_Query_likedMotionsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.LikedMotionsCount(childComplexity, args["userId"].(*string)), true

	case "Query.matching":
		if e.complexity.Query.Matching == nil {
			break
		}

		args, err := ec.field_Query_matching_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Matching(childComplexity, args["id"].(string)), true

	case "Query.matchingDurationConstraints":
		if e.complexity.Query.MatchingDurationConstraints == nil {
			break
		}

		args, err := ec.field_Query_matchingDurationConstraints_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MatchingDurationConstraints(childComplexity, args["userId"].(string)), true

	case "Query.matchingInvitations":
		if e.complexity.Query.MatchingInvitations == nil {
			break
		}

		args, err := ec.field_Query_matchingInvitations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MatchingInvitations(childComplexity, args["filter"].(*models.MatchingInvitationFilter), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.matchingInvitationsCount":
		if e.complexity.Query.MatchingInvitationsCount == nil {
			break
		}

		args, err := ec.field_Query_matchingInvitationsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MatchingInvitationsCount(childComplexity, args["filter"].(*models.MatchingInvitationFilter)), true

	case "Query.matchingResult":
		if e.complexity.Query.MatchingResult == nil {
			break
		}

		args, err := ec.field_Query_matchingResult_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MatchingResult(childComplexity, args["id"].(int)), true

	case "Query.matchingResultByChatGroupId":
		if e.complexity.Query.MatchingResultByChatGroupID == nil {
			break
		}

		args, err := ec.field_Query_matchingResultByChatGroupId_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MatchingResultByChatGroupID(childComplexity, args["userId"].(*string), args["chatGroupId"].(string)), true

	case "Query.matchingResults":
		if e.complexity.Query.MatchingResults == nil {
			break
		}

		args, err := ec.field_Query_matchingResults_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MatchingResults(childComplexity, args["filter"].(*models.MatchingResultFilter), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.matchingResultsCount":
		if e.complexity.Query.MatchingResultsCount == nil {
			break
		}

		args, err := ec.field_Query_matchingResultsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MatchingResultsCount(childComplexity, args["filter"].(*models.MatchingResultFilter)), true

	case "Query.matchings":
		if e.complexity.Query.Matchings == nil {
			break
		}

		args, err := ec.field_Query_matchings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Matchings(childComplexity, args["filter"].(*models.MatchingFilter), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.matchingsCount":
		if e.complexity.Query.MatchingsCount == nil {
			break
		}

		args, err := ec.field_Query_matchingsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MatchingsCount(childComplexity, args["filter"].(*models.MatchingFilter)), true

	case "Query.motion":
		if e.complexity.Query.Motion == nil {
			break
		}

		args, err := ec.field_Query_motion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Motion(childComplexity, args["id"].(string)), true

	case "Query.motionSummary":
		if e.complexity.Query.MotionSummary == nil {
			break
		}

		return e.complexity.Query.MotionSummary(childComplexity), true

	case "Query.motions":
		if e.complexity.Query.Motions == nil {
			break
		}

		args, err := ec.field_Query_motions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Motions(childComplexity, args["filter"].(*models.MotionFilter), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.motionsCount":
		if e.complexity.Query.MotionsCount == nil {
			break
		}

		args, err := ec.field_Query_motionsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MotionsCount(childComplexity, args["filter"].(*models.MotionFilter)), true

	case "Query.outMotionOffers":
		if e.complexity.Query.OutMotionOffers == nil {
			break
		}

		args, err := ec.field_Query_outMotionOffers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.OutMotionOffers(childComplexity, args["motionId"].(string)), true

	case "Query.previewMatchingsOfTopic":
		if e.complexity.Query.PreviewMatchingsOfTopic == nil {
			break
		}

		args, err := ec.field_Query_previewMatchingsOfTopic_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PreviewMatchingsOfTopic(childComplexity, args["cityId"].(string), args["topicId"].(string), args["limit"].(*int)), true

	case "Query.recentMatching":
		if e.complexity.Query.RecentMatching == nil {
			break
		}

		args, err := ec.field_Query_recentMatching_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RecentMatching(childComplexity, args["id"].(string)), true

	case "Query.recentMatchings":
		if e.complexity.Query.RecentMatchings == nil {
			break
		}

		args, err := ec.field_Query_recentMatchings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RecentMatchings(childComplexity, args["filter"].(*models.RecentMatchingFilter), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.recentMatchingsCount":
		if e.complexity.Query.RecentMatchingsCount == nil {
			break
		}

		args, err := ec.field_Query_recentMatchingsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RecentMatchingsCount(childComplexity, args["filter"].(*models.RecentMatchingFilter)), true

	case "Query.topicDistribution":
		if e.complexity.Query.TopicDistribution == nil {
			break
		}

		return e.complexity.Query.TopicDistribution(childComplexity), true

	case "Query.unconfirmedInvitationCount":
		if e.complexity.Query.UnconfirmedInvitationCount == nil {
			break
		}

		args, err := ec.field_Query_unconfirmedInvitationCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UnconfirmedInvitationCount(childComplexity, args["userId"].(*string)), true

	case "Query.unconfirmedInvitations":
		if e.complexity.Query.UnconfirmedInvitations == nil {
			break
		}

		args, err := ec.field_Query_unconfirmedInvitations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UnconfirmedInvitations(childComplexity, args["userId"].(*string)), true

	case "Query.unconfirmedUserMatchings":
		if e.complexity.Query.UnconfirmedUserMatchings == nil {
			break
		}

		args, err := ec.field_Query_unconfirmedUserMatchings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UnconfirmedUserMatchings(childComplexity, args["userId"].(*string)), true

	case "Query.userDurationConstraint":
		if e.complexity.Query.UserDurationConstraint == nil {
			break
		}

		args, err := ec.field_Query_userDurationConstraint_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserDurationConstraint(childComplexity, args["userId"].(string)), true

	case "Query.userJoinTopic":
		if e.complexity.Query.UserJoinTopic == nil {
			break
		}

		args, err := ec.field_Query_userJoinTopic_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserJoinTopic(childComplexity, args["id"].(int)), true

	case "Query.userJoinTopics":
		if e.complexity.Query.UserJoinTopics == nil {
			break
		}

		args, err := ec.field_Query_userJoinTopics_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserJoinTopics(childComplexity, args["filter"].(*models.UserJoinTopicFilter), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.userJoinTopicsCount":
		if e.complexity.Query.UserJoinTopicsCount == nil {
			break
		}

		args, err := ec.field_Query_userJoinTopicsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserJoinTopicsCount(childComplexity, args["filter"].(*models.UserJoinTopicFilter)), true

	case "Query.userMatchingCalendar":
		if e.complexity.Query.UserMatchingCalendar == nil {
			break
		}

		args, err := ec.field_Query_userMatchingCalendar_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserMatchingCalendar(childComplexity, args["userId"].(*string), args["param"].(models.UserMatchingCalenderParam)), true

	case "Query.userMatchingQuota":
		if e.complexity.Query.UserMatchingQuota == nil {
			break
		}

		args, err := ec.field_Query_userMatchingQuota_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserMatchingQuota(childComplexity, args["userId"].(string)), true

	case "Query.userMatchings":
		if e.complexity.Query.UserMatchings == nil {
			break
		}

		args, err := ec.field_Query_userMatchings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserMatchings(childComplexity, args["userId"].(*string), args["filter"].(*models.UserMatchingFilter), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.userMatchingsCount":
		if e.complexity.Query.UserMatchingsCount == nil {
			break
		}

		args, err := ec.field_Query_userMatchingsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserMatchingsCount(childComplexity, args["userId"].(*string), args["filter"].(*models.UserMatchingFilter)), true

	case "Query.userMatchingsInTheDay":
		if e.complexity.Query.UserMatchingsInTheDay == nil {
			break
		}

		args, err := ec.field_Query_userMatchingsInTheDay_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserMatchingsInTheDay(childComplexity, args["userId"].(*string), args["param"].(models.UserMatchingInTheDayParam)), true

	case "Query.userMotions":
		if e.complexity.Query.UserMotions == nil {
			break
		}

		args, err := ec.field_Query_userMotions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserMotions(childComplexity, args["userId"].(*string), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.userMotionsCount":
		if e.complexity.Query.UserMotionsCount == nil {
			break
		}

		args, err := ec.field_Query_userMotionsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserMotionsCount(childComplexity, args["userId"].(*string)), true

	case "Query.yesterdayMatchingCount":
		if e.complexity.Query.YesterdayMatchingCount == nil {
			break
		}

		return e.complexity.Query.YesterdayMatchingCount(childComplexity), true

	case "Query._service":
		if e.complexity.Query.__resolve__service == nil {
			break
		}

		return e.complexity.Query.__resolve__service(childComplexity), true

	case "Query._entities":
		if e.complexity.Query.__resolve_entities == nil {
			break
		}

		args, err := ec.field_Query__entities_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.__resolve_entities(childComplexity, args["representations"].([]map[string]interface{})), true

	case "RecentMatching.city":
		if e.complexity.RecentMatching.City == nil {
			break
		}

		return e.complexity.RecentMatching.City(childComplexity), true

	case "RecentMatching.cityId":
		if e.complexity.RecentMatching.CityID == nil {
			break
		}

		return e.complexity.RecentMatching.CityID(childComplexity), true

	case "RecentMatching.createdAt":
		if e.complexity.RecentMatching.CreatedAt == nil {
			break
		}

		return e.complexity.RecentMatching.CreatedAt(childComplexity), true

	case "RecentMatching.id":
		if e.complexity.RecentMatching.ID == nil {
			break
		}

		return e.complexity.RecentMatching.ID(childComplexity), true

	case "RecentMatching.matchingIds":
		if e.complexity.RecentMatching.MatchingIDs == nil {
			break
		}

		return e.complexity.RecentMatching.MatchingIDs(childComplexity), true

	case "RecentMatching.matchings":
		if e.complexity.RecentMatching.Matchings == nil {
			break
		}

		return e.complexity.RecentMatching.Matchings(childComplexity), true

	case "RecentMatching.topic":
		if e.complexity.RecentMatching.Topic == nil {
			break
		}

		return e.complexity.RecentMatching.Topic(childComplexity), true

	case "RecentMatching.topicId":
		if e.complexity.RecentMatching.TopicID == nil {
			break
		}

		return e.complexity.RecentMatching.TopicID(childComplexity), true

	case "RecentMatching.updatedAt":
		if e.complexity.RecentMatching.UpdatedAt == nil {
			break
		}

		return e.complexity.RecentMatching.UpdatedAt(childComplexity), true

	case "SimpleAvatarUser.avatar":
		if e.complexity.SimpleAvatarUser.Avatar == nil {
			break
		}

		return e.complexity.SimpleAvatarUser.Avatar(childComplexity), true

	case "SimpleAvatarUser.nickname":
		if e.complexity.SimpleAvatarUser.Nickname == nil {
			break
		}

		return e.complexity.SimpleAvatarUser.Nickname(childComplexity), true

	case "Summary.count":
		if e.complexity.Summary.Count == nil {
			break
		}

		return e.complexity.Summary.Count(childComplexity), true

	case "Topic.fuzzyMatchingNum":
		if e.complexity.Topic.FuzzyMatchingNum == nil {
			break
		}

		args, err := ec.field_Topic_fuzzyMatchingNum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Topic.FuzzyMatchingNum(childComplexity, args["cityId"].(*string)), true

	case "Topic.id":
		if e.complexity.Topic.ID == nil {
			break
		}

		return e.complexity.Topic.ID(childComplexity), true

	case "Topic.matchingNum":
		if e.complexity.Topic.MatchingNum == nil {
			break
		}

		args, err := ec.field_Topic_matchingNum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Topic.MatchingNum(childComplexity, args["cityId"].(*string)), true

	case "Topic.recentUsers":
		if e.complexity.Topic.RecentUsers == nil {
			break
		}

		args, err := ec.field_Topic_recentUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Topic.RecentUsers(childComplexity, args["cityId"].(*string)), true

	case "TopicMetrics.heat":
		if e.complexity.TopicMetrics.Heat == nil {
			break
		}

		return e.complexity.TopicMetrics.Heat(childComplexity), true

	case "TopicMetrics.id":
		if e.complexity.TopicMetrics.ID == nil {
			break
		}

		return e.complexity.TopicMetrics.ID(childComplexity), true

	case "TopicMetrics.matched":
		if e.complexity.TopicMetrics.Matched == nil {
			break
		}

		return e.complexity.TopicMetrics.Matched(childComplexity), true

	case "TopicMetrics.matching":
		if e.complexity.TopicMetrics.Matching == nil {
			break
		}

		return e.complexity.TopicMetrics.Matching(childComplexity), true

	case "TopicMetrics.topic":
		if e.complexity.TopicMetrics.Topic == nil {
			break
		}

		return e.complexity.TopicMetrics.Topic(childComplexity), true

	case "TopicOptionConfig.topicId":
		if e.complexity.TopicOptionConfig.TopicID == nil {
			break
		}

		return e.complexity.TopicOptionConfig.TopicID(childComplexity), true

	case "TopicToMatching.matchingIds":
		if e.complexity.TopicToMatching.MatchingIds == nil {
			break
		}

		return e.complexity.TopicToMatching.MatchingIds(childComplexity), true

	case "TopicToMatching.topic":
		if e.complexity.TopicToMatching.Topic == nil {
			break
		}

		return e.complexity.TopicToMatching.Topic(childComplexity), true

	case "TopicToMatching.topicId":
		if e.complexity.TopicToMatching.TopicID == nil {
			break
		}

		return e.complexity.TopicToMatching.TopicID(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.matchingQuota":
		if e.complexity.User.MatchingQuota == nil {
			break
		}

		return e.complexity.User.MatchingQuota(childComplexity), true

	case "UserConfirmState.state":
		if e.complexity.UserConfirmState.State == nil {
			break
		}

		return e.complexity.UserConfirmState.State(childComplexity), true

	case "UserConfirmState.userId":
		if e.complexity.UserConfirmState.UserID == nil {
			break
		}

		return e.complexity.UserConfirmState.UserID(childComplexity), true

	case "UserJoinTopic.city":
		if e.complexity.UserJoinTopic.City == nil {
			break
		}

		return e.complexity.UserJoinTopic.City(childComplexity), true

	case "UserJoinTopic.cityId":
		if e.complexity.UserJoinTopic.CityID == nil {
			break
		}

		return e.complexity.UserJoinTopic.CityID(childComplexity), true

	case "UserJoinTopic.createdAt":
		if e.complexity.UserJoinTopic.CreatedAt == nil {
			break
		}

		return e.complexity.UserJoinTopic.CreatedAt(childComplexity), true

	case "UserJoinTopic.id":
		if e.complexity.UserJoinTopic.ID == nil {
			break
		}

		return e.complexity.UserJoinTopic.ID(childComplexity), true

	case "UserJoinTopic.latestMatchingId":
		if e.complexity.UserJoinTopic.LatestMatchingID == nil {
			break
		}

		return e.complexity.UserJoinTopic.LatestMatchingID(childComplexity), true

	case "UserJoinTopic.matching":
		if e.complexity.UserJoinTopic.Matching == nil {
			break
		}

		return e.complexity.UserJoinTopic.Matching(childComplexity), true

	case "UserJoinTopic.topic":
		if e.complexity.UserJoinTopic.Topic == nil {
			break
		}

		return e.complexity.UserJoinTopic.Topic(childComplexity), true

	case "UserJoinTopic.topicId":
		if e.complexity.UserJoinTopic.TopicID == nil {
			break
		}

		return e.complexity.UserJoinTopic.TopicID(childComplexity), true

	case "UserJoinTopic.updatedAt":
		if e.complexity.UserJoinTopic.UpdatedAt == nil {
			break
		}

		return e.complexity.UserJoinTopic.UpdatedAt(childComplexity), true

	case "UserJoinTopic.user":
		if e.complexity.UserJoinTopic.User == nil {
			break
		}

		return e.complexity.UserJoinTopic.User(childComplexity), true

	case "UserJoinTopic.userId":
		if e.complexity.UserJoinTopic.UserID == nil {
			break
		}

		return e.complexity.UserJoinTopic.UserID(childComplexity), true

	case "UserLikeMotion.createdAt":
		if e.complexity.UserLikeMotion.CreatedAt == nil {
			break
		}

		return e.complexity.UserLikeMotion.CreatedAt(childComplexity), true

	case "UserLikeMotion.motion":
		if e.complexity.UserLikeMotion.Motion == nil {
			break
		}

		return e.complexity.UserLikeMotion.Motion(childComplexity), true

	case "UserLikeMotion.toMotionId":
		if e.complexity.UserLikeMotion.ToMotionID == nil {
			break
		}

		return e.complexity.UserLikeMotion.ToMotionID(childComplexity), true

	case "UserLikeMotion.toUserId":
		if e.complexity.UserLikeMotion.ToUserID == nil {
			break
		}

		return e.complexity.UserLikeMotion.ToUserID(childComplexity), true

	case "UserLikeMotion.userId":
		if e.complexity.UserLikeMotion.UserID == nil {
			break
		}

		return e.complexity.UserLikeMotion.UserID(childComplexity), true

	case "UserThumbsUpMotion.createdAt":
		if e.complexity.UserThumbsUpMotion.CreatedAt == nil {
			break
		}

		return e.complexity.UserThumbsUpMotion.CreatedAt(childComplexity), true

	case "UserThumbsUpMotion.toMotionId":
		if e.complexity.UserThumbsUpMotion.ToMotionID == nil {
			break
		}

		return e.complexity.UserThumbsUpMotion.ToMotionID(childComplexity), true

	case "UserThumbsUpMotion.userId":
		if e.complexity.UserThumbsUpMotion.UserID == nil {
			break
		}

		return e.complexity.UserThumbsUpMotion.UserID(childComplexity), true

	case "_Service.sdl":
		if e.complexity._Service.SDL == nil {
			break
		}

		return e.complexity._Service.SDL(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCitiesTopicsFilter,
		ec.unmarshalInputCreateCityTopicParam,
		ec.unmarshalInputCreateMatchingInvitationParam,
		ec.unmarshalInputCreateMatchingParam,
		ec.unmarshalInputCreateMatchingParamV2,
		ec.unmarshalInputCreateMotionParam,
		ec.unmarshalInputCreateUserJoinTopicParam,
		ec.unmarshalInputDiscoverTopicCategoryMotionFilter,
		ec.unmarshalInputGraphQLPaginator,
		ec.unmarshalInputHotTopicsFilter,
		ec.unmarshalInputMatchingFilter,
		ec.unmarshalInputMatchingInvitationFilter,
		ec.unmarshalInputMatchingPropertyParam,
		ec.unmarshalInputMatchingResultFilter,
		ec.unmarshalInputMotionFilter,
		ec.unmarshalInputMotionPropertyParam,
		ec.unmarshalInputNotifyNewMotionOfferMessageParam,
		ec.unmarshalInputRecentMatchingFilter,
		ec.unmarshalInputReviewMatchingParam,
		ec.unmarshalInputReviewMotionParam,
		ec.unmarshalInputUpdateCityTopicParam,
		ec.unmarshalInputUpdateDurationConstraintParam,
		ec.unmarshalInputUpdateHotTopicMetricsParam,
		ec.unmarshalInputUpdateHotTopicParam,
		ec.unmarshalInputUpdateMatchingDurationConstraintParam,
		ec.unmarshalInputUpdateMatchingInvitationParam,
		ec.unmarshalInputUpdateMatchingParam,
		ec.unmarshalInputUpdateMatchingQuotaParam,
		ec.unmarshalInputUpdateMotionParam,
		ec.unmarshalInputUpdateRecentMatchingParam,
		ec.unmarshalInputUpdateUserJoinTopicParam,
		ec.unmarshalInputUserJoinTopicFilter,
		ec.unmarshalInputUserMatchingCalenderParam,
		ec.unmarshalInputUserMatchingFilter,
		ec.unmarshalInputUserMatchingInTheDayParam,
		ec.unmarshalInputUserUpdateMotionParam,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

//go:embed "schema.graphqls" "matching-discover.graphql" "matching-invitation.graphql" "matching.graphql" "motion-discover.graphql" "motion.graphql" "topic.graphql" "user-like-motion.graphql"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "schema.graphqls", Input: sourceData("schema.graphqls"), BuiltIn: false},
	{Name: "matching-discover.graphql", Input: sourceData("matching-discover.graphql"), BuiltIn: false},
	{Name: "matching-invitation.graphql", Input: sourceData("matching-invitation.graphql"), BuiltIn: false},
	{Name: "matching.graphql", Input: sourceData("matching.graphql"), BuiltIn: false},
	{Name: "motion-discover.graphql", Input: sourceData("motion-discover.graphql"), BuiltIn: false},
	{Name: "motion.graphql", Input: sourceData("motion.graphql"), BuiltIn: false},
	{Name: "topic.graphql", Input: sourceData("topic.graphql"), BuiltIn: false},
	{Name: "user-like-motion.graphql", Input: sourceData("user-like-motion.graphql"), BuiltIn: false},
	{Name: "../federation/directives.graphql", Input: `
	directive @composeDirective(name: String!) repeatable on SCHEMA
	directive @extends on OBJECT | INTERFACE
	directive @external on OBJECT | FIELD_DEFINITION
	directive @key(fields: FieldSet!, resolvable: Boolean = true) repeatable on OBJECT | INTERFACE
	directive @inaccessible on
	  | ARGUMENT_DEFINITION
	  | ENUM
	  | ENUM_VALUE
	  | FIELD_DEFINITION
	  | INPUT_FIELD_DEFINITION
	  | INPUT_OBJECT
	  | INTERFACE
	  | OBJECT
	  | SCALAR
	  | UNION
	directive @interfaceObject on OBJECT
	directive @link(import: [String!], url: String!) repeatable on SCHEMA
	directive @override(from: String!) on FIELD_DEFINITION
	directive @provides(fields: FieldSet!) on FIELD_DEFINITION
	directive @requires(fields: FieldSet!) on FIELD_DEFINITION
	directive @shareable repeatable on FIELD_DEFINITION | OBJECT
	directive @tag(name: String!) repeatable on
	  | ARGUMENT_DEFINITION
	  | ENUM
	  | ENUM_VALUE
	  | FIELD_DEFINITION
	  | INPUT_FIELD_DEFINITION
	  | INPUT_OBJECT
	  | INTERFACE
	  | OBJECT
	  | SCALAR
	  | UNION
	scalar _Any
	scalar FieldSet
`, BuiltIn: true},
	{Name: "../federation/entity.graphql", Input: `
# a union of all types that use the @key directive
union _Entity = Area | ChatGroup | LevelRights | Matching | MatchingQuota | Topic | TopicOptionConfig | User

# fake type to build resolver interfaces for users to implement
type Entity {
		findLevelRightsByLevel(level: Int!,): LevelRights!
	findMatchingByID(id: String!,): Matching!
	findMatchingQuotaByUserID(userID: String!,): MatchingQuota!
	findTopicByID(id: String!,): Topic!
	findUserByID(id: String!,): User!

}

type _Service {
  sdl: String
}

extend type Query {
  _entities(representations: [_Any!]!): [_Entity]!
  _service: _Service!
}
`, BuiltIn: true},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_composeDirective_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_DiscoverMotion_liked_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_DiscoverMotion_submitted_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_DiscoverMotion_thumbsUp_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Entity_findLevelRightsByLevel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["level"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["level"] = arg0
	return args, nil
}

func (ec *executionContext) field_Entity_findMatchingByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Entity_findMatchingQuotaByUserID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Entity_findTopicByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Entity_findUserByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_MotionOfferRecord_reviewed_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_acceptMotionOffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["myMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("myMotionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["myMotionId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["targetMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetMotionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["targetMotionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addMatchingToRecent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["matchingId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchingId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["matchingId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cancelMatchingInvitation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["invitationId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("invitationId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["invitationId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cancelMatching_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["matchingId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchingId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["matchingId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cancelMotionOffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["myMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("myMotionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["myMotionId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["targetMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetMotionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["targetMotionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_cancelThumbsUpMotion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["motionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("motionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["motionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_closeMotion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_confirmMatchingInvitation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["invitationId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("invitationId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["invitationId"] = arg1
	var arg2 bool
	if tmp, ok := rawArgs["confirm"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("confirm"))
		arg2, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["confirm"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_confirmMatchingResultV2_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["matchingId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchingId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["matchingId"] = arg1
	var arg2 bool
	if tmp, ok := rawArgs["confirm"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("confirm"))
		arg2, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["confirm"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_confirmMatchingResult_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["matchingId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchingId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["matchingId"] = arg1
	var arg2 bool
	if tmp, ok := rawArgs["reject"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("reject"))
		arg2, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reject"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_createCityTopics_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreateCityTopicParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg0, err = ec.unmarshalNCreateCityTopicParam2whaleᚋpkgᚋmodelsᚐCreateCityTopicParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createMatchingInvitation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 models.CreateMatchingInvitationParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNCreateMatchingInvitationParam2whaleᚋpkgᚋmodelsᚐCreateMatchingInvitationParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createMatchingV2_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 models.CreateMatchingParamV2
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNCreateMatchingParamV22whaleᚋpkgᚋmodelsᚐCreateMatchingParamV2(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createMatching_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 models.CreateMatchingParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNCreateMatchingParam2whaleᚋpkgᚋmodelsᚐCreateMatchingParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createMotionOffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["myMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("myMotionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["myMotionId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["targetMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetMotionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["targetMotionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createMotion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 models.CreateMotionParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNCreateMotionParam2whaleᚋpkgᚋmodelsᚐCreateMotionParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createUserJoinTopic_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreateUserJoinTopicParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg0, err = ec.unmarshalNCreateUserJoinTopicParam2whaleᚋpkgᚋmodelsᚐCreateUserJoinTopicParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_finishMatching_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["matchingId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchingId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["matchingId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_finishMotionOffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["fromMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fromMotionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["fromMotionId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["toMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toMotionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["toMotionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_getAvailableMotionOffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["targetMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetMotionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["targetMotionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_getMatchingScore_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id1"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id1"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id1"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["id2"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id2"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id2"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_likeMotion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["motionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("motionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["motionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_notifyNewMotionOffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.NotifyNewMotionOfferMessageParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg0, err = ec.unmarshalONotifyNewMotionOfferMessageParam2ᚖwhaleᚋpkgᚋmodelsᚐNotifyNewMotionOfferMessageParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_rejectMotionOffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["myMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("myMotionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["myMotionId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["targetMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetMotionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["targetMotionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_reviewMatching_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["matchingId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchingId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["matchingId"] = arg0
	var arg1 models.ReviewMatchingParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNReviewMatchingParam2whaleᚋpkgᚋmodelsᚐReviewMatchingParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_reviewMotionOffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["fromMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fromMotionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["fromMotionId"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["toMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toMotionId"))
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["toMotionId"] = arg2
	var arg3 models.ReviewMotionParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg3, err = ec.unmarshalNReviewMotionParam2whaleᚋpkgᚋmodelsᚐReviewMotionParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg3
	return args, nil
}

func (ec *executionContext) field_Mutation_sendChatInOffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["myMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("myMotionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["myMotionId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["targetMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetMotionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["targetMotionId"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["sentence"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sentence"))
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sentence"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_sendMotionOfferAcceptMessage_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_thumbsUpMotion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["motionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("motionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["motionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_thumbsUpMotionsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_thumbsUpMotions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2ᚖgithubᚗcomᚋletjoyᚑclubᚋmidaᚑtoolᚋgraphqlutilᚐGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_unlikeMotion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["motionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("motionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["motionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateCityTopics_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["cityId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["cityId"] = arg0
	var arg1 models.UpdateCityTopicParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUpdateCityTopicParam2whaleᚋpkgᚋmodelsᚐUpdateCityTopicParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateDurationConstraint_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 models.UpdateDurationConstraintParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUpdateDurationConstraintParam2whaleᚋpkgᚋmodelsᚐUpdateDurationConstraintParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateHotTopicsInArea_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["cityId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["cityId"] = arg0
	var arg1 models.UpdateHotTopicParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUpdateHotTopicParam2whaleᚋpkgᚋmodelsᚐUpdateHotTopicParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateMatchingDurationConstraint_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 models.UpdateMatchingDurationConstraintParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUpdateMatchingDurationConstraintParam2whaleᚋpkgᚋmodelsᚐUpdateMatchingDurationConstraintParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateMatchingInvitation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["invitationId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("invitationId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["invitationId"] = arg0
	var arg1 models.UpdateMatchingInvitationParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUpdateMatchingInvitationParam2whaleᚋpkgᚋmodelsᚐUpdateMatchingInvitationParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateMatchingQuota_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 models.UpdateMatchingQuotaParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUpdateMatchingQuotaParam2whaleᚋpkgᚋmodelsᚐUpdateMatchingQuotaParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateMatching_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["matchingId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchingId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["matchingId"] = arg0
	var arg1 models.UpdateMatchingParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUpdateMatchingParam2whaleᚋpkgᚋmodelsᚐUpdateMatchingParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateMotion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 models.UpdateMotionParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUpdateMotionParam2whaleᚋpkgᚋmodelsᚐUpdateMotionParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateRecentMatching_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 models.UpdateRecentMatchingParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUpdateRecentMatchingParam2whaleᚋpkgᚋmodelsᚐUpdateRecentMatchingParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateUserJoinTopic_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 models.UpdateUserJoinTopicParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUpdateUserJoinTopicParam2whaleᚋpkgᚋmodelsᚐUpdateUserJoinTopicParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_userUpdateMotion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["myMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("myMotionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["myMotionId"] = arg0
	var arg1 models.UserUpdateMotionParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUserUpdateMotionParam2whaleᚋpkgᚋmodelsᚐUserUpdateMotionParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query__entities_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []map[string]interface{}
	if tmp, ok := rawArgs["representations"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("representations"))
		arg0, err = ec.unmarshalN_Any2ᚕmapᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["representations"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_activeMotions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_chatGroupByResultId_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["resultId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resultId"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resultId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_citiesTopicsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.CitiesTopicsFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOCitiesTopicsFilter2ᚖwhaleᚋpkgᚋmodelsᚐCitiesTopicsFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_citiesTopics_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.CitiesTopicsFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOCitiesTopicsFilter2ᚖwhaleᚋpkgᚋmodelsᚐCitiesTopicsFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2ᚖgithubᚗcomᚋletjoyᚑclubᚋmidaᚑtoolᚋgraphqlutilᚐGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_cityTopics_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["cityId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["cityId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_discoverCategoryMotions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 *models.DiscoverTopicCategoryMotionFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg1, err = ec.unmarshalODiscoverTopicCategoryMotionFilter2ᚖwhaleᚋpkgᚋmodelsᚐDiscoverTopicCategoryMotionFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["topicCategoryId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicCategoryId"))
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["topicCategoryId"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["nextToken"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nextToken"))
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["nextToken"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_discoverLatestCategoryMotions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.DiscoverTopicCategoryMotionFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalNDiscoverTopicCategoryMotionFilter2whaleᚋpkgᚋmodelsᚐDiscoverTopicCategoryMotionFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["topicCategoryId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicCategoryId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["topicCategoryId"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["lastId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastId"))
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["lastId"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_getDiscoverMotion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["motionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("motionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["motionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getMotionOffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["motionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("motionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["motionId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["toMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toMotionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["toMotionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_hotTopicsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.HotTopicsFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOHotTopicsFilter2ᚖwhaleᚋpkgᚋmodelsᚐHotTopicsFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_hotTopicsInArea_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["cityId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["cityId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_hotTopics_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.HotTopicsFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOHotTopicsFilter2ᚖwhaleᚋpkgᚋmodelsᚐHotTopicsFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2ᚖgithubᚗcomᚋletjoyᚑclubᚋmidaᚑtoolᚋgraphqlutilᚐGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_inMotionOffers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["motionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("motionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["motionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_invitation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_invitationsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_invitations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2ᚖgithubᚗcomᚋletjoyᚑclubᚋmidaᚑtoolᚋgraphqlutilᚐGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_likedMotionsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_likedMotions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2ᚖgithubᚗcomᚋletjoyᚑclubᚋmidaᚑtoolᚋgraphqlutilᚐGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_matchingDurationConstraints_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_matchingInvitationsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.MatchingInvitationFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOMatchingInvitationFilter2ᚖwhaleᚋpkgᚋmodelsᚐMatchingInvitationFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_matchingInvitations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.MatchingInvitationFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOMatchingInvitationFilter2ᚖwhaleᚋpkgᚋmodelsᚐMatchingInvitationFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2ᚖgithubᚗcomᚋletjoyᚑclubᚋmidaᚑtoolᚋgraphqlutilᚐGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_matchingResultByChatGroupId_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["chatGroupId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chatGroupId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["chatGroupId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_matchingResult_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_matchingResultsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.MatchingResultFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOMatchingResultFilter2ᚖwhaleᚋpkgᚋmodelsᚐMatchingResultFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_matchingResults_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.MatchingResultFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOMatchingResultFilter2ᚖwhaleᚋpkgᚋmodelsᚐMatchingResultFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2ᚖgithubᚗcomᚋletjoyᚑclubᚋmidaᚑtoolᚋgraphqlutilᚐGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_matching_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_matchingsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.MatchingFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOMatchingFilter2ᚖwhaleᚋpkgᚋmodelsᚐMatchingFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_matchings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.MatchingFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOMatchingFilter2ᚖwhaleᚋpkgᚋmodelsᚐMatchingFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2ᚖgithubᚗcomᚋletjoyᚑclubᚋmidaᚑtoolᚋgraphqlutilᚐGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_motion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_motionsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.MotionFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOMotionFilter2ᚖwhaleᚋpkgᚋmodelsᚐMotionFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_motions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.MotionFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOMotionFilter2ᚖwhaleᚋpkgᚋmodelsᚐMotionFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2ᚖgithubᚗcomᚋletjoyᚑclubᚋmidaᚑtoolᚋgraphqlutilᚐGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_outMotionOffers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["motionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("motionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["motionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_previewMatchingsOfTopic_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["cityId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["cityId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["topicId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["topicId"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_recentMatching_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_recentMatchingsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.RecentMatchingFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalORecentMatchingFilter2ᚖwhaleᚋpkgᚋmodelsᚐRecentMatchingFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_recentMatchings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.RecentMatchingFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalORecentMatchingFilter2ᚖwhaleᚋpkgᚋmodelsᚐRecentMatchingFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2ᚖgithubᚗcomᚋletjoyᚑclubᚋmidaᚑtoolᚋgraphqlutilᚐGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_unconfirmedInvitationCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_unconfirmedInvitations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_unconfirmedUserMatchings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userDurationConstraint_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userJoinTopic_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userJoinTopicsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.UserJoinTopicFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOUserJoinTopicFilter2ᚖwhaleᚋpkgᚋmodelsᚐUserJoinTopicFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userJoinTopics_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.UserJoinTopicFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOUserJoinTopicFilter2ᚖwhaleᚋpkgᚋmodelsᚐUserJoinTopicFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2ᚖgithubᚗcomᚋletjoyᚑclubᚋmidaᚑtoolᚋgraphqlutilᚐGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_userMatchingCalendar_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 models.UserMatchingCalenderParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUserMatchingCalenderParam2whaleᚋpkgᚋmodelsᚐUserMatchingCalenderParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_userMatchingQuota_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userMatchingsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 *models.UserMatchingFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg1, err = ec.unmarshalOUserMatchingFilter2ᚖwhaleᚋpkgᚋmodelsᚐUserMatchingFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_userMatchingsInTheDay_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 models.UserMatchingInTheDayParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUserMatchingInTheDayParam2whaleᚋpkgᚋmodelsᚐUserMatchingInTheDayParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_userMatchings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 *models.UserMatchingFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg1, err = ec.unmarshalOUserMatchingFilter2ᚖwhaleᚋpkgᚋmodelsᚐUserMatchingFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg1
	var arg2 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg2, err = ec.unmarshalOGraphQLPaginator2ᚖgithubᚗcomᚋletjoyᚑclubᚋmidaᚑtoolᚋgraphqlutilᚐGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_userMotionsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userMotions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2ᚖgithubᚗcomᚋletjoyᚑclubᚋmidaᚑtoolᚋgraphqlutilᚐGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Topic_fuzzyMatchingNum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["cityId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["cityId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Topic_matchingNum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["cityId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["cityId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Topic_recentUsers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["cityId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["cityId"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Area_code(ctx context.Context, field graphql.CollectedField, obj *models.Area) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Area_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNAreaCode2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Area_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Area",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AreaCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AvailableMotionOffer_motion(ctx context.Context, field graphql.CollectedField, obj *models.AvailableMotionOffer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AvailableMotionOffer_motion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Motion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Motion)
	fc.Result = res
	return ec.marshalOMotion2ᚖwhaleᚋpkgᚋmodelsᚐMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AvailableMotionOffer_motion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AvailableMotionOffer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Motion_id(ctx, field)
			case "userId":
				return ec.fieldContext_Motion_userId(ctx, field)
			case "cityId":
				return ec.fieldContext_Motion_cityId(ctx, field)
			case "remark":
				return ec.fieldContext_Motion_remark(ctx, field)
			case "active":
				return ec.fieldContext_Motion_active(ctx, field)
			case "inOfferNum":
				return ec.fieldContext_Motion_inOfferNum(ctx, field)
			case "outOfferNum":
				return ec.fieldContext_Motion_outOfferNum(ctx, field)
			case "pendingInNum":
				return ec.fieldContext_Motion_pendingInNum(ctx, field)
			case "pendingOutNum":
				return ec.fieldContext_Motion_pendingOutNum(ctx, field)
			case "activeNum":
				return ec.fieldContext_Motion_activeNum(ctx, field)
			case "discoverable":
				return ec.fieldContext_Motion_discoverable(ctx, field)
			case "relatedMatchingId":
				return ec.fieldContext_Motion_relatedMatchingId(ctx, field)
			case "properties":
				return ec.fieldContext_Motion_properties(ctx, field)
			case "dayRange":
				return ec.fieldContext_Motion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Motion_preferredPeriods(ctx, field)
			case "gender":
				return ec.fieldContext_Motion_gender(ctx, field)
			case "createdAt":
				return ec.fieldContext_Motion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_Motion_liked(ctx, field)
			case "viewCount":
				return ec.fieldContext_Motion_viewCount(ctx, field)
			case "likeCount":
				return ec.fieldContext_Motion_likeCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_Motion_thumbsUpCount(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_Motion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_Motion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_Motion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_Motion_user(ctx, field)
			case "city":
				return ec.fieldContext_Motion_city(ctx, field)
			case "areas":
				return ec.fieldContext_Motion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Motion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AvailableMotionOffer_nextQuotaTime(ctx context.Context, field graphql.CollectedField, obj *models.AvailableMotionOffer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AvailableMotionOffer_nextQuotaTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextQuotaTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AvailableMotionOffer_nextQuotaTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AvailableMotionOffer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CalendarEvent_topicId(ctx context.Context, field graphql.CollectedField, obj *models.CalendarEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CalendarEvent_topicId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CalendarEvent_topicId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CalendarEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CalendarEvent_matchedAt(ctx context.Context, field graphql.CollectedField, obj *models.CalendarEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CalendarEvent_matchedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CalendarEvent_matchedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CalendarEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CalendarEvent_finishedAt(ctx context.Context, field graphql.CollectedField, obj *models.CalendarEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CalendarEvent_finishedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FinishedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CalendarEvent_finishedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CalendarEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CalendarEvent_chatGroupCreatedAt(ctx context.Context, field graphql.CollectedField, obj *models.CalendarEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CalendarEvent_chatGroupCreatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChatGroupCreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CalendarEvent_chatGroupCreatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CalendarEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatGroup_id(ctx context.Context, field graphql.CollectedField, obj *models.ChatGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatGroup_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatGroup_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CityToTopicMatching_cityId(ctx context.Context, field graphql.CollectedField, obj *models.CityToTopicMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CityToTopicMatching_cityId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CityToTopicMatching_cityId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CityToTopicMatching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CityToTopicMatching_topics(ctx context.Context, field graphql.CollectedField, obj *models.CityToTopicMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CityToTopicMatching_topics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Topics, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.TopicToMatching)
	fc.Result = res
	return ec.marshalNTopicToMatching2ᚕᚖwhaleᚋpkgᚋmodelsᚐTopicToMatchingᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CityToTopicMatching_topics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CityToTopicMatching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "topicId":
				return ec.fieldContext_TopicToMatching_topicId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_TopicToMatching_matchingIds(ctx, field)
			case "topic":
				return ec.fieldContext_TopicToMatching_topic(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TopicToMatching", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CityToTopicMatching_city(ctx context.Context, field graphql.CollectedField, obj *models.CityToTopicMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CityToTopicMatching_city(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CityToTopicMatching().City(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Area)
	fc.Result = res
	return ec.marshalNArea2ᚖwhaleᚋpkgᚋmodelsᚐArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CityToTopicMatching_city(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CityToTopicMatching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CityTopics_cityId(ctx context.Context, field graphql.CollectedField, obj *models.CityTopics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CityTopics_cityId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CityTopics_cityId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CityTopics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CityTopics_topicIds(ctx context.Context, field graphql.CollectedField, obj *models.CityTopics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CityTopics_topicIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CityTopics_topicIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CityTopics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CityTopics_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.CityTopics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CityTopics_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CityTopics_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CityTopics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CityTopics_topics(ctx context.Context, field graphql.CollectedField, obj *models.CityTopics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CityTopics_topics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CityTopics().Topics(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Topic)
	fc.Result = res
	return ec.marshalNTopic2ᚕᚖwhaleᚋpkgᚋmodelsᚐTopicᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CityTopics_topics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CityTopics",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Topic_id(ctx, field)
			case "recentUsers":
				return ec.fieldContext_Topic_recentUsers(ctx, field)
			case "matchingNum":
				return ec.fieldContext_Topic_matchingNum(ctx, field)
			case "fuzzyMatchingNum":
				return ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Topic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CityTopics_city(ctx context.Context, field graphql.CollectedField, obj *models.CityTopics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CityTopics_city(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CityTopics().City(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Area)
	fc.Result = res
	return ec.marshalNArea2ᚖwhaleᚋpkgᚋmodelsᚐArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CityTopics_city(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CityTopics",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateMotionOfferResult_chatGroupId(ctx context.Context, field graphql.CollectedField, obj *models.CreateMotionOfferResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateMotionOfferResult_chatGroupId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChatGroupID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateMotionOfferResult_chatGroupId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateMotionOfferResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_id(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_userId(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_topicId(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_topicId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_topicId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_properties(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_properties(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Properties, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.MotionProperty)
	fc.Result = res
	return ec.marshalNMotionProperty2ᚕwhaleᚋpkgᚋmodelsᚐMotionPropertyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_properties(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MotionProperty_id(ctx, field)
			case "values":
				return ec.fieldContext_MotionProperty_values(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MotionProperty", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_cityId(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_cityId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_cityId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_areaIds(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_areaIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AreaIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_areaIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_gender(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_gender(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DiscoverMotion().Gender(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Gender)
	fc.Result = res
	return ec.marshalNGender2whaleᚋpkgᚋmodelsᚐGender(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_gender(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Gender does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_dayRange(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_dayRange(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DayRange, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_dayRange(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_preferredPeriods(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_preferredPeriods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DiscoverMotion().PreferredPeriods(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.DatePeriod)
	fc.Result = res
	return ec.marshalNDatePeriod2ᚕwhaleᚋpkgᚋmodelsᚐDatePeriodᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_preferredPeriods(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DatePeriod does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_remark(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_remark(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Remark, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_remark(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_likeCount(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_likeCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LikeCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_likeCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_viewCount(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_viewCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ViewCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_viewCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_thumbsUpCount(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_thumbsUpCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ThumbsUpCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_thumbsUpCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_liked(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_liked(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DiscoverMotion().Liked(rctx, obj, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_liked(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DiscoverMotion_liked_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_submitted(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_submitted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DiscoverMotion().Submitted(rctx, obj, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_submitted(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DiscoverMotion_submitted_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_thumbsUp(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_thumbsUp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DiscoverMotion().ThumbsUp(rctx, obj, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_thumbsUp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DiscoverMotion_thumbsUp_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_topic(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_topic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DiscoverMotion().Topic(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Topic)
	fc.Result = res
	return ec.marshalNTopic2ᚖwhaleᚋpkgᚋmodelsᚐTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_topic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Topic_id(ctx, field)
			case "recentUsers":
				return ec.fieldContext_Topic_recentUsers(ctx, field)
			case "matchingNum":
				return ec.fieldContext_Topic_matchingNum(ctx, field)
			case "fuzzyMatchingNum":
				return ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Topic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_topicOptionConfig(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_topicOptionConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DiscoverMotion().TopicOptionConfig(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.TopicOptionConfig)
	fc.Result = res
	return ec.marshalOTopicOptionConfig2ᚖwhaleᚋpkgᚋmodelsᚐTopicOptionConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_topicOptionConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "topicId":
				return ec.fieldContext_TopicOptionConfig_topicId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TopicOptionConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_user(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DiscoverMotion().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2ᚖwhaleᚋpkgᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "matchingQuota":
				return ec.fieldContext_User_matchingQuota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_city(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_city(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DiscoverMotion().City(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Area)
	fc.Result = res
	return ec.marshalNArea2ᚖwhaleᚋpkgᚋmodelsᚐArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_city(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_areas(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_areas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DiscoverMotion().Areas(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Area)
	fc.Result = res
	return ec.marshalNArea2ᚕᚖwhaleᚋpkgᚋmodelsᚐAreaᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_areas(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotionResult_motions(ctx context.Context, field graphql.CollectedField, obj *models.DiscoverMotionResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotionResult_motions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Motions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Motion)
	fc.Result = res
	return ec.marshalNDiscoverMotion2ᚕᚖwhaleᚋpkgᚋmodelsᚐMotionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotionResult_motions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotionResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscoverMotion_id(ctx, field)
			case "userId":
				return ec.fieldContext_DiscoverMotion_userId(ctx, field)
			case "topicId":
				return ec.fieldContext_DiscoverMotion_topicId(ctx, field)
			case "properties":
				return ec.fieldContext_DiscoverMotion_properties(ctx, field)
			case "cityId":
				return ec.fieldContext_DiscoverMotion_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_DiscoverMotion_areaIds(ctx, field)
			case "gender":
				return ec.fieldContext_DiscoverMotion_gender(ctx, field)
			case "dayRange":
				return ec.fieldContext_DiscoverMotion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_DiscoverMotion_preferredPeriods(ctx, field)
			case "remark":
				return ec.fieldContext_DiscoverMotion_remark(ctx, field)
			case "likeCount":
				return ec.fieldContext_DiscoverMotion_likeCount(ctx, field)
			case "viewCount":
				return ec.fieldContext_DiscoverMotion_viewCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_DiscoverMotion_thumbsUpCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_DiscoverMotion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_DiscoverMotion_liked(ctx, field)
			case "submitted":
				return ec.fieldContext_DiscoverMotion_submitted(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_DiscoverMotion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_DiscoverMotion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_DiscoverMotion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_DiscoverMotion_user(ctx, field)
			case "city":
				return ec.fieldContext_DiscoverMotion_city(ctx, field)
			case "areas":
				return ec.fieldContext_DiscoverMotion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscoverMotion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotionResult_nextToken(ctx context.Context, field graphql.CollectedField, obj *models.DiscoverMotionResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotionResult_nextToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotionResult_nextToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotionResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DurationConstraint_userId(ctx context.Context, field graphql.CollectedField, obj *models.DurationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DurationConstraint_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DurationConstraint_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DurationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DurationConstraint_startDate(ctx context.Context, field graphql.CollectedField, obj *models.DurationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DurationConstraint_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DurationConstraint_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DurationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DurationConstraint_stopDate(ctx context.Context, field graphql.CollectedField, obj *models.DurationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DurationConstraint_stopDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DurationConstraint_stopDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DurationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DurationConstraint_totalMotionQuota(ctx context.Context, field graphql.CollectedField, obj *models.DurationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DurationConstraint_totalMotionQuota(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalMotionQuota, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DurationConstraint_totalMotionQuota(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DurationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DurationConstraint_remainMotionQuota(ctx context.Context, field graphql.CollectedField, obj *models.DurationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DurationConstraint_remainMotionQuota(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RemainMotionQuota, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DurationConstraint_remainMotionQuota(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DurationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DurationConstraint_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.DurationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DurationConstraint_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DurationConstraint_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DurationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entity_findLevelRightsByLevel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_findLevelRightsByLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Entity().FindLevelRightsByLevel(rctx, fc.Args["level"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.LevelRights)
	fc.Result = res
	return ec.marshalNLevelRights2ᚖwhaleᚋpkgᚋmodelsᚐLevelRights(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_findLevelRightsByLevel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "level":
				return ec.fieldContext_LevelRights_level(ctx, field)
			case "matchingQuota":
				return ec.fieldContext_LevelRights_matchingQuota(ctx, field)
			case "matchingDurationConstraint":
				return ec.fieldContext_LevelRights_matchingDurationConstraint(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LevelRights", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Entity_findLevelRightsByLevel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Entity_findMatchingByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_findMatchingByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Entity().FindMatchingByID(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Matching)
	fc.Result = res
	return ec.marshalNMatching2ᚖwhaleᚋpkgᚋmodelsᚐMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_findMatchingByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Matching_id(ctx, field)
			case "topicId":
				return ec.fieldContext_Matching_topicId(ctx, field)
			case "userId":
				return ec.fieldContext_Matching_userId(ctx, field)
			case "areaIds":
				return ec.fieldContext_Matching_areaIds(ctx, field)
			case "cityId":
				return ec.fieldContext_Matching_cityId(ctx, field)
			case "gender":
				return ec.fieldContext_Matching_gender(ctx, field)
			case "state":
				return ec.fieldContext_Matching_state(ctx, field)
			case "rejectedUserIds":
				return ec.fieldContext_Matching_rejectedUserIds(ctx, field)
			case "inChatGroup":
				return ec.fieldContext_Matching_inChatGroup(ctx, field)
			case "remark":
				return ec.fieldContext_Matching_remark(ctx, field)
			case "dayRange":
				return ec.fieldContext_Matching_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Matching_preferredPeriods(ctx, field)
			case "properties":
				return ec.fieldContext_Matching_properties(ctx, field)
			case "startMatchingAt":
				return ec.fieldContext_Matching_startMatchingAt(ctx, field)
			case "deadline":
				return ec.fieldContext_Matching_deadline(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Matching_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Matching_createdAt(ctx, field)
			case "matchingResult":
				return ec.fieldContext_Matching_matchingResult(ctx, field)
			case "reviewed":
				return ec.fieldContext_Matching_reviewed(ctx, field)
			case "user":
				return ec.fieldContext_Matching_user(ctx, field)
			case "topic":
				return ec.fieldContext_Matching_topic(ctx, field)
			case "areas":
				return ec.fieldContext_Matching_areas(ctx, field)
			case "city":
				return ec.fieldContext_Matching_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Matching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Entity_findMatchingByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Entity_findMatchingQuotaByUserID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_findMatchingQuotaByUserID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Entity().FindMatchingQuotaByUserID(rctx, fc.Args["userID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.MatchingQuota)
	fc.Result = res
	return ec.marshalNMatchingQuota2ᚖwhaleᚋpkgᚋmodelsᚐMatchingQuota(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_findMatchingQuotaByUserID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userId":
				return ec.fieldContext_MatchingQuota_userId(ctx, field)
			case "remain":
				return ec.fieldContext_MatchingQuota_remain(ctx, field)
			case "total":
				return ec.fieldContext_MatchingQuota_total(ctx, field)
			case "matchingNum":
				return ec.fieldContext_MatchingQuota_matchingNum(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingQuota_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingQuota_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingQuota", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Entity_findMatchingQuotaByUserID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Entity_findTopicByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_findTopicByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Entity().FindTopicByID(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Topic)
	fc.Result = res
	return ec.marshalNTopic2ᚖwhaleᚋpkgᚋmodelsᚐTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_findTopicByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Topic_id(ctx, field)
			case "recentUsers":
				return ec.fieldContext_Topic_recentUsers(ctx, field)
			case "matchingNum":
				return ec.fieldContext_Topic_matchingNum(ctx, field)
			case "fuzzyMatchingNum":
				return ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Topic", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Entity_findTopicByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Entity_findUserByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_findUserByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Entity().FindUserByID(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2ᚖwhaleᚋpkgᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_findUserByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "matchingQuota":
				return ec.fieldContext_User_matchingQuota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Entity_findUserByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _EvaluatorResult_score(ctx context.Context, field graphql.CollectedField, obj *matcher.EvaluatorResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EvaluatorResult_score(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Score, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EvaluatorResult_score(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EvaluatorResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EvaluatorResult_timeScore(ctx context.Context, field graphql.CollectedField, obj *matcher.EvaluatorResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EvaluatorResult_timeScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EvaluatorResult_timeScore(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EvaluatorResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EvaluatorResult_properties(ctx context.Context, field graphql.CollectedField, obj *matcher.EvaluatorResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EvaluatorResult_properties(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Properties, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2ᚕintᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EvaluatorResult_properties(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EvaluatorResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EvaluatorResult_failedReason(ctx context.Context, field graphql.CollectedField, obj *matcher.EvaluatorResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EvaluatorResult_failedReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EvaluatorResult().FailedReason(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EvaluatorResult_failedReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EvaluatorResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HotTopicsInArea_cityId(ctx context.Context, field graphql.CollectedField, obj *models.HotTopicsInArea) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HotTopicsInArea_cityId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HotTopicsInArea_cityId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HotTopicsInArea",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HotTopicsInArea_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.HotTopicsInArea) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HotTopicsInArea_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HotTopicsInArea_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HotTopicsInArea",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HotTopicsInArea_topicMetrics(ctx context.Context, field graphql.CollectedField, obj *models.HotTopicsInArea) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HotTopicsInArea_topicMetrics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicMetrics, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.TopicMetrics)
	fc.Result = res
	return ec.marshalNTopicMetrics2ᚕwhaleᚋpkgᚋmodelsᚐTopicMetricsᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HotTopicsInArea_topicMetrics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HotTopicsInArea",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TopicMetrics_id(ctx, field)
			case "matched":
				return ec.fieldContext_TopicMetrics_matched(ctx, field)
			case "matching":
				return ec.fieldContext_TopicMetrics_matching(ctx, field)
			case "heat":
				return ec.fieldContext_TopicMetrics_heat(ctx, field)
			case "topic":
				return ec.fieldContext_TopicMetrics_topic(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TopicMetrics", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HotTopicsInArea_city(ctx context.Context, field graphql.CollectedField, obj *models.HotTopicsInArea) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HotTopicsInArea_city(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.HotTopicsInArea().City(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Area)
	fc.Result = res
	return ec.marshalNArea2ᚖwhaleᚋpkgᚋmodelsᚐArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HotTopicsInArea_city(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HotTopicsInArea",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LevelRights_level(ctx context.Context, field graphql.CollectedField, obj *models.LevelRights) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LevelRights_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LevelRights_level(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LevelRights",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LevelRights_matchingQuota(ctx context.Context, field graphql.CollectedField, obj *models.LevelRights) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LevelRights_matchingQuota(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchingQuota, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LevelRights_matchingQuota(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LevelRights",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LevelRights_matchingDurationConstraint(ctx context.Context, field graphql.CollectedField, obj *models.LevelRights) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LevelRights_matchingDurationConstraint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchingDurationConstraint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LevelRights_matchingDurationConstraint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LevelRights",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_id(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_topicId(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_topicId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_topicId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_userId(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_areaIds(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_areaIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AreaIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_areaIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_cityId(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_cityId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_cityId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_gender(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_gender(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Matching().Gender(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Gender)
	fc.Result = res
	return ec.marshalNGender2whaleᚋpkgᚋmodelsᚐGender(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_gender(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Gender does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_state(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Matching().State(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.MatchingState)
	fc.Result = res
	return ec.marshalNMatchingState2whaleᚋpkgᚋmodelsᚐMatchingState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MatchingState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_rejectedUserIds(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_rejectedUserIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.RejectedUserIDs, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_rejectedUserIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_inChatGroup(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_inChatGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InChatGroup, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_inChatGroup(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_remark(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_remark(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Remark, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_remark(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_dayRange(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_dayRange(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DayRange, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_dayRange(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_preferredPeriods(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_preferredPeriods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Matching().PreferredPeriods(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.DatePeriod)
	fc.Result = res
	return ec.marshalNDatePeriod2ᚕwhaleᚋpkgᚋmodelsᚐDatePeriodᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_preferredPeriods(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DatePeriod does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_properties(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_properties(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Properties, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.MatchingProperty)
	fc.Result = res
	return ec.marshalNMatchingProperty2ᚕwhaleᚋpkgᚋmodelsᚐMatchingPropertyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_properties(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingProperty_id(ctx, field)
			case "values":
				return ec.fieldContext_MatchingProperty_values(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingProperty", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_startMatchingAt(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_startMatchingAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.StartMatchingAt, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_startMatchingAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_deadline(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_deadline(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Deadline, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_deadline(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_matchingResult(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_matchingResult(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Matching().MatchingResult(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MatchingResult)
	fc.Result = res
	return ec.marshalOMatchingResult2ᚖwhaleᚋpkgᚋmodelsᚐMatchingResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_matchingResult(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingResult_id(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingResult_matchingIds(ctx, field)
			case "motionIds":
				return ec.fieldContext_MatchingResult_motionIds(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingResult_topicId(ctx, field)
			case "userIds":
				return ec.fieldContext_MatchingResult_userIds(ctx, field)
			case "confirmStates":
				return ec.fieldContext_MatchingResult_confirmStates(ctx, field)
			case "userConfirmStates":
				return ec.fieldContext_MatchingResult_userConfirmStates(ctx, field)
			case "chatGroupId":
				return ec.fieldContext_MatchingResult_chatGroupId(ctx, field)
			case "chatGroupState":
				return ec.fieldContext_MatchingResult_chatGroupState(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingResult_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingResult_createdAt(ctx, field)
			case "matchingScore":
				return ec.fieldContext_MatchingResult_matchingScore(ctx, field)
			case "closed":
				return ec.fieldContext_MatchingResult_closed(ctx, field)
			case "finishedAt":
				return ec.fieldContext_MatchingResult_finishedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_MatchingResult_createdBy(ctx, field)
			case "users":
				return ec.fieldContext_MatchingResult_users(ctx, field)
			case "discoverMotion":
				return ec.fieldContext_MatchingResult_discoverMotion(ctx, field)
			case "matchingPreviews":
				return ec.fieldContext_MatchingResult_matchingPreviews(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingResult_topic(ctx, field)
			case "chatGroup":
				return ec.fieldContext_MatchingResult_chatGroup(ctx, field)
			case "matchingDegree":
				return ec.fieldContext_MatchingResult_matchingDegree(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_reviewed(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_reviewed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Matching().Reviewed(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_reviewed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_user(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Matching().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2ᚖwhaleᚋpkgᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "matchingQuota":
				return ec.fieldContext_User_matchingQuota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_topic(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_topic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Matching().Topic(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Topic)
	fc.Result = res
	return ec.marshalNTopic2ᚖwhaleᚋpkgᚋmodelsᚐTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_topic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Topic_id(ctx, field)
			case "recentUsers":
				return ec.fieldContext_Topic_recentUsers(ctx, field)
			case "matchingNum":
				return ec.fieldContext_Topic_matchingNum(ctx, field)
			case "fuzzyMatchingNum":
				return ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Topic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_areas(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_areas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Matching().Areas(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Area)
	fc.Result = res
	return ec.marshalNArea2ᚕᚖwhaleᚋpkgᚋmodelsᚐAreaᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_areas(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_city(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_city(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Matching().City(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Area)
	fc.Result = res
	return ec.marshalNArea2ᚖwhaleᚋpkgᚋmodelsᚐArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_city(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingDurationConstraint_startDate(ctx context.Context, field graphql.CollectedField, obj *models.MatchingDurationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingDurationConstraint_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingDurationConstraint_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingDurationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingDurationConstraint_stopDate(ctx context.Context, field graphql.CollectedField, obj *models.MatchingDurationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingDurationConstraint_stopDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingDurationConstraint_stopDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingDurationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingDurationConstraint_total(ctx context.Context, field graphql.CollectedField, obj *models.MatchingDurationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingDurationConstraint_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingDurationConstraint_total(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingDurationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingDurationConstraint_remain(ctx context.Context, field graphql.CollectedField, obj *models.MatchingDurationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingDurationConstraint_remain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Remain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingDurationConstraint_remain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingDurationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingDurationConstraint_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.MatchingDurationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingDurationConstraint_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingDurationConstraint_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingDurationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_id(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_userId(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_inviteeId(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_inviteeId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InviteeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_inviteeId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_topicId(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_topicId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_topicId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_remark(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_remark(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Remark, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_remark(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_cityId(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_cityId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_cityId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_areaIds(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_areaIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AreaIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_areaIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_matchingResultId(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_matchingResultId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MatchingResultId, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_matchingResultId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_matchingIds(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_matchingIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchingIds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_matchingIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_confirmState(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_confirmState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingInvitation().ConfirmState(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.InvitationConfirmState)
	fc.Result = res
	return ec.marshalNInvitationConfirmState2whaleᚋpkgᚋmodelsᚐInvitationConfirmState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_confirmState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type InvitationConfirmState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_confirmedAt(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_confirmedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ConfirmedAt, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_confirmedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_invitee(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_invitee(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingInvitation().Invitee(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2ᚖwhaleᚋpkgᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_invitee(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "matchingQuota":
				return ec.fieldContext_User_matchingQuota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_topic(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_topic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingInvitation().Topic(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Topic)
	fc.Result = res
	return ec.marshalNTopic2ᚖwhaleᚋpkgᚋmodelsᚐTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_topic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Topic_id(ctx, field)
			case "recentUsers":
				return ec.fieldContext_Topic_recentUsers(ctx, field)
			case "matchingNum":
				return ec.fieldContext_Topic_matchingNum(ctx, field)
			case "fuzzyMatchingNum":
				return ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Topic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_areas(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_areas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingInvitation().Areas(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Area)
	fc.Result = res
	return ec.marshalNArea2ᚕᚖwhaleᚋpkgᚋmodelsᚐAreaᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_areas(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_city(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_city(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingInvitation().City(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Area)
	fc.Result = res
	return ec.marshalNArea2ᚖwhaleᚋpkgᚋmodelsᚐArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_city(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_user(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingInvitation().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2ᚖwhaleᚋpkgᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "matchingQuota":
				return ec.fieldContext_User_matchingQuota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_matchingResult(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_matchingResult(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingInvitation().MatchingResult(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MatchingResult)
	fc.Result = res
	return ec.marshalOMatchingResult2ᚖwhaleᚋpkgᚋmodelsᚐMatchingResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_matchingResult(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingResult_id(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingResult_matchingIds(ctx, field)
			case "motionIds":
				return ec.fieldContext_MatchingResult_motionIds(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingResult_topicId(ctx, field)
			case "userIds":
				return ec.fieldContext_MatchingResult_userIds(ctx, field)
			case "confirmStates":
				return ec.fieldContext_MatchingResult_confirmStates(ctx, field)
			case "userConfirmStates":
				return ec.fieldContext_MatchingResult_userConfirmStates(ctx, field)
			case "chatGroupId":
				return ec.fieldContext_MatchingResult_chatGroupId(ctx, field)
			case "chatGroupState":
				return ec.fieldContext_MatchingResult_chatGroupState(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingResult_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingResult_createdAt(ctx, field)
			case "matchingScore":
				return ec.fieldContext_MatchingResult_matchingScore(ctx, field)
			case "closed":
				return ec.fieldContext_MatchingResult_closed(ctx, field)
			case "finishedAt":
				return ec.fieldContext_MatchingResult_finishedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_MatchingResult_createdBy(ctx, field)
			case "users":
				return ec.fieldContext_MatchingResult_users(ctx, field)
			case "discoverMotion":
				return ec.fieldContext_MatchingResult_discoverMotion(ctx, field)
			case "matchingPreviews":
				return ec.fieldContext_MatchingResult_matchingPreviews(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingResult_topic(ctx, field)
			case "chatGroup":
				return ec.fieldContext_MatchingResult_chatGroup(ctx, field)
			case "matchingDegree":
				return ec.fieldContext_MatchingResult_matchingDegree(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingOfTopic_userId(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingOfTopic_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingOfTopic_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingOfTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingOfTopic_gender(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingOfTopic_gender(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingOfTopic().Gender(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Gender)
	fc.Result = res
	return ec.marshalNGender2whaleᚋpkgᚋmodelsᚐGender(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingOfTopic_gender(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingOfTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Gender does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingOfTopic_remark(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingOfTopic_remark(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Remark, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingOfTopic_remark(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingOfTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingOfTopic_areaIds(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingOfTopic_areaIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AreaIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingOfTopic_areaIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingOfTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingOfTopic_cityId(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingOfTopic_cityId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingOfTopic_cityId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingOfTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingOfTopic_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingOfTopic_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingOfTopic_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingOfTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingOfTopic_user(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingOfTopic_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingOfTopic().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2ᚖwhaleᚋpkgᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingOfTopic_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingOfTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "matchingQuota":
				return ec.fieldContext_User_matchingQuota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingOfTopic_city(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingOfTopic_city(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingOfTopic().City(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Area)
	fc.Result = res
	return ec.marshalNArea2ᚖwhaleᚋpkgᚋmodelsᚐArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingOfTopic_city(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingOfTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingOfTopic_areas(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingOfTopic_areas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingOfTopic().Areas(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Area)
	fc.Result = res
	return ec.marshalNArea2ᚕᚖwhaleᚋpkgᚋmodelsᚐAreaᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingOfTopic_areas(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingOfTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingPreview_userId(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingPreview_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingPreview_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingPreview",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingPreview_remark(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingPreview_remark(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Remark, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingPreview_remark(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingPreview",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingPreview_properties(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingPreview_properties(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Properties, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.MatchingProperty)
	fc.Result = res
	return ec.marshalNMatchingProperty2ᚕwhaleᚋpkgᚋmodelsᚐMatchingPropertyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingPreview_properties(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingPreview",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingProperty_id(ctx, field)
			case "values":
				return ec.fieldContext_MatchingProperty_values(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingProperty", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingPreview_dayRange(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingPreview_dayRange(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DayRange, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingPreview_dayRange(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingPreview",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingPreview_preferredPeriods(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingPreview_preferredPeriods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingPreview().PreferredPeriods(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.DatePeriod)
	fc.Result = res
	return ec.marshalNDatePeriod2ᚕwhaleᚋpkgᚋmodelsᚐDatePeriodᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingPreview_preferredPeriods(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingPreview",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DatePeriod does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingPreview_topicOptionConfig(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingPreview_topicOptionConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingPreview().TopicOptionConfig(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.TopicOptionConfig)
	fc.Result = res
	return ec.marshalOTopicOptionConfig2ᚖwhaleᚋpkgᚋmodelsᚐTopicOptionConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingPreview_topicOptionConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingPreview",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "topicId":
				return ec.fieldContext_TopicOptionConfig_topicId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TopicOptionConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingPreview_user(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingPreview_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingPreview().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2ᚖwhaleᚋpkgᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingPreview_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingPreview",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "matchingQuota":
				return ec.fieldContext_User_matchingQuota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingProperty_id(ctx context.Context, field graphql.CollectedField, obj *models.MatchingProperty) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingProperty_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingProperty_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingProperty",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingProperty_values(ctx context.Context, field graphql.CollectedField, obj *models.MatchingProperty) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingProperty_values(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Values, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingProperty_values(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingProperty",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingQuota_userId(ctx context.Context, field graphql.CollectedField, obj *models.MatchingQuota) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingQuota_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingQuota_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingQuota",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingQuota_remain(ctx context.Context, field graphql.CollectedField, obj *models.MatchingQuota) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingQuota_remain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Remain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingQuota_remain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingQuota",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingQuota_total(ctx context.Context, field graphql.CollectedField, obj *models.MatchingQuota) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingQuota_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingQuota_total(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingQuota",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingQuota_matchingNum(ctx context.Context, field graphql.CollectedField, obj *models.MatchingQuota) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingQuota_matchingNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchingNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingQuota_matchingNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingQuota",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingQuota_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.MatchingQuota) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingQuota_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingQuota_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingQuota",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingQuota_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.MatchingQuota) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingQuota_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingQuota_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingQuota",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_id(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_matchingIds(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_matchingIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchingIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_matchingIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_motionIds(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_motionIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MotionIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_motionIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_topicId(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_topicId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_topicId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_userIds(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_userIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_userIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_confirmStates(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_confirmStates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingResult().ConfirmStates(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.MatchingResultConfirmState)
	fc.Result = res
	return ec.marshalNMatchingResultConfirmState2ᚕwhaleᚋpkgᚋmodelsᚐMatchingResultConfirmStateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_confirmStates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MatchingResultConfirmState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_userConfirmStates(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_userConfirmStates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingResult().UserConfirmStates(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.UserConfirmState)
	fc.Result = res
	return ec.marshalNUserConfirmState2ᚕᚖwhaleᚋpkgᚋmodelsᚐUserConfirmStateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_userConfirmStates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userId":
				return ec.fieldContext_UserConfirmState_userId(ctx, field)
			case "state":
				return ec.fieldContext_UserConfirmState_state(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserConfirmState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_chatGroupId(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_chatGroupId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChatGroupID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_chatGroupId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_chatGroupState(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_chatGroupState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingResult().ChatGroupState(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.ChatGroupState)
	fc.Result = res
	return ec.marshalNChatGroupState2whaleᚋpkgᚋmodelsᚐChatGroupState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_chatGroupState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChatGroupState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_matchingScore(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_matchingScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MatchingScore, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_matchingScore(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_closed(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_closed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Closed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_closed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_finishedAt(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_finishedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FinishedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_finishedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_createdBy(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.MatchingResult().CreatedBy(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(models.ResultCreatedBy); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be whale/pkg/models.ResultCreatedBy`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.ResultCreatedBy)
	fc.Result = res
	return ec.marshalNResultCreatedBy2whaleᚋpkgᚋmodelsᚐResultCreatedBy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ResultCreatedBy does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_users(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingResult().Users(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.User)
	fc.Result = res
	return ec.marshalNUser2ᚕᚖwhaleᚋpkgᚋmodelsᚐUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "matchingQuota":
				return ec.fieldContext_User_matchingQuota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_discoverMotion(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_discoverMotion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingResult().DiscoverMotion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Motion)
	fc.Result = res
	return ec.marshalNDiscoverMotion2ᚕᚖwhaleᚋpkgᚋmodelsᚐMotionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_discoverMotion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscoverMotion_id(ctx, field)
			case "userId":
				return ec.fieldContext_DiscoverMotion_userId(ctx, field)
			case "topicId":
				return ec.fieldContext_DiscoverMotion_topicId(ctx, field)
			case "properties":
				return ec.fieldContext_DiscoverMotion_properties(ctx, field)
			case "cityId":
				return ec.fieldContext_DiscoverMotion_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_DiscoverMotion_areaIds(ctx, field)
			case "gender":
				return ec.fieldContext_DiscoverMotion_gender(ctx, field)
			case "dayRange":
				return ec.fieldContext_DiscoverMotion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_DiscoverMotion_preferredPeriods(ctx, field)
			case "remark":
				return ec.fieldContext_DiscoverMotion_remark(ctx, field)
			case "likeCount":
				return ec.fieldContext_DiscoverMotion_likeCount(ctx, field)
			case "viewCount":
				return ec.fieldContext_DiscoverMotion_viewCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_DiscoverMotion_thumbsUpCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_DiscoverMotion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_DiscoverMotion_liked(ctx, field)
			case "submitted":
				return ec.fieldContext_DiscoverMotion_submitted(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_DiscoverMotion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_DiscoverMotion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_DiscoverMotion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_DiscoverMotion_user(ctx, field)
			case "city":
				return ec.fieldContext_DiscoverMotion_city(ctx, field)
			case "areas":
				return ec.fieldContext_DiscoverMotion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscoverMotion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_matchingPreviews(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_matchingPreviews(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingResult().MatchingPreviews(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Matching)
	fc.Result = res
	return ec.marshalNMatchingPreview2ᚕᚖwhaleᚋpkgᚋmodelsᚐMatchingᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_matchingPreviews(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userId":
				return ec.fieldContext_MatchingPreview_userId(ctx, field)
			case "remark":
				return ec.fieldContext_MatchingPreview_remark(ctx, field)
			case "properties":
				return ec.fieldContext_MatchingPreview_properties(ctx, field)
			case "dayRange":
				return ec.fieldContext_MatchingPreview_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_MatchingPreview_preferredPeriods(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_MatchingPreview_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_MatchingPreview_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingPreview", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_topic(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_topic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingResult().Topic(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Topic)
	fc.Result = res
	return ec.marshalNTopic2ᚖwhaleᚋpkgᚋmodelsᚐTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_topic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Topic_id(ctx, field)
			case "recentUsers":
				return ec.fieldContext_Topic_recentUsers(ctx, field)
			case "matchingNum":
				return ec.fieldContext_Topic_matchingNum(ctx, field)
			case "fuzzyMatchingNum":
				return ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Topic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_chatGroup(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_chatGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingResult().ChatGroup(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ChatGroup)
	fc.Result = res
	return ec.marshalOChatGroup2ᚖwhaleᚋpkgᚋmodelsᚐChatGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_chatGroup(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ChatGroup_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChatGroup", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_matchingDegree(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_matchingDegree(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingResult().MatchingDegree(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_matchingDegree(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResultConfirmAction_id(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResultConfirmAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResultConfirmAction_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResultConfirmAction_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResultConfirmAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResultConfirmAction_matchingResultId(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResultConfirmAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResultConfirmAction_matchingResultId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchingResultID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResultConfirmAction_matchingResultId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResultConfirmAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResultConfirmAction_userId(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResultConfirmAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResultConfirmAction_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResultConfirmAction_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResultConfirmAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResultConfirmAction_confirmed(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResultConfirmAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResultConfirmAction_confirmed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Confirmed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResultConfirmAction_confirmed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResultConfirmAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResultConfirmAction_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResultConfirmAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResultConfirmAction_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResultConfirmAction_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResultConfirmAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_id(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_userId(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_cityId(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_cityId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_cityId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_remark(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_remark(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Remark, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_remark(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_active(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_active(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Active, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_active(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_inOfferNum(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_inOfferNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InOfferNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_inOfferNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_outOfferNum(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_outOfferNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OutOfferNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_outOfferNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_pendingInNum(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_pendingInNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PendingInNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_pendingInNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_pendingOutNum(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_pendingOutNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PendingOutNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_pendingOutNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_activeNum(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_activeNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActiveNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_activeNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_discoverable(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_discoverable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Discoverable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_discoverable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_relatedMatchingId(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_relatedMatchingId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RelatedMatchingID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_relatedMatchingId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_properties(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_properties(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Properties, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.MotionProperty)
	fc.Result = res
	return ec.marshalNMotionProperty2ᚕwhaleᚋpkgᚋmodelsᚐMotionPropertyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_properties(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MotionProperty_id(ctx, field)
			case "values":
				return ec.fieldContext_MotionProperty_values(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MotionProperty", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_dayRange(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_dayRange(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DayRange, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_dayRange(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_preferredPeriods(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_preferredPeriods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Motion().PreferredPeriods(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.DatePeriod)
	fc.Result = res
	return ec.marshalNDatePeriod2ᚕwhaleᚋpkgᚋmodelsᚐDatePeriodᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_preferredPeriods(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DatePeriod does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_gender(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_gender(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Motion().Gender(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Gender)
	fc.Result = res
	return ec.marshalNGender2whaleᚋpkgᚋmodelsᚐGender(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_gender(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Gender does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_liked(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_liked(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Motion().Liked(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_liked(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_viewCount(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_viewCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ViewCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_viewCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_likeCount(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_likeCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LikeCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_likeCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_thumbsUpCount(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_thumbsUpCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ThumbsUpCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_thumbsUpCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_thumbsUp(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_thumbsUp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Motion().ThumbsUp(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_thumbsUp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_topic(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_topic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Motion().Topic(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Topic)
	fc.Result = res
	return ec.marshalNTopic2ᚖwhaleᚋpkgᚋmodelsᚐTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_topic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Topic_id(ctx, field)
			case "recentUsers":
				return ec.fieldContext_Topic_recentUsers(ctx, field)
			case "matchingNum":
				return ec.fieldContext_Topic_matchingNum(ctx, field)
			case "fuzzyMatchingNum":
				return ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Topic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_topicOptionConfig(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_topicOptionConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Motion().TopicOptionConfig(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.TopicOptionConfig)
	fc.Result = res
	return ec.marshalOTopicOptionConfig2ᚖwhaleᚋpkgᚋmodelsᚐTopicOptionConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_topicOptionConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "topicId":
				return ec.fieldContext_TopicOptionConfig_topicId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TopicOptionConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_user(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Motion().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2ᚖwhaleᚋpkgᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "matchingQuota":
				return ec.fieldContext_User_matchingQuota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_city(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_city(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Motion().City(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Area)
	fc.Result = res
	return ec.marshalNArea2ᚖwhaleᚋpkgᚋmodelsᚐArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_city(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_areas(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_areas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Motion().Areas(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Area)
	fc.Result = res
	return ec.marshalNArea2ᚕᚖwhaleᚋpkgᚋmodelsᚐAreaᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_areas(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionOfferRecord_id(ctx context.Context, field graphql.CollectedField, obj *models.MotionOfferRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionOfferRecord_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionOfferRecord_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionOfferRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionOfferRecord_toMotionId(ctx context.Context, field graphql.CollectedField, obj *models.MotionOfferRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionOfferRecord_toMotionId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToMotionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionOfferRecord_toMotionId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionOfferRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionOfferRecord_motionId(ctx context.Context, field graphql.CollectedField, obj *models.MotionOfferRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionOfferRecord_motionId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MotionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionOfferRecord_motionId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionOfferRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionOfferRecord_state(ctx context.Context, field graphql.CollectedField, obj *models.MotionOfferRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionOfferRecord_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MotionOfferRecord().State(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.MotionOfferState)
	fc.Result = res
	return ec.marshalNMotionOfferState2whaleᚋpkgᚋmodelsᚐMotionOfferState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionOfferRecord_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionOfferRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MotionOfferState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionOfferRecord_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.MotionOfferRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionOfferRecord_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionOfferRecord_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionOfferRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionOfferRecord_reactAt(ctx context.Context, field graphql.CollectedField, obj *models.MotionOfferRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionOfferRecord_reactAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReactAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionOfferRecord_reactAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionOfferRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionOfferRecord_remark(ctx context.Context, field graphql.CollectedField, obj *models.MotionOfferRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionOfferRecord_remark(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Remark, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionOfferRecord_remark(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionOfferRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionOfferRecord_chatChance(ctx context.Context, field graphql.CollectedField, obj *models.MotionOfferRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionOfferRecord_chatChance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChatChance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionOfferRecord_chatChance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionOfferRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionOfferRecord_reviewed(ctx context.Context, field graphql.CollectedField, obj *models.MotionOfferRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionOfferRecord_reviewed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MotionOfferRecord().Reviewed(rctx, obj, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionOfferRecord_reviewed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionOfferRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_MotionOfferRecord_reviewed_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _MotionOfferRecord_toMotion(ctx context.Context, field graphql.CollectedField, obj *models.MotionOfferRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionOfferRecord_toMotion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MotionOfferRecord().ToMotion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Motion)
	fc.Result = res
	return ec.marshalNDiscoverMotion2ᚖwhaleᚋpkgᚋmodelsᚐMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionOfferRecord_toMotion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionOfferRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscoverMotion_id(ctx, field)
			case "userId":
				return ec.fieldContext_DiscoverMotion_userId(ctx, field)
			case "topicId":
				return ec.fieldContext_DiscoverMotion_topicId(ctx, field)
			case "properties":
				return ec.fieldContext_DiscoverMotion_properties(ctx, field)
			case "cityId":
				return ec.fieldContext_DiscoverMotion_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_DiscoverMotion_areaIds(ctx, field)
			case "gender":
				return ec.fieldContext_DiscoverMotion_gender(ctx, field)
			case "dayRange":
				return ec.fieldContext_DiscoverMotion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_DiscoverMotion_preferredPeriods(ctx, field)
			case "remark":
				return ec.fieldContext_DiscoverMotion_remark(ctx, field)
			case "likeCount":
				return ec.fieldContext_DiscoverMotion_likeCount(ctx, field)
			case "viewCount":
				return ec.fieldContext_DiscoverMotion_viewCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_DiscoverMotion_thumbsUpCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_DiscoverMotion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_DiscoverMotion_liked(ctx, field)
			case "submitted":
				return ec.fieldContext_DiscoverMotion_submitted(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_DiscoverMotion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_DiscoverMotion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_DiscoverMotion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_DiscoverMotion_user(ctx, field)
			case "city":
				return ec.fieldContext_DiscoverMotion_city(ctx, field)
			case "areas":
				return ec.fieldContext_DiscoverMotion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscoverMotion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionOfferRecord_motion(ctx context.Context, field graphql.CollectedField, obj *models.MotionOfferRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionOfferRecord_motion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MotionOfferRecord().Motion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Motion)
	fc.Result = res
	return ec.marshalNDiscoverMotion2ᚖwhaleᚋpkgᚋmodelsᚐMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionOfferRecord_motion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionOfferRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscoverMotion_id(ctx, field)
			case "userId":
				return ec.fieldContext_DiscoverMotion_userId(ctx, field)
			case "topicId":
				return ec.fieldContext_DiscoverMotion_topicId(ctx, field)
			case "properties":
				return ec.fieldContext_DiscoverMotion_properties(ctx, field)
			case "cityId":
				return ec.fieldContext_DiscoverMotion_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_DiscoverMotion_areaIds(ctx, field)
			case "gender":
				return ec.fieldContext_DiscoverMotion_gender(ctx, field)
			case "dayRange":
				return ec.fieldContext_DiscoverMotion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_DiscoverMotion_preferredPeriods(ctx, field)
			case "remark":
				return ec.fieldContext_DiscoverMotion_remark(ctx, field)
			case "likeCount":
				return ec.fieldContext_DiscoverMotion_likeCount(ctx, field)
			case "viewCount":
				return ec.fieldContext_DiscoverMotion_viewCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_DiscoverMotion_thumbsUpCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_DiscoverMotion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_DiscoverMotion_liked(ctx, field)
			case "submitted":
				return ec.fieldContext_DiscoverMotion_submitted(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_DiscoverMotion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_DiscoverMotion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_DiscoverMotion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_DiscoverMotion_user(ctx, field)
			case "city":
				return ec.fieldContext_DiscoverMotion_city(ctx, field)
			case "areas":
				return ec.fieldContext_DiscoverMotion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscoverMotion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionProperty_id(ctx context.Context, field graphql.CollectedField, obj *models.MotionProperty) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionProperty_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionProperty_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionProperty",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionProperty_values(ctx context.Context, field graphql.CollectedField, obj *models.MotionProperty) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionProperty_values(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Values, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionProperty_values(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionProperty",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_refreshTopicMetrics(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_refreshTopicMetrics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RefreshTopicMetrics(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_refreshTopicMetrics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateDurationConstraint(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateDurationConstraint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateDurationConstraint(rctx, fc.Args["userId"].(string), fc.Args["param"].(models.UpdateDurationConstraintParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateDurationConstraint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateDurationConstraint_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMatchingInvitation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMatchingInvitation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateMatchingInvitation(rctx, fc.Args["userId"].(*string), fc.Args["param"].(models.CreateMatchingInvitationParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.MatchingInvitation)
	fc.Result = res
	return ec.marshalNMatchingInvitation2ᚖwhaleᚋpkgᚋmodelsᚐMatchingInvitation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMatchingInvitation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingInvitation_id(ctx, field)
			case "userId":
				return ec.fieldContext_MatchingInvitation_userId(ctx, field)
			case "inviteeId":
				return ec.fieldContext_MatchingInvitation_inviteeId(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingInvitation_topicId(ctx, field)
			case "remark":
				return ec.fieldContext_MatchingInvitation_remark(ctx, field)
			case "cityId":
				return ec.fieldContext_MatchingInvitation_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_MatchingInvitation_areaIds(ctx, field)
			case "matchingResultId":
				return ec.fieldContext_MatchingInvitation_matchingResultId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingInvitation_matchingIds(ctx, field)
			case "confirmState":
				return ec.fieldContext_MatchingInvitation_confirmState(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_MatchingInvitation_confirmedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingInvitation_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingInvitation_updatedAt(ctx, field)
			case "invitee":
				return ec.fieldContext_MatchingInvitation_invitee(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingInvitation_topic(ctx, field)
			case "areas":
				return ec.fieldContext_MatchingInvitation_areas(ctx, field)
			case "city":
				return ec.fieldContext_MatchingInvitation_city(ctx, field)
			case "user":
				return ec.fieldContext_MatchingInvitation_user(ctx, field)
			case "matchingResult":
				return ec.fieldContext_MatchingInvitation_matchingResult(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingInvitation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMatchingInvitation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelMatchingInvitation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cancelMatchingInvitation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CancelMatchingInvitation(rctx, fc.Args["invitationId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cancelMatchingInvitation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelMatchingInvitation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_confirmMatchingInvitation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_confirmMatchingInvitation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ConfirmMatchingInvitation(rctx, fc.Args["userId"].(*string), fc.Args["invitationId"].(string), fc.Args["confirm"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_confirmMatchingInvitation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_confirmMatchingInvitation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateMatchingInvitation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateMatchingInvitation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateMatchingInvitation(rctx, fc.Args["invitationId"].(string), fc.Args["param"].(models.UpdateMatchingInvitationParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.MatchingInvitation)
	fc.Result = res
	return ec.marshalNMatchingInvitation2ᚖwhaleᚋpkgᚋmodelsᚐMatchingInvitation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateMatchingInvitation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingInvitation_id(ctx, field)
			case "userId":
				return ec.fieldContext_MatchingInvitation_userId(ctx, field)
			case "inviteeId":
				return ec.fieldContext_MatchingInvitation_inviteeId(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingInvitation_topicId(ctx, field)
			case "remark":
				return ec.fieldContext_MatchingInvitation_remark(ctx, field)
			case "cityId":
				return ec.fieldContext_MatchingInvitation_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_MatchingInvitation_areaIds(ctx, field)
			case "matchingResultId":
				return ec.fieldContext_MatchingInvitation_matchingResultId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingInvitation_matchingIds(ctx, field)
			case "confirmState":
				return ec.fieldContext_MatchingInvitation_confirmState(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_MatchingInvitation_confirmedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingInvitation_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingInvitation_updatedAt(ctx, field)
			case "invitee":
				return ec.fieldContext_MatchingInvitation_invitee(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingInvitation_topic(ctx, field)
			case "areas":
				return ec.fieldContext_MatchingInvitation_areas(ctx, field)
			case "city":
				return ec.fieldContext_MatchingInvitation_city(ctx, field)
			case "user":
				return ec.fieldContext_MatchingInvitation_user(ctx, field)
			case "matchingResult":
				return ec.fieldContext_MatchingInvitation_matchingResult(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingInvitation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateMatchingInvitation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMatching(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMatching(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateMatching(rctx, fc.Args["userId"].(*string), fc.Args["param"].(models.CreateMatchingParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Matching)
	fc.Result = res
	return ec.marshalNMatching2ᚖwhaleᚋpkgᚋmodelsᚐMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMatching(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Matching_id(ctx, field)
			case "topicId":
				return ec.fieldContext_Matching_topicId(ctx, field)
			case "userId":
				return ec.fieldContext_Matching_userId(ctx, field)
			case "areaIds":
				return ec.fieldContext_Matching_areaIds(ctx, field)
			case "cityId":
				return ec.fieldContext_Matching_cityId(ctx, field)
			case "gender":
				return ec.fieldContext_Matching_gender(ctx, field)
			case "state":
				return ec.fieldContext_Matching_state(ctx, field)
			case "rejectedUserIds":
				return ec.fieldContext_Matching_rejectedUserIds(ctx, field)
			case "inChatGroup":
				return ec.fieldContext_Matching_inChatGroup(ctx, field)
			case "remark":
				return ec.fieldContext_Matching_remark(ctx, field)
			case "dayRange":
				return ec.fieldContext_Matching_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Matching_preferredPeriods(ctx, field)
			case "properties":
				return ec.fieldContext_Matching_properties(ctx, field)
			case "startMatchingAt":
				return ec.fieldContext_Matching_startMatchingAt(ctx, field)
			case "deadline":
				return ec.fieldContext_Matching_deadline(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Matching_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Matching_createdAt(ctx, field)
			case "matchingResult":
				return ec.fieldContext_Matching_matchingResult(ctx, field)
			case "reviewed":
				return ec.fieldContext_Matching_reviewed(ctx, field)
			case "user":
				return ec.fieldContext_Matching_user(ctx, field)
			case "topic":
				return ec.fieldContext_Matching_topic(ctx, field)
			case "areas":
				return ec.fieldContext_Matching_areas(ctx, field)
			case "city":
				return ec.fieldContext_Matching_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Matching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMatching_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMatchingV2(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMatchingV2(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateMatchingV2(rctx, fc.Args["userId"].(*string), fc.Args["param"].(models.CreateMatchingParamV2))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Matching)
	fc.Result = res
	return ec.marshalNMatching2ᚖwhaleᚋpkgᚋmodelsᚐMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMatchingV2(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Matching_id(ctx, field)
			case "topicId":
				return ec.fieldContext_Matching_topicId(ctx, field)
			case "userId":
				return ec.fieldContext_Matching_userId(ctx, field)
			case "areaIds":
				return ec.fieldContext_Matching_areaIds(ctx, field)
			case "cityId":
				return ec.fieldContext_Matching_cityId(ctx, field)
			case "gender":
				return ec.fieldContext_Matching_gender(ctx, field)
			case "state":
				return ec.fieldContext_Matching_state(ctx, field)
			case "rejectedUserIds":
				return ec.fieldContext_Matching_rejectedUserIds(ctx, field)
			case "inChatGroup":
				return ec.fieldContext_Matching_inChatGroup(ctx, field)
			case "remark":
				return ec.fieldContext_Matching_remark(ctx, field)
			case "dayRange":
				return ec.fieldContext_Matching_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Matching_preferredPeriods(ctx, field)
			case "properties":
				return ec.fieldContext_Matching_properties(ctx, field)
			case "startMatchingAt":
				return ec.fieldContext_Matching_startMatchingAt(ctx, field)
			case "deadline":
				return ec.fieldContext_Matching_deadline(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Matching_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Matching_createdAt(ctx, field)
			case "matchingResult":
				return ec.fieldContext_Matching_matchingResult(ctx, field)
			case "reviewed":
				return ec.fieldContext_Matching_reviewed(ctx, field)
			case "user":
				return ec.fieldContext_Matching_user(ctx, field)
			case "topic":
				return ec.fieldContext_Matching_topic(ctx, field)
			case "areas":
				return ec.fieldContext_Matching_areas(ctx, field)
			case "city":
				return ec.fieldContext_Matching_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Matching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMatchingV2_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateMatching(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateMatching(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateMatching(rctx, fc.Args["matchingId"].(string), fc.Args["param"].(models.UpdateMatchingParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Matching)
	fc.Result = res
	return ec.marshalNMatching2ᚖwhaleᚋpkgᚋmodelsᚐMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateMatching(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Matching_id(ctx, field)
			case "topicId":
				return ec.fieldContext_Matching_topicId(ctx, field)
			case "userId":
				return ec.fieldContext_Matching_userId(ctx, field)
			case "areaIds":
				return ec.fieldContext_Matching_areaIds(ctx, field)
			case "cityId":
				return ec.fieldContext_Matching_cityId(ctx, field)
			case "gender":
				return ec.fieldContext_Matching_gender(ctx, field)
			case "state":
				return ec.fieldContext_Matching_state(ctx, field)
			case "rejectedUserIds":
				return ec.fieldContext_Matching_rejectedUserIds(ctx, field)
			case "inChatGroup":
				return ec.fieldContext_Matching_inChatGroup(ctx, field)
			case "remark":
				return ec.fieldContext_Matching_remark(ctx, field)
			case "dayRange":
				return ec.fieldContext_Matching_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Matching_preferredPeriods(ctx, field)
			case "properties":
				return ec.fieldContext_Matching_properties(ctx, field)
			case "startMatchingAt":
				return ec.fieldContext_Matching_startMatchingAt(ctx, field)
			case "deadline":
				return ec.fieldContext_Matching_deadline(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Matching_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Matching_createdAt(ctx, field)
			case "matchingResult":
				return ec.fieldContext_Matching_matchingResult(ctx, field)
			case "reviewed":
				return ec.fieldContext_Matching_reviewed(ctx, field)
			case "user":
				return ec.fieldContext_Matching_user(ctx, field)
			case "topic":
				return ec.fieldContext_Matching_topic(ctx, field)
			case "areas":
				return ec.fieldContext_Matching_areas(ctx, field)
			case "city":
				return ec.fieldContext_Matching_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Matching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateMatching_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateMatchingQuota(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateMatchingQuota(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateMatchingQuota(rctx, fc.Args["userId"].(string), fc.Args["param"].(models.UpdateMatchingQuotaParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateMatchingQuota(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateMatchingQuota_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateMatchingDurationConstraint(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateMatchingDurationConstraint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateMatchingDurationConstraint(rctx, fc.Args["userId"].(string), fc.Args["param"].(models.UpdateMatchingDurationConstraintParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateMatchingDurationConstraint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateMatchingDurationConstraint_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_confirmMatchingResult(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_confirmMatchingResult(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ConfirmMatchingResult(rctx, fc.Args["userId"].(*string), fc.Args["matchingId"].(string), fc.Args["reject"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_confirmMatchingResult(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_confirmMatchingResult_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_confirmMatchingResultV2(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_confirmMatchingResultV2(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ConfirmMatchingResultV2(rctx, fc.Args["userId"].(*string), fc.Args["matchingId"].(string), fc.Args["confirm"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_confirmMatchingResultV2(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_confirmMatchingResultV2_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelMatching(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cancelMatching(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CancelMatching(rctx, fc.Args["matchingId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cancelMatching(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelMatching_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_startMatching(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_startMatching(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().StartMatching(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_startMatching(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_finishMatching(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_finishMatching(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().FinishMatching(rctx, fc.Args["matchingId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_finishMatching(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_finishMatching_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_reviewMatching(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_reviewMatching(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ReviewMatching(rctx, fc.Args["matchingId"].(string), fc.Args["param"].(models.ReviewMatchingParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_reviewMatching(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_reviewMatching_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateRecentMatching(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateRecentMatching(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateRecentMatching(rctx, fc.Args["id"].(string), fc.Args["param"].(models.UpdateRecentMatchingParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.RecentMatching)
	fc.Result = res
	return ec.marshalNRecentMatching2ᚖwhaleᚋpkgᚋmodelsᚐRecentMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateRecentMatching(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RecentMatching_id(ctx, field)
			case "cityId":
				return ec.fieldContext_RecentMatching_cityId(ctx, field)
			case "topicId":
				return ec.fieldContext_RecentMatching_topicId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_RecentMatching_matchingIds(ctx, field)
			case "createdAt":
				return ec.fieldContext_RecentMatching_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_RecentMatching_updatedAt(ctx, field)
			case "topic":
				return ec.fieldContext_RecentMatching_topic(ctx, field)
			case "city":
				return ec.fieldContext_RecentMatching_city(ctx, field)
			case "matchings":
				return ec.fieldContext_RecentMatching_matchings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RecentMatching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateRecentMatching_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addMatchingToRecent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addMatchingToRecent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddMatchingToRecent(rctx, fc.Args["matchingId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.RecentMatching)
	fc.Result = res
	return ec.marshalNRecentMatching2ᚖwhaleᚋpkgᚋmodelsᚐRecentMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addMatchingToRecent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RecentMatching_id(ctx, field)
			case "cityId":
				return ec.fieldContext_RecentMatching_cityId(ctx, field)
			case "topicId":
				return ec.fieldContext_RecentMatching_topicId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_RecentMatching_matchingIds(ctx, field)
			case "createdAt":
				return ec.fieldContext_RecentMatching_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_RecentMatching_updatedAt(ctx, field)
			case "topic":
				return ec.fieldContext_RecentMatching_topic(ctx, field)
			case "city":
				return ec.fieldContext_RecentMatching_city(ctx, field)
			case "matchings":
				return ec.fieldContext_RecentMatching_matchings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RecentMatching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addMatchingToRecent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_getMatchingScore(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_getMatchingScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().GetMatchingScore(rctx, fc.Args["id1"].(string), fc.Args["id2"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*matcher.EvaluatorResult)
	fc.Result = res
	return ec.marshalNEvaluatorResult2ᚖwhaleᚋpkgᚋmatcherᚐEvaluatorResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_getMatchingScore(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "score":
				return ec.fieldContext_EvaluatorResult_score(ctx, field)
			case "timeScore":
				return ec.fieldContext_EvaluatorResult_timeScore(ctx, field)
			case "properties":
				return ec.fieldContext_EvaluatorResult_properties(ctx, field)
			case "failedReason":
				return ec.fieldContext_EvaluatorResult_failedReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EvaluatorResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_getMatchingScore_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_getAvailableMotionOffer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_getAvailableMotionOffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().GetAvailableMotionOffer(rctx, fc.Args["userId"].(*string), fc.Args["targetMotionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.AvailableMotionOffer)
	fc.Result = res
	return ec.marshalNAvailableMotionOffer2ᚖwhaleᚋpkgᚋmodelsᚐAvailableMotionOffer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_getAvailableMotionOffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "motion":
				return ec.fieldContext_AvailableMotionOffer_motion(ctx, field)
			case "nextQuotaTime":
				return ec.fieldContext_AvailableMotionOffer_nextQuotaTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AvailableMotionOffer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_getAvailableMotionOffer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMotionOffer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMotionOffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateMotionOffer(rctx, fc.Args["myMotionId"].(string), fc.Args["targetMotionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.CreateMotionOfferResult)
	fc.Result = res
	return ec.marshalNCreateMotionOfferResult2ᚖwhaleᚋpkgᚋmodelsᚐCreateMotionOfferResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMotionOffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "chatGroupId":
				return ec.fieldContext_CreateMotionOfferResult_chatGroupId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateMotionOfferResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMotionOffer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelMotionOffer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cancelMotionOffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CancelMotionOffer(rctx, fc.Args["myMotionId"].(string), fc.Args["targetMotionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cancelMotionOffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelMotionOffer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_acceptMotionOffer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_acceptMotionOffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AcceptMotionOffer(rctx, fc.Args["myMotionId"].(string), fc.Args["targetMotionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_acceptMotionOffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_acceptMotionOffer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_rejectMotionOffer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_rejectMotionOffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RejectMotionOffer(rctx, fc.Args["myMotionId"].(string), fc.Args["targetMotionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_rejectMotionOffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_rejectMotionOffer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_sendChatInOffer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_sendChatInOffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SendChatInOffer(rctx, fc.Args["myMotionId"].(string), fc.Args["targetMotionId"].(string), fc.Args["sentence"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_sendChatInOffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_sendChatInOffer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_finishMotionOffer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_finishMotionOffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().FinishMotionOffer(rctx, fc.Args["fromMotionId"].(string), fc.Args["toMotionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_finishMotionOffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_finishMotionOffer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_notifyNewMotionOffer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_notifyNewMotionOffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().NotifyNewMotionOffer(rctx, fc.Args["param"].(*models.NotifyNewMotionOfferMessageParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_notifyNewMotionOffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_notifyNewMotionOffer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_sendMotionOfferAcceptMessage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_sendMotionOfferAcceptMessage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SendMotionOfferAcceptMessage(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_sendMotionOfferAcceptMessage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_sendMotionOfferAcceptMessage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMotion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMotion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateMotion(rctx, fc.Args["userId"].(*string), fc.Args["param"].(models.CreateMotionParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Motion)
	fc.Result = res
	return ec.marshalNMotion2ᚖwhaleᚋpkgᚋmodelsᚐMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMotion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Motion_id(ctx, field)
			case "userId":
				return ec.fieldContext_Motion_userId(ctx, field)
			case "cityId":
				return ec.fieldContext_Motion_cityId(ctx, field)
			case "remark":
				return ec.fieldContext_Motion_remark(ctx, field)
			case "active":
				return ec.fieldContext_Motion_active(ctx, field)
			case "inOfferNum":
				return ec.fieldContext_Motion_inOfferNum(ctx, field)
			case "outOfferNum":
				return ec.fieldContext_Motion_outOfferNum(ctx, field)
			case "pendingInNum":
				return ec.fieldContext_Motion_pendingInNum(ctx, field)
			case "pendingOutNum":
				return ec.fieldContext_Motion_pendingOutNum(ctx, field)
			case "activeNum":
				return ec.fieldContext_Motion_activeNum(ctx, field)
			case "discoverable":
				return ec.fieldContext_Motion_discoverable(ctx, field)
			case "relatedMatchingId":
				return ec.fieldContext_Motion_relatedMatchingId(ctx, field)
			case "properties":
				return ec.fieldContext_Motion_properties(ctx, field)
			case "dayRange":
				return ec.fieldContext_Motion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Motion_preferredPeriods(ctx, field)
			case "gender":
				return ec.fieldContext_Motion_gender(ctx, field)
			case "createdAt":
				return ec.fieldContext_Motion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_Motion_liked(ctx, field)
			case "viewCount":
				return ec.fieldContext_Motion_viewCount(ctx, field)
			case "likeCount":
				return ec.fieldContext_Motion_likeCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_Motion_thumbsUpCount(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_Motion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_Motion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_Motion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_Motion_user(ctx, field)
			case "city":
				return ec.fieldContext_Motion_city(ctx, field)
			case "areas":
				return ec.fieldContext_Motion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Motion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMotion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateMotion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateMotion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateMotion(rctx, fc.Args["id"].(string), fc.Args["param"].(models.UpdateMotionParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Motion)
	fc.Result = res
	return ec.marshalNMotion2ᚖwhaleᚋpkgᚋmodelsᚐMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateMotion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Motion_id(ctx, field)
			case "userId":
				return ec.fieldContext_Motion_userId(ctx, field)
			case "cityId":
				return ec.fieldContext_Motion_cityId(ctx, field)
			case "remark":
				return ec.fieldContext_Motion_remark(ctx, field)
			case "active":
				return ec.fieldContext_Motion_active(ctx, field)
			case "inOfferNum":
				return ec.fieldContext_Motion_inOfferNum(ctx, field)
			case "outOfferNum":
				return ec.fieldContext_Motion_outOfferNum(ctx, field)
			case "pendingInNum":
				return ec.fieldContext_Motion_pendingInNum(ctx, field)
			case "pendingOutNum":
				return ec.fieldContext_Motion_pendingOutNum(ctx, field)
			case "activeNum":
				return ec.fieldContext_Motion_activeNum(ctx, field)
			case "discoverable":
				return ec.fieldContext_Motion_discoverable(ctx, field)
			case "relatedMatchingId":
				return ec.fieldContext_Motion_relatedMatchingId(ctx, field)
			case "properties":
				return ec.fieldContext_Motion_properties(ctx, field)
			case "dayRange":
				return ec.fieldContext_Motion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Motion_preferredPeriods(ctx, field)
			case "gender":
				return ec.fieldContext_Motion_gender(ctx, field)
			case "createdAt":
				return ec.fieldContext_Motion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_Motion_liked(ctx, field)
			case "viewCount":
				return ec.fieldContext_Motion_viewCount(ctx, field)
			case "likeCount":
				return ec.fieldContext_Motion_likeCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_Motion_thumbsUpCount(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_Motion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_Motion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_Motion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_Motion_user(ctx, field)
			case "city":
				return ec.fieldContext_Motion_city(ctx, field)
			case "areas":
				return ec.fieldContext_Motion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Motion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateMotion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_userUpdateMotion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_userUpdateMotion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UserUpdateMotion(rctx, fc.Args["myMotionId"].(string), fc.Args["param"].(models.UserUpdateMotionParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Motion)
	fc.Result = res
	return ec.marshalNMotion2ᚖwhaleᚋpkgᚋmodelsᚐMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_userUpdateMotion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Motion_id(ctx, field)
			case "userId":
				return ec.fieldContext_Motion_userId(ctx, field)
			case "cityId":
				return ec.fieldContext_Motion_cityId(ctx, field)
			case "remark":
				return ec.fieldContext_Motion_remark(ctx, field)
			case "active":
				return ec.fieldContext_Motion_active(ctx, field)
			case "inOfferNum":
				return ec.fieldContext_Motion_inOfferNum(ctx, field)
			case "outOfferNum":
				return ec.fieldContext_Motion_outOfferNum(ctx, field)
			case "pendingInNum":
				return ec.fieldContext_Motion_pendingInNum(ctx, field)
			case "pendingOutNum":
				return ec.fieldContext_Motion_pendingOutNum(ctx, field)
			case "activeNum":
				return ec.fieldContext_Motion_activeNum(ctx, field)
			case "discoverable":
				return ec.fieldContext_Motion_discoverable(ctx, field)
			case "relatedMatchingId":
				return ec.fieldContext_Motion_relatedMatchingId(ctx, field)
			case "properties":
				return ec.fieldContext_Motion_properties(ctx, field)
			case "dayRange":
				return ec.fieldContext_Motion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Motion_preferredPeriods(ctx, field)
			case "gender":
				return ec.fieldContext_Motion_gender(ctx, field)
			case "createdAt":
				return ec.fieldContext_Motion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_Motion_liked(ctx, field)
			case "viewCount":
				return ec.fieldContext_Motion_viewCount(ctx, field)
			case "likeCount":
				return ec.fieldContext_Motion_likeCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_Motion_thumbsUpCount(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_Motion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_Motion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_Motion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_Motion_user(ctx, field)
			case "city":
				return ec.fieldContext_Motion_city(ctx, field)
			case "areas":
				return ec.fieldContext_Motion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Motion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_userUpdateMotion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_closeMotion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_closeMotion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CloseMotion(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_closeMotion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_closeMotion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_reviewMotionOffer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_reviewMotionOffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ReviewMotionOffer(rctx, fc.Args["userId"].(*string), fc.Args["fromMotionId"].(string), fc.Args["toMotionId"].(string), fc.Args["param"].(models.ReviewMotionParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_reviewMotionOffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_reviewMotionOffer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createCityTopics(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createCityTopics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateCityTopics(rctx, fc.Args["param"].(models.CreateCityTopicParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.CityTopics)
	fc.Result = res
	return ec.marshalNCityTopics2ᚖwhaleᚋpkgᚋmodelsᚐCityTopics(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createCityTopics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cityId":
				return ec.fieldContext_CityTopics_cityId(ctx, field)
			case "topicIds":
				return ec.fieldContext_CityTopics_topicIds(ctx, field)
			case "updatedAt":
				return ec.fieldContext_CityTopics_updatedAt(ctx, field)
			case "topics":
				return ec.fieldContext_CityTopics_topics(ctx, field)
			case "city":
				return ec.fieldContext_CityTopics_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CityTopics", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createCityTopics_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateCityTopics(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateCityTopics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateCityTopics(rctx, fc.Args["cityId"].(string), fc.Args["param"].(models.UpdateCityTopicParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.CityTopics)
	fc.Result = res
	return ec.marshalNCityTopics2ᚖwhaleᚋpkgᚋmodelsᚐCityTopics(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateCityTopics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cityId":
				return ec.fieldContext_CityTopics_cityId(ctx, field)
			case "topicIds":
				return ec.fieldContext_CityTopics_topicIds(ctx, field)
			case "updatedAt":
				return ec.fieldContext_CityTopics_updatedAt(ctx, field)
			case "topics":
				return ec.fieldContext_CityTopics_topics(ctx, field)
			case "city":
				return ec.fieldContext_CityTopics_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CityTopics", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateCityTopics_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateHotTopicsInArea(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateHotTopicsInArea(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateHotTopicsInArea(rctx, fc.Args["cityId"].(string), fc.Args["param"].(models.UpdateHotTopicParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.HotTopicsInArea)
	fc.Result = res
	return ec.marshalNHotTopicsInArea2ᚖwhaleᚋpkgᚋmodelsᚐHotTopicsInArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateHotTopicsInArea(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cityId":
				return ec.fieldContext_HotTopicsInArea_cityId(ctx, field)
			case "updatedAt":
				return ec.fieldContext_HotTopicsInArea_updatedAt(ctx, field)
			case "topicMetrics":
				return ec.fieldContext_HotTopicsInArea_topicMetrics(ctx, field)
			case "city":
				return ec.fieldContext_HotTopicsInArea_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HotTopicsInArea", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateHotTopicsInArea_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateUserJoinTopic(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateUserJoinTopic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateUserJoinTopic(rctx, fc.Args["id"].(int), fc.Args["param"].(models.UpdateUserJoinTopicParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.UserJoinTopic)
	fc.Result = res
	return ec.marshalNUserJoinTopic2ᚖwhaleᚋpkgᚋmodelsᚐUserJoinTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateUserJoinTopic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserJoinTopic_id(ctx, field)
			case "topicId":
				return ec.fieldContext_UserJoinTopic_topicId(ctx, field)
			case "cityId":
				return ec.fieldContext_UserJoinTopic_cityId(ctx, field)
			case "userId":
				return ec.fieldContext_UserJoinTopic_userId(ctx, field)
			case "latestMatchingId":
				return ec.fieldContext_UserJoinTopic_latestMatchingId(ctx, field)
			case "createdAt":
				return ec.fieldContext_UserJoinTopic_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_UserJoinTopic_updatedAt(ctx, field)
			case "topic":
				return ec.fieldContext_UserJoinTopic_topic(ctx, field)
			case "city":
				return ec.fieldContext_UserJoinTopic_city(ctx, field)
			case "user":
				return ec.fieldContext_UserJoinTopic_user(ctx, field)
			case "matching":
				return ec.fieldContext_UserJoinTopic_matching(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserJoinTopic", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUserJoinTopic_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createUserJoinTopic(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createUserJoinTopic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateUserJoinTopic(rctx, fc.Args["param"].(models.CreateUserJoinTopicParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.UserJoinTopic)
	fc.Result = res
	return ec.marshalNUserJoinTopic2ᚖwhaleᚋpkgᚋmodelsᚐUserJoinTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createUserJoinTopic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserJoinTopic_id(ctx, field)
			case "topicId":
				return ec.fieldContext_UserJoinTopic_topicId(ctx, field)
			case "cityId":
				return ec.fieldContext_UserJoinTopic_cityId(ctx, field)
			case "userId":
				return ec.fieldContext_UserJoinTopic_userId(ctx, field)
			case "latestMatchingId":
				return ec.fieldContext_UserJoinTopic_latestMatchingId(ctx, field)
			case "createdAt":
				return ec.fieldContext_UserJoinTopic_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_UserJoinTopic_updatedAt(ctx, field)
			case "topic":
				return ec.fieldContext_UserJoinTopic_topic(ctx, field)
			case "city":
				return ec.fieldContext_UserJoinTopic_city(ctx, field)
			case "user":
				return ec.fieldContext_UserJoinTopic_user(ctx, field)
			case "matching":
				return ec.fieldContext_UserJoinTopic_matching(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserJoinTopic", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createUserJoinTopic_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_likeMotion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_likeMotion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().LikeMotion(rctx, fc.Args["userId"].(*string), fc.Args["motionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_likeMotion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_likeMotion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unlikeMotion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unlikeMotion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UnlikeMotion(rctx, fc.Args["userId"].(*string), fc.Args["motionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unlikeMotion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unlikeMotion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_thumbsUpMotion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_thumbsUpMotion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ThumbsUpMotion(rctx, fc.Args["userId"].(*string), fc.Args["motionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_thumbsUpMotion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_thumbsUpMotion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelThumbsUpMotion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cancelThumbsUpMotion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CancelThumbsUpMotion(rctx, fc.Args["userId"].(*string), fc.Args["motionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cancelThumbsUpMotion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelThumbsUpMotion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_thumbsUpMotions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_thumbsUpMotions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ThumbsUpMotions(rctx, fc.Args["userId"].(*string), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.UserThumbsUpMotion)
	fc.Result = res
	return ec.marshalNUserThumbsUpMotion2ᚕᚖwhaleᚋpkgᚋmodelsᚐUserThumbsUpMotionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_thumbsUpMotions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userId":
				return ec.fieldContext_UserThumbsUpMotion_userId(ctx, field)
			case "toMotionId":
				return ec.fieldContext_UserThumbsUpMotion_toMotionId(ctx, field)
			case "createdAt":
				return ec.fieldContext_UserThumbsUpMotion_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserThumbsUpMotion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_thumbsUpMotions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_thumbsUpMotionsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_thumbsUpMotionsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ThumbsUpMotionsCount(rctx, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2ᚖwhaleᚋpkgᚋmodelsᚐSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_thumbsUpMotionsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_thumbsUpMotionsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_chatGroupByResultId(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_chatGroupByResultId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ChatGroupByResultID(rctx, fc.Args["resultId"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.ChatGroup)
	fc.Result = res
	return ec.marshalNChatGroup2ᚖwhaleᚋpkgᚋmodelsᚐChatGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_chatGroupByResultId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ChatGroup_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChatGroup", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_chatGroupByResultId_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userDurationConstraint(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userDurationConstraint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserDurationConstraint(rctx, fc.Args["userId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.DurationConstraint)
	fc.Result = res
	return ec.marshalNDurationConstraint2ᚖwhaleᚋpkgᚋmodelsᚐDurationConstraint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userDurationConstraint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userId":
				return ec.fieldContext_DurationConstraint_userId(ctx, field)
			case "startDate":
				return ec.fieldContext_DurationConstraint_startDate(ctx, field)
			case "stopDate":
				return ec.fieldContext_DurationConstraint_stopDate(ctx, field)
			case "totalMotionQuota":
				return ec.fieldContext_DurationConstraint_totalMotionQuota(ctx, field)
			case "remainMotionQuota":
				return ec.fieldContext_DurationConstraint_remainMotionQuota(ctx, field)
			case "updatedAt":
				return ec.fieldContext_DurationConstraint_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DurationConstraint", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userDurationConstraint_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_yesterdayMatchingCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_yesterdayMatchingCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().YesterdayMatchingCount(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_yesterdayMatchingCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_motionSummary(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_motionSummary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MotionSummary(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_motionSummary(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_matchingInvitations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_matchingInvitations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MatchingInvitations(rctx, fc.Args["filter"].(*models.MatchingInvitationFilter), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.MatchingInvitation)
	fc.Result = res
	return ec.marshalNMatchingInvitation2ᚕᚖwhaleᚋpkgᚋmodelsᚐMatchingInvitationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_matchingInvitations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingInvitation_id(ctx, field)
			case "userId":
				return ec.fieldContext_MatchingInvitation_userId(ctx, field)
			case "inviteeId":
				return ec.fieldContext_MatchingInvitation_inviteeId(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingInvitation_topicId(ctx, field)
			case "remark":
				return ec.fieldContext_MatchingInvitation_remark(ctx, field)
			case "cityId":
				return ec.fieldContext_MatchingInvitation_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_MatchingInvitation_areaIds(ctx, field)
			case "matchingResultId":
				return ec.fieldContext_MatchingInvitation_matchingResultId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingInvitation_matchingIds(ctx, field)
			case "confirmState":
				return ec.fieldContext_MatchingInvitation_confirmState(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_MatchingInvitation_confirmedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingInvitation_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingInvitation_updatedAt(ctx, field)
			case "invitee":
				return ec.fieldContext_MatchingInvitation_invitee(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingInvitation_topic(ctx, field)
			case "areas":
				return ec.fieldContext_MatchingInvitation_areas(ctx, field)
			case "city":
				return ec.fieldContext_MatchingInvitation_city(ctx, field)
			case "user":
				return ec.fieldContext_MatchingInvitation_user(ctx, field)
			case "matchingResult":
				return ec.fieldContext_MatchingInvitation_matchingResult(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingInvitation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_matchingInvitations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_matchingInvitationsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_matchingInvitationsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MatchingInvitationsCount(rctx, fc.Args["filter"].(*models.MatchingInvitationFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2ᚖwhaleᚋpkgᚋmodelsᚐSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_matchingInvitationsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_matchingInvitationsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_invitations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_invitations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Invitations(rctx, fc.Args["userId"].(*string), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.MatchingInvitation)
	fc.Result = res
	return ec.marshalNMatchingInvitation2ᚕᚖwhaleᚋpkgᚋmodelsᚐMatchingInvitationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_invitations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingInvitation_id(ctx, field)
			case "userId":
				return ec.fieldContext_MatchingInvitation_userId(ctx, field)
			case "inviteeId":
				return ec.fieldContext_MatchingInvitation_inviteeId(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingInvitation_topicId(ctx, field)
			case "remark":
				return ec.fieldContext_MatchingInvitation_remark(ctx, field)
			case "cityId":
				return ec.fieldContext_MatchingInvitation_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_MatchingInvitation_areaIds(ctx, field)
			case "matchingResultId":
				return ec.fieldContext_MatchingInvitation_matchingResultId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingInvitation_matchingIds(ctx, field)
			case "confirmState":
				return ec.fieldContext_MatchingInvitation_confirmState(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_MatchingInvitation_confirmedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingInvitation_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingInvitation_updatedAt(ctx, field)
			case "invitee":
				return ec.fieldContext_MatchingInvitation_invitee(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingInvitation_topic(ctx, field)
			case "areas":
				return ec.fieldContext_MatchingInvitation_areas(ctx, field)
			case "city":
				return ec.fieldContext_MatchingInvitation_city(ctx, field)
			case "user":
				return ec.fieldContext_MatchingInvitation_user(ctx, field)
			case "matchingResult":
				return ec.fieldContext_MatchingInvitation_matchingResult(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingInvitation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_invitations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_invitation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_invitation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Invitation(rctx, fc.Args["userId"].(*string), fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.MatchingInvitation)
	fc.Result = res
	return ec.marshalNMatchingInvitation2ᚖwhaleᚋpkgᚋmodelsᚐMatchingInvitation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_invitation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingInvitation_id(ctx, field)
			case "userId":
				return ec.fieldContext_MatchingInvitation_userId(ctx, field)
			case "inviteeId":
				return ec.fieldContext_MatchingInvitation_inviteeId(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingInvitation_topicId(ctx, field)
			case "remark":
				return ec.fieldContext_MatchingInvitation_remark(ctx, field)
			case "cityId":
				return ec.fieldContext_MatchingInvitation_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_MatchingInvitation_areaIds(ctx, field)
			case "matchingResultId":
				return ec.fieldContext_MatchingInvitation_matchingResultId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingInvitation_matchingIds(ctx, field)
			case "confirmState":
				return ec.fieldContext_MatchingInvitation_confirmState(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_MatchingInvitation_confirmedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingInvitation_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingInvitation_updatedAt(ctx, field)
			case "invitee":
				return ec.fieldContext_MatchingInvitation_invitee(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingInvitation_topic(ctx, field)
			case "areas":
				return ec.fieldContext_MatchingInvitation_areas(ctx, field)
			case "city":
				return ec.fieldContext_MatchingInvitation_city(ctx, field)
			case "user":
				return ec.fieldContext_MatchingInvitation_user(ctx, field)
			case "matchingResult":
				return ec.fieldContext_MatchingInvitation_matchingResult(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingInvitation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_invitation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_invitationsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_invitationsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().InvitationsCount(rctx, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2ᚖwhaleᚋpkgᚋmodelsᚐSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_invitationsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_invitationsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_matching(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_matching(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Matching(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Matching)
	fc.Result = res
	return ec.marshalNMatching2ᚖwhaleᚋpkgᚋmodelsᚐMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_matching(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Matching_id(ctx, field)
			case "topicId":
				return ec.fieldContext_Matching_topicId(ctx, field)
			case "userId":
				return ec.fieldContext_Matching_userId(ctx, field)
			case "areaIds":
				return ec.fieldContext_Matching_areaIds(ctx, field)
			case "cityId":
				return ec.fieldContext_Matching_cityId(ctx, field)
			case "gender":
				return ec.fieldContext_Matching_gender(ctx, field)
			case "state":
				return ec.fieldContext_Matching_state(ctx, field)
			case "rejectedUserIds":
				return ec.fieldContext_Matching_rejectedUserIds(ctx, field)
			case "inChatGroup":
				return ec.fieldContext_Matching_inChatGroup(ctx, field)
			case "remark":
				return ec.fieldContext_Matching_remark(ctx, field)
			case "dayRange":
				return ec.fieldContext_Matching_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Matching_preferredPeriods(ctx, field)
			case "properties":
				return ec.fieldContext_Matching_properties(ctx, field)
			case "startMatchingAt":
				return ec.fieldContext_Matching_startMatchingAt(ctx, field)
			case "deadline":
				return ec.fieldContext_Matching_deadline(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Matching_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Matching_createdAt(ctx, field)
			case "matchingResult":
				return ec.fieldContext_Matching_matchingResult(ctx, field)
			case "reviewed":
				return ec.fieldContext_Matching_reviewed(ctx, field)
			case "user":
				return ec.fieldContext_Matching_user(ctx, field)
			case "topic":
				return ec.fieldContext_Matching_topic(ctx, field)
			case "areas":
				return ec.fieldContext_Matching_areas(ctx, field)
			case "city":
				return ec.fieldContext_Matching_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Matching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_matching_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userMatchingQuota(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userMatchingQuota(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserMatchingQuota(rctx, fc.Args["userId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.MatchingQuota)
	fc.Result = res
	return ec.marshalNMatchingQuota2ᚖwhaleᚋpkgᚋmodelsᚐMatchingQuota(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userMatchingQuota(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userId":
				return ec.fieldContext_MatchingQuota_userId(ctx, field)
			case "remain":
				return ec.fieldContext_MatchingQuota_remain(ctx, field)
			case "total":
				return ec.fieldContext_MatchingQuota_total(ctx, field)
			case "matchingNum":
				return ec.fieldContext_MatchingQuota_matchingNum(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingQuota_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingQuota_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingQuota", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userMatchingQuota_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userMatchingCalendar(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userMatchingCalendar(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserMatchingCalendar(rctx, fc.Args["userId"].(*string), fc.Args["param"].(models.UserMatchingCalenderParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.CalendarEvent)
	fc.Result = res
	return ec.marshalNCalendarEvent2ᚕᚖwhaleᚋpkgᚋmodelsᚐCalendarEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userMatchingCalendar(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "topicId":
				return ec.fieldContext_CalendarEvent_topicId(ctx, field)
			case "matchedAt":
				return ec.fieldContext_CalendarEvent_matchedAt(ctx, field)
			case "finishedAt":
				return ec.fieldContext_CalendarEvent_finishedAt(ctx, field)
			case "chatGroupCreatedAt":
				return ec.fieldContext_CalendarEvent_chatGroupCreatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CalendarEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userMatchingCalendar_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userMatchingsInTheDay(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userMatchingsInTheDay(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserMatchingsInTheDay(rctx, fc.Args["userId"].(*string), fc.Args["param"].(models.UserMatchingInTheDayParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.MatchingResult)
	fc.Result = res
	return ec.marshalNMatchingResult2ᚕᚖwhaleᚋpkgᚋmodelsᚐMatchingResultᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userMatchingsInTheDay(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingResult_id(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingResult_matchingIds(ctx, field)
			case "motionIds":
				return ec.fieldContext_MatchingResult_motionIds(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingResult_topicId(ctx, field)
			case "userIds":
				return ec.fieldContext_MatchingResult_userIds(ctx, field)
			case "confirmStates":
				return ec.fieldContext_MatchingResult_confirmStates(ctx, field)
			case "userConfirmStates":
				return ec.fieldContext_MatchingResult_userConfirmStates(ctx, field)
			case "chatGroupId":
				return ec.fieldContext_MatchingResult_chatGroupId(ctx, field)
			case "chatGroupState":
				return ec.fieldContext_MatchingResult_chatGroupState(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingResult_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingResult_createdAt(ctx, field)
			case "matchingScore":
				return ec.fieldContext_MatchingResult_matchingScore(ctx, field)
			case "closed":
				return ec.fieldContext_MatchingResult_closed(ctx, field)
			case "finishedAt":
				return ec.fieldContext_MatchingResult_finishedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_MatchingResult_createdBy(ctx, field)
			case "users":
				return ec.fieldContext_MatchingResult_users(ctx, field)
			case "discoverMotion":
				return ec.fieldContext_MatchingResult_discoverMotion(ctx, field)
			case "matchingPreviews":
				return ec.fieldContext_MatchingResult_matchingPreviews(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingResult_topic(ctx, field)
			case "chatGroup":
				return ec.fieldContext_MatchingResult_chatGroup(ctx, field)
			case "matchingDegree":
				return ec.fieldContext_MatchingResult_matchingDegree(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userMatchingsInTheDay_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_matchingResultByChatGroupId(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_matchingResultByChatGroupId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MatchingResultByChatGroupID(rctx, fc.Args["userId"].(*string), fc.Args["chatGroupId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.MatchingResult)
	fc.Result = res
	return ec.marshalNMatchingResult2ᚖwhaleᚋpkgᚋmodelsᚐMatchingResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_matchingResultByChatGroupId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingResult_id(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingResult_matchingIds(ctx, field)
			case "motionIds":
				return ec.fieldContext_MatchingResult_motionIds(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingResult_topicId(ctx, field)
			case "userIds":
				return ec.fieldContext_MatchingResult_userIds(ctx, field)
			case "confirmStates":
				return ec.fieldContext_MatchingResult_confirmStates(ctx, field)
			case "userConfirmStates":
				return ec.fieldContext_MatchingResult_userConfirmStates(ctx, field)
			case "chatGroupId":
				return ec.fieldContext_MatchingResult_chatGroupId(ctx, field)
			case "chatGroupState":
				return ec.fieldContext_MatchingResult_chatGroupState(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingResult_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingResult_createdAt(ctx, field)
			case "matchingScore":
				return ec.fieldContext_MatchingResult_matchingScore(ctx, field)
			case "closed":
				return ec.fieldContext_MatchingResult_closed(ctx, field)
			case "finishedAt":
				return ec.fieldContext_MatchingResult_finishedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_MatchingResult_createdBy(ctx, field)
			case "users":
				return ec.fieldContext_MatchingResult_users(ctx, field)
			case "discoverMotion":
				return ec.fieldContext_MatchingResult_discoverMotion(ctx, field)
			case "matchingPreviews":
				return ec.fieldContext_MatchingResult_matchingPreviews(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingResult_topic(ctx, field)
			case "chatGroup":
				return ec.fieldContext_MatchingResult_chatGroup(ctx, field)
			case "matchingDegree":
				return ec.fieldContext_MatchingResult_matchingDegree(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_matchingResultByChatGroupId_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_matchings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_matchings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Matchings(rctx, fc.Args["filter"].(*models.MatchingFilter), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Matching)
	fc.Result = res
	return ec.marshalNMatching2ᚕᚖwhaleᚋpkgᚋmodelsᚐMatchingᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_matchings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Matching_id(ctx, field)
			case "topicId":
				return ec.fieldContext_Matching_topicId(ctx, field)
			case "userId":
				return ec.fieldContext_Matching_userId(ctx, field)
			case "areaIds":
				return ec.fieldContext_Matching_areaIds(ctx, field)
			case "cityId":
				return ec.fieldContext_Matching_cityId(ctx, field)
			case "gender":
				return ec.fieldContext_Matching_gender(ctx, field)
			case "state":
				return ec.fieldContext_Matching_state(ctx, field)
			case "rejectedUserIds":
				return ec.fieldContext_Matching_rejectedUserIds(ctx, field)
			case "inChatGroup":
				return ec.fieldContext_Matching_inChatGroup(ctx, field)
			case "remark":
				return ec.fieldContext_Matching_remark(ctx, field)
			case "dayRange":
				return ec.fieldContext_Matching_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Matching_preferredPeriods(ctx, field)
			case "properties":
				return ec.fieldContext_Matching_properties(ctx, field)
			case "startMatchingAt":
				return ec.fieldContext_Matching_startMatchingAt(ctx, field)
			case "deadline":
				return ec.fieldContext_Matching_deadline(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Matching_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Matching_createdAt(ctx, field)
			case "matchingResult":
				return ec.fieldContext_Matching_matchingResult(ctx, field)
			case "reviewed":
				return ec.fieldContext_Matching_reviewed(ctx, field)
			case "user":
				return ec.fieldContext_Matching_user(ctx, field)
			case "topic":
				return ec.fieldContext_Matching_topic(ctx, field)
			case "areas":
				return ec.fieldContext_Matching_areas(ctx, field)
			case "city":
				return ec.fieldContext_Matching_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Matching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_matchings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_matchingsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_matchingsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MatchingsCount(rctx, fc.Args["filter"].(*models.MatchingFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2ᚖwhaleᚋpkgᚋmodelsᚐSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_matchingsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_matchingsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_matchingResult(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_matchingResult(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MatchingResult(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.MatchingResult)
	fc.Result = res
	return ec.marshalNMatchingResult2ᚖwhaleᚋpkgᚋmodelsᚐMatchingResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_matchingResult(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingResult_id(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingResult_matchingIds(ctx, field)
			case "motionIds":
				return ec.fieldContext_MatchingResult_motionIds(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingResult_topicId(ctx, field)
			case "userIds":
				return ec.fieldContext_MatchingResult_userIds(ctx, field)
			case "confirmStates":
				return ec.fieldContext_MatchingResult_confirmStates(ctx, field)
			case "userConfirmStates":
				return ec.fieldContext_MatchingResult_userConfirmStates(ctx, field)
			case "chatGroupId":
				return ec.fieldContext_MatchingResult_chatGroupId(ctx, field)
			case "chatGroupState":
				return ec.fieldContext_MatchingResult_chatGroupState(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingResult_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingResult_createdAt(ctx, field)
			case "matchingScore":
				return ec.fieldContext_MatchingResult_matchingScore(ctx, field)
			case "closed":
				return ec.fieldContext_MatchingResult_closed(ctx, field)
			case "finishedAt":
				return ec.fieldContext_MatchingResult_finishedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_MatchingResult_createdBy(ctx, field)
			case "users":
				return ec.fieldContext_MatchingResult_users(ctx, field)
			case "discoverMotion":
				return ec.fieldContext_MatchingResult_discoverMotion(ctx, field)
			case "matchingPreviews":
				return ec.fieldContext_MatchingResult_matchingPreviews(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingResult_topic(ctx, field)
			case "chatGroup":
				return ec.fieldContext_MatchingResult_chatGroup(ctx, field)
			case "matchingDegree":
				return ec.fieldContext_MatchingResult_matchingDegree(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_matchingResult_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_matchingResults(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_matchingResults(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MatchingResults(rctx, fc.Args["filter"].(*models.MatchingResultFilter), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.MatchingResult)
	fc.Result = res
	return ec.marshalNMatchingResult2ᚕᚖwhaleᚋpkgᚋmodelsᚐMatchingResultᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_matchingResults(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingResult_id(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingResult_matchingIds(ctx, field)
			case "motionIds":
				return ec.fieldContext_MatchingResult_motionIds(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingResult_topicId(ctx, field)
			case "userIds":
				return ec.fieldContext_MatchingResult_userIds(ctx, field)
			case "confirmStates":
				return ec.fieldContext_MatchingResult_confirmStates(ctx, field)
			case "userConfirmStates":
				return ec.fieldContext_MatchingResult_userConfirmStates(ctx, field)
			case "chatGroupId":
				return ec.fieldContext_MatchingResult_chatGroupId(ctx, field)
			case "chatGroupState":
				return ec.fieldContext_MatchingResult_chatGroupState(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingResult_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingResult_createdAt(ctx, field)
			case "matchingScore":
				return ec.fieldContext_MatchingResult_matchingScore(ctx, field)
			case "closed":
				return ec.fieldContext_MatchingResult_closed(ctx, field)
			case "finishedAt":
				return ec.fieldContext_MatchingResult_finishedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_MatchingResult_createdBy(ctx, field)
			case "users":
				return ec.fieldContext_MatchingResult_users(ctx, field)
			case "discoverMotion":
				return ec.fieldContext_MatchingResult_discoverMotion(ctx, field)
			case "matchingPreviews":
				return ec.fieldContext_MatchingResult_matchingPreviews(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingResult_topic(ctx, field)
			case "chatGroup":
				return ec.fieldContext_MatchingResult_chatGroup(ctx, field)
			case "matchingDegree":
				return ec.fieldContext_MatchingResult_matchingDegree(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_matchingResults_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_matchingResultsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_matchingResultsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MatchingResultsCount(rctx, fc.Args["filter"].(*models.MatchingResultFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2ᚖwhaleᚋpkgᚋmodelsᚐSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_matchingResultsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_matchingResultsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userMatchings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userMatchings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserMatchings(rctx, fc.Args["userId"].(*string), fc.Args["filter"].(*models.UserMatchingFilter), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Matching)
	fc.Result = res
	return ec.marshalNMatching2ᚕᚖwhaleᚋpkgᚋmodelsᚐMatchingᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userMatchings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Matching_id(ctx, field)
			case "topicId":
				return ec.fieldContext_Matching_topicId(ctx, field)
			case "userId":
				return ec.fieldContext_Matching_userId(ctx, field)
			case "areaIds":
				return ec.fieldContext_Matching_areaIds(ctx, field)
			case "cityId":
				return ec.fieldContext_Matching_cityId(ctx, field)
			case "gender":
				return ec.fieldContext_Matching_gender(ctx, field)
			case "state":
				return ec.fieldContext_Matching_state(ctx, field)
			case "rejectedUserIds":
				return ec.fieldContext_Matching_rejectedUserIds(ctx, field)
			case "inChatGroup":
				return ec.fieldContext_Matching_inChatGroup(ctx, field)
			case "remark":
				return ec.fieldContext_Matching_remark(ctx, field)
			case "dayRange":
				return ec.fieldContext_Matching_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Matching_preferredPeriods(ctx, field)
			case "properties":
				return ec.fieldContext_Matching_properties(ctx, field)
			case "startMatchingAt":
				return ec.fieldContext_Matching_startMatchingAt(ctx, field)
			case "deadline":
				return ec.fieldContext_Matching_deadline(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Matching_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Matching_createdAt(ctx, field)
			case "matchingResult":
				return ec.fieldContext_Matching_matchingResult(ctx, field)
			case "reviewed":
				return ec.fieldContext_Matching_reviewed(ctx, field)
			case "user":
				return ec.fieldContext_Matching_user(ctx, field)
			case "topic":
				return ec.fieldContext_Matching_topic(ctx, field)
			case "areas":
				return ec.fieldContext_Matching_areas(ctx, field)
			case "city":
				return ec.fieldContext_Matching_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Matching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userMatchings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_unconfirmedUserMatchings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_unconfirmedUserMatchings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UnconfirmedUserMatchings(rctx, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Matching)
	fc.Result = res
	return ec.marshalNMatching2ᚕᚖwhaleᚋpkgᚋmodelsᚐMatchingᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_unconfirmedUserMatchings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Matching_id(ctx, field)
			case "topicId":
				return ec.fieldContext_Matching_topicId(ctx, field)
			case "userId":
				return ec.fieldContext_Matching_userId(ctx, field)
			case "areaIds":
				return ec.fieldContext_Matching_areaIds(ctx, field)
			case "cityId":
				return ec.fieldContext_Matching_cityId(ctx, field)
			case "gender":
				return ec.fieldContext_Matching_gender(ctx, field)
			case "state":
				return ec.fieldContext_Matching_state(ctx, field)
			case "rejectedUserIds":
				return ec.fieldContext_Matching_rejectedUserIds(ctx, field)
			case "inChatGroup":
				return ec.fieldContext_Matching_inChatGroup(ctx, field)
			case "remark":
				return ec.fieldContext_Matching_remark(ctx, field)
			case "dayRange":
				return ec.fieldContext_Matching_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Matching_preferredPeriods(ctx, field)
			case "properties":
				return ec.fieldContext_Matching_properties(ctx, field)
			case "startMatchingAt":
				return ec.fieldContext_Matching_startMatchingAt(ctx, field)
			case "deadline":
				return ec.fieldContext_Matching_deadline(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Matching_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Matching_createdAt(ctx, field)
			case "matchingResult":
				return ec.fieldContext_Matching_matchingResult(ctx, field)
			case "reviewed":
				return ec.fieldContext_Matching_reviewed(ctx, field)
			case "user":
				return ec.fieldContext_Matching_user(ctx, field)
			case "topic":
				return ec.fieldContext_Matching_topic(ctx, field)
			case "areas":
				return ec.fieldContext_Matching_areas(ctx, field)
			case "city":
				return ec.fieldContext_Matching_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Matching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_unconfirmedUserMatchings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userMatchingsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userMatchingsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserMatchingsCount(rctx, fc.Args["userId"].(*string), fc.Args["filter"].(*models.UserMatchingFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2ᚖwhaleᚋpkgᚋmodelsᚐSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userMatchingsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userMatchingsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_previewMatchingsOfTopic(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_previewMatchingsOfTopic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PreviewMatchingsOfTopic(rctx, fc.Args["cityId"].(string), fc.Args["topicId"].(string), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Matching)
	fc.Result = res
	return ec.marshalNMatchingOfTopic2ᚕᚖwhaleᚋpkgᚋmodelsᚐMatchingᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_previewMatchingsOfTopic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userId":
				return ec.fieldContext_MatchingOfTopic_userId(ctx, field)
			case "gender":
				return ec.fieldContext_MatchingOfTopic_gender(ctx, field)
			case "remark":
				return ec.fieldContext_MatchingOfTopic_remark(ctx, field)
			case "areaIds":
				return ec.fieldContext_MatchingOfTopic_areaIds(ctx, field)
			case "cityId":
				return ec.fieldContext_MatchingOfTopic_cityId(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingOfTopic_createdAt(ctx, field)
			case "user":
				return ec.fieldContext_MatchingOfTopic_user(ctx, field)
			case "city":
				return ec.fieldContext_MatchingOfTopic_city(ctx, field)
			case "areas":
				return ec.fieldContext_MatchingOfTopic_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingOfTopic", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_previewMatchingsOfTopic_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_unconfirmedInvitations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_unconfirmedInvitations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UnconfirmedInvitations(rctx, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.MatchingInvitation)
	fc.Result = res
	return ec.marshalOMatchingInvitation2ᚕᚖwhaleᚋpkgᚋmodelsᚐMatchingInvitationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_unconfirmedInvitations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingInvitation_id(ctx, field)
			case "userId":
				return ec.fieldContext_MatchingInvitation_userId(ctx, field)
			case "inviteeId":
				return ec.fieldContext_MatchingInvitation_inviteeId(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingInvitation_topicId(ctx, field)
			case "remark":
				return ec.fieldContext_MatchingInvitation_remark(ctx, field)
			case "cityId":
				return ec.fieldContext_MatchingInvitation_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_MatchingInvitation_areaIds(ctx, field)
			case "matchingResultId":
				return ec.fieldContext_MatchingInvitation_matchingResultId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingInvitation_matchingIds(ctx, field)
			case "confirmState":
				return ec.fieldContext_MatchingInvitation_confirmState(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_MatchingInvitation_confirmedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingInvitation_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingInvitation_updatedAt(ctx, field)
			case "invitee":
				return ec.fieldContext_MatchingInvitation_invitee(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingInvitation_topic(ctx, field)
			case "areas":
				return ec.fieldContext_MatchingInvitation_areas(ctx, field)
			case "city":
				return ec.fieldContext_MatchingInvitation_city(ctx, field)
			case "user":
				return ec.fieldContext_MatchingInvitation_user(ctx, field)
			case "matchingResult":
				return ec.fieldContext_MatchingInvitation_matchingResult(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingInvitation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_unconfirmedInvitations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_unconfirmedInvitationCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_unconfirmedInvitationCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UnconfirmedInvitationCount(rctx, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2ᚖwhaleᚋpkgᚋmodelsᚐSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_unconfirmedInvitationCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_unconfirmedInvitationCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_recentMatchings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_recentMatchings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RecentMatchings(rctx, fc.Args["filter"].(*models.RecentMatchingFilter), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.RecentMatching)
	fc.Result = res
	return ec.marshalNRecentMatching2ᚕᚖwhaleᚋpkgᚋmodelsᚐRecentMatchingᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_recentMatchings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RecentMatching_id(ctx, field)
			case "cityId":
				return ec.fieldContext_RecentMatching_cityId(ctx, field)
			case "topicId":
				return ec.fieldContext_RecentMatching_topicId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_RecentMatching_matchingIds(ctx, field)
			case "createdAt":
				return ec.fieldContext_RecentMatching_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_RecentMatching_updatedAt(ctx, field)
			case "topic":
				return ec.fieldContext_RecentMatching_topic(ctx, field)
			case "city":
				return ec.fieldContext_RecentMatching_city(ctx, field)
			case "matchings":
				return ec.fieldContext_RecentMatching_matchings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RecentMatching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_recentMatchings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_recentMatchingsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_recentMatchingsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RecentMatchingsCount(rctx, fc.Args["filter"].(*models.RecentMatchingFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2ᚖwhaleᚋpkgᚋmodelsᚐSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_recentMatchingsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_recentMatchingsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_recentMatching(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_recentMatching(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RecentMatching(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.RecentMatching)
	fc.Result = res
	return ec.marshalNRecentMatching2ᚖwhaleᚋpkgᚋmodelsᚐRecentMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_recentMatching(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RecentMatching_id(ctx, field)
			case "cityId":
				return ec.fieldContext_RecentMatching_cityId(ctx, field)
			case "topicId":
				return ec.fieldContext_RecentMatching_topicId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_RecentMatching_matchingIds(ctx, field)
			case "createdAt":
				return ec.fieldContext_RecentMatching_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_RecentMatching_updatedAt(ctx, field)
			case "topic":
				return ec.fieldContext_RecentMatching_topic(ctx, field)
			case "city":
				return ec.fieldContext_RecentMatching_city(ctx, field)
			case "matchings":
				return ec.fieldContext_RecentMatching_matchings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RecentMatching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_recentMatching_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_topicDistribution(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_topicDistribution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TopicDistribution(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.TopicToMatching)
	fc.Result = res
	return ec.marshalNTopicToMatching2ᚕᚖwhaleᚋpkgᚋmodelsᚐTopicToMatchingᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_topicDistribution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "topicId":
				return ec.fieldContext_TopicToMatching_topicId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_TopicToMatching_matchingIds(ctx, field)
			case "topic":
				return ec.fieldContext_TopicToMatching_topic(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TopicToMatching", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_cityDistribution(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cityDistribution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CityDistribution(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.CityToTopicMatching)
	fc.Result = res
	return ec.marshalNCityToTopicMatching2ᚕᚖwhaleᚋpkgᚋmodelsᚐCityToTopicMatchingᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cityDistribution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cityId":
				return ec.fieldContext_CityToTopicMatching_cityId(ctx, field)
			case "topics":
				return ec.fieldContext_CityToTopicMatching_topics(ctx, field)
			case "city":
				return ec.fieldContext_CityToTopicMatching_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CityToTopicMatching", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_matchingDurationConstraints(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_matchingDurationConstraints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MatchingDurationConstraints(rctx, fc.Args["userId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.MatchingDurationConstraint)
	fc.Result = res
	return ec.marshalNMatchingDurationConstraint2ᚖwhaleᚋpkgᚋmodelsᚐMatchingDurationConstraint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_matchingDurationConstraints(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startDate":
				return ec.fieldContext_MatchingDurationConstraint_startDate(ctx, field)
			case "stopDate":
				return ec.fieldContext_MatchingDurationConstraint_stopDate(ctx, field)
			case "total":
				return ec.fieldContext_MatchingDurationConstraint_total(ctx, field)
			case "remain":
				return ec.fieldContext_MatchingDurationConstraint_remain(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingDurationConstraint_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingDurationConstraint", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_matchingDurationConstraints_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_discoverCategoryMotions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_discoverCategoryMotions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DiscoverCategoryMotions(rctx, fc.Args["userId"].(*string), fc.Args["filter"].(*models.DiscoverTopicCategoryMotionFilter), fc.Args["topicCategoryId"].(string), fc.Args["nextToken"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.DiscoverMotionResult)
	fc.Result = res
	return ec.marshalNDiscoverMotionResult2ᚖwhaleᚋpkgᚋmodelsᚐDiscoverMotionResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_discoverCategoryMotions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "motions":
				return ec.fieldContext_DiscoverMotionResult_motions(ctx, field)
			case "nextToken":
				return ec.fieldContext_DiscoverMotionResult_nextToken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscoverMotionResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_discoverCategoryMotions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_discoverLatestCategoryMotions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_discoverLatestCategoryMotions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DiscoverLatestCategoryMotions(rctx, fc.Args["filter"].(models.DiscoverTopicCategoryMotionFilter), fc.Args["topicCategoryId"].(string), fc.Args["lastId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Motion)
	fc.Result = res
	return ec.marshalNDiscoverMotion2ᚕᚖwhaleᚋpkgᚋmodelsᚐMotionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_discoverLatestCategoryMotions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscoverMotion_id(ctx, field)
			case "userId":
				return ec.fieldContext_DiscoverMotion_userId(ctx, field)
			case "topicId":
				return ec.fieldContext_DiscoverMotion_topicId(ctx, field)
			case "properties":
				return ec.fieldContext_DiscoverMotion_properties(ctx, field)
			case "cityId":
				return ec.fieldContext_DiscoverMotion_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_DiscoverMotion_areaIds(ctx, field)
			case "gender":
				return ec.fieldContext_DiscoverMotion_gender(ctx, field)
			case "dayRange":
				return ec.fieldContext_DiscoverMotion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_DiscoverMotion_preferredPeriods(ctx, field)
			case "remark":
				return ec.fieldContext_DiscoverMotion_remark(ctx, field)
			case "likeCount":
				return ec.fieldContext_DiscoverMotion_likeCount(ctx, field)
			case "viewCount":
				return ec.fieldContext_DiscoverMotion_viewCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_DiscoverMotion_thumbsUpCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_DiscoverMotion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_DiscoverMotion_liked(ctx, field)
			case "submitted":
				return ec.fieldContext_DiscoverMotion_submitted(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_DiscoverMotion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_DiscoverMotion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_DiscoverMotion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_DiscoverMotion_user(ctx, field)
			case "city":
				return ec.fieldContext_DiscoverMotion_city(ctx, field)
			case "areas":
				return ec.fieldContext_DiscoverMotion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscoverMotion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_discoverLatestCategoryMotions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getDiscoverMotion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getDiscoverMotion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetDiscoverMotion(rctx, fc.Args["motionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Motion)
	fc.Result = res
	return ec.marshalNDiscoverMotion2ᚖwhaleᚋpkgᚋmodelsᚐMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getDiscoverMotion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscoverMotion_id(ctx, field)
			case "userId":
				return ec.fieldContext_DiscoverMotion_userId(ctx, field)
			case "topicId":
				return ec.fieldContext_DiscoverMotion_topicId(ctx, field)
			case "properties":
				return ec.fieldContext_DiscoverMotion_properties(ctx, field)
			case "cityId":
				return ec.fieldContext_DiscoverMotion_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_DiscoverMotion_areaIds(ctx, field)
			case "gender":
				return ec.fieldContext_DiscoverMotion_gender(ctx, field)
			case "dayRange":
				return ec.fieldContext_DiscoverMotion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_DiscoverMotion_preferredPeriods(ctx, field)
			case "remark":
				return ec.fieldContext_DiscoverMotion_remark(ctx, field)
			case "likeCount":
				return ec.fieldContext_DiscoverMotion_likeCount(ctx, field)
			case "viewCount":
				return ec.fieldContext_DiscoverMotion_viewCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_DiscoverMotion_thumbsUpCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_DiscoverMotion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_DiscoverMotion_liked(ctx, field)
			case "submitted":
				return ec.fieldContext_DiscoverMotion_submitted(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_DiscoverMotion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_DiscoverMotion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_DiscoverMotion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_DiscoverMotion_user(ctx, field)
			case "city":
				return ec.fieldContext_DiscoverMotion_city(ctx, field)
			case "areas":
				return ec.fieldContext_DiscoverMotion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscoverMotion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getDiscoverMotion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_outMotionOffers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_outMotionOffers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().OutMotionOffers(rctx, fc.Args["motionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.MotionOfferRecord)
	fc.Result = res
	return ec.marshalNMotionOfferRecord2ᚕᚖwhaleᚋpkgᚋmodelsᚐMotionOfferRecordᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_outMotionOffers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MotionOfferRecord_id(ctx, field)
			case "toMotionId":
				return ec.fieldContext_MotionOfferRecord_toMotionId(ctx, field)
			case "motionId":
				return ec.fieldContext_MotionOfferRecord_motionId(ctx, field)
			case "state":
				return ec.fieldContext_MotionOfferRecord_state(ctx, field)
			case "createdAt":
				return ec.fieldContext_MotionOfferRecord_createdAt(ctx, field)
			case "reactAt":
				return ec.fieldContext_MotionOfferRecord_reactAt(ctx, field)
			case "remark":
				return ec.fieldContext_MotionOfferRecord_remark(ctx, field)
			case "chatChance":
				return ec.fieldContext_MotionOfferRecord_chatChance(ctx, field)
			case "reviewed":
				return ec.fieldContext_MotionOfferRecord_reviewed(ctx, field)
			case "toMotion":
				return ec.fieldContext_MotionOfferRecord_toMotion(ctx, field)
			case "motion":
				return ec.fieldContext_MotionOfferRecord_motion(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MotionOfferRecord", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_outMotionOffers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_inMotionOffers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_inMotionOffers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().InMotionOffers(rctx, fc.Args["motionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.MotionOfferRecord)
	fc.Result = res
	return ec.marshalNMotionOfferRecord2ᚕᚖwhaleᚋpkgᚋmodelsᚐMotionOfferRecordᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_inMotionOffers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MotionOfferRecord_id(ctx, field)
			case "toMotionId":
				return ec.fieldContext_MotionOfferRecord_toMotionId(ctx, field)
			case "motionId":
				return ec.fieldContext_MotionOfferRecord_motionId(ctx, field)
			case "state":
				return ec.fieldContext_MotionOfferRecord_state(ctx, field)
			case "createdAt":
				return ec.fieldContext_MotionOfferRecord_createdAt(ctx, field)
			case "reactAt":
				return ec.fieldContext_MotionOfferRecord_reactAt(ctx, field)
			case "remark":
				return ec.fieldContext_MotionOfferRecord_remark(ctx, field)
			case "chatChance":
				return ec.fieldContext_MotionOfferRecord_chatChance(ctx, field)
			case "reviewed":
				return ec.fieldContext_MotionOfferRecord_reviewed(ctx, field)
			case "toMotion":
				return ec.fieldContext_MotionOfferRecord_toMotion(ctx, field)
			case "motion":
				return ec.fieldContext_MotionOfferRecord_motion(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MotionOfferRecord", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_inMotionOffers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMotionOffer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMotionOffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMotionOffer(rctx, fc.Args["motionId"].(string), fc.Args["toMotionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.MotionOfferRecord)
	fc.Result = res
	return ec.marshalNMotionOfferRecord2ᚖwhaleᚋpkgᚋmodelsᚐMotionOfferRecord(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMotionOffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MotionOfferRecord_id(ctx, field)
			case "toMotionId":
				return ec.fieldContext_MotionOfferRecord_toMotionId(ctx, field)
			case "motionId":
				return ec.fieldContext_MotionOfferRecord_motionId(ctx, field)
			case "state":
				return ec.fieldContext_MotionOfferRecord_state(ctx, field)
			case "createdAt":
				return ec.fieldContext_MotionOfferRecord_createdAt(ctx, field)
			case "reactAt":
				return ec.fieldContext_MotionOfferRecord_reactAt(ctx, field)
			case "remark":
				return ec.fieldContext_MotionOfferRecord_remark(ctx, field)
			case "chatChance":
				return ec.fieldContext_MotionOfferRecord_chatChance(ctx, field)
			case "reviewed":
				return ec.fieldContext_MotionOfferRecord_reviewed(ctx, field)
			case "toMotion":
				return ec.fieldContext_MotionOfferRecord_toMotion(ctx, field)
			case "motion":
				return ec.fieldContext_MotionOfferRecord_motion(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MotionOfferRecord", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMotionOffer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_motion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_motion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Motion(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Motion)
	fc.Result = res
	return ec.marshalNMotion2ᚖwhaleᚋpkgᚋmodelsᚐMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_motion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Motion_id(ctx, field)
			case "userId":
				return ec.fieldContext_Motion_userId(ctx, field)
			case "cityId":
				return ec.fieldContext_Motion_cityId(ctx, field)
			case "remark":
				return ec.fieldContext_Motion_remark(ctx, field)
			case "active":
				return ec.fieldContext_Motion_active(ctx, field)
			case "inOfferNum":
				return ec.fieldContext_Motion_inOfferNum(ctx, field)
			case "outOfferNum":
				return ec.fieldContext_Motion_outOfferNum(ctx, field)
			case "pendingInNum":
				return ec.fieldContext_Motion_pendingInNum(ctx, field)
			case "pendingOutNum":
				return ec.fieldContext_Motion_pendingOutNum(ctx, field)
			case "activeNum":
				return ec.fieldContext_Motion_activeNum(ctx, field)
			case "discoverable":
				return ec.fieldContext_Motion_discoverable(ctx, field)
			case "relatedMatchingId":
				return ec.fieldContext_Motion_relatedMatchingId(ctx, field)
			case "properties":
				return ec.fieldContext_Motion_properties(ctx, field)
			case "dayRange":
				return ec.fieldContext_Motion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Motion_preferredPeriods(ctx, field)
			case "gender":
				return ec.fieldContext_Motion_gender(ctx, field)
			case "createdAt":
				return ec.fieldContext_Motion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_Motion_liked(ctx, field)
			case "viewCount":
				return ec.fieldContext_Motion_viewCount(ctx, field)
			case "likeCount":
				return ec.fieldContext_Motion_likeCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_Motion_thumbsUpCount(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_Motion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_Motion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_Motion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_Motion_user(ctx, field)
			case "city":
				return ec.fieldContext_Motion_city(ctx, field)
			case "areas":
				return ec.fieldContext_Motion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Motion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_motion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userMotions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userMotions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserMotions(rctx, fc.Args["userId"].(*string), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Motion)
	fc.Result = res
	return ec.marshalNMotion2ᚕᚖwhaleᚋpkgᚋmodelsᚐMotionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userMotions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Motion_id(ctx, field)
			case "userId":
				return ec.fieldContext_Motion_userId(ctx, field)
			case "cityId":
				return ec.fieldContext_Motion_cityId(ctx, field)
			case "remark":
				return ec.fieldContext_Motion_remark(ctx, field)
			case "active":
				return ec.fieldContext_Motion_active(ctx, field)
			case "inOfferNum":
				return ec.fieldContext_Motion_inOfferNum(ctx, field)
			case "outOfferNum":
				return ec.fieldContext_Motion_outOfferNum(ctx, field)
			case "pendingInNum":
				return ec.fieldContext_Motion_pendingInNum(ctx, field)
			case "pendingOutNum":
				return ec.fieldContext_Motion_pendingOutNum(ctx, field)
			case "activeNum":
				return ec.fieldContext_Motion_activeNum(ctx, field)
			case "discoverable":
				return ec.fieldContext_Motion_discoverable(ctx, field)
			case "relatedMatchingId":
				return ec.fieldContext_Motion_relatedMatchingId(ctx, field)
			case "properties":
				return ec.fieldContext_Motion_properties(ctx, field)
			case "dayRange":
				return ec.fieldContext_Motion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Motion_preferredPeriods(ctx, field)
			case "gender":
				return ec.fieldContext_Motion_gender(ctx, field)
			case "createdAt":
				return ec.fieldContext_Motion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_Motion_liked(ctx, field)
			case "viewCount":
				return ec.fieldContext_Motion_viewCount(ctx, field)
			case "likeCount":
				return ec.fieldContext_Motion_likeCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_Motion_thumbsUpCount(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_Motion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_Motion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_Motion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_Motion_user(ctx, field)
			case "city":
				return ec.fieldContext_Motion_city(ctx, field)
			case "areas":
				return ec.fieldContext_Motion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Motion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userMotions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userMotionsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userMotionsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserMotionsCount(rctx, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2ᚖwhaleᚋpkgᚋmodelsᚐSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userMotionsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userMotionsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_activeMotions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_activeMotions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ActiveMotions(rctx, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Motion)
	fc.Result = res
	return ec.marshalNMotion2ᚕᚖwhaleᚋpkgᚋmodelsᚐMotionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_activeMotions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Motion_id(ctx, field)
			case "userId":
				return ec.fieldContext_Motion_userId(ctx, field)
			case "cityId":
				return ec.fieldContext_Motion_cityId(ctx, field)
			case "remark":
				return ec.fieldContext_Motion_remark(ctx, field)
			case "active":
				return ec.fieldContext_Motion_active(ctx, field)
			case "inOfferNum":
				return ec.fieldContext_Motion_inOfferNum(ctx, field)
			case "outOfferNum":
				return ec.fieldContext_Motion_outOfferNum(ctx, field)
			case "pendingInNum":
				return ec.fieldContext_Motion_pendingInNum(ctx, field)
			case "pendingOutNum":
				return ec.fieldContext_Motion_pendingOutNum(ctx, field)
			case "activeNum":
				return ec.fieldContext_Motion_activeNum(ctx, field)
			case "discoverable":
				return ec.fieldContext_Motion_discoverable(ctx, field)
			case "relatedMatchingId":
				return ec.fieldContext_Motion_relatedMatchingId(ctx, field)
			case "properties":
				return ec.fieldContext_Motion_properties(ctx, field)
			case "dayRange":
				return ec.fieldContext_Motion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Motion_preferredPeriods(ctx, field)
			case "gender":
				return ec.fieldContext_Motion_gender(ctx, field)
			case "createdAt":
				return ec.fieldContext_Motion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_Motion_liked(ctx, field)
			case "viewCount":
				return ec.fieldContext_Motion_viewCount(ctx, field)
			case "likeCount":
				return ec.fieldContext_Motion_likeCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_Motion_thumbsUpCount(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_Motion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_Motion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_Motion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_Motion_user(ctx, field)
			case "city":
				return ec.fieldContext_Motion_city(ctx, field)
			case "areas":
				return ec.fieldContext_Motion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Motion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_activeMotions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_motions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_motions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Motions(rctx, fc.Args["filter"].(*models.MotionFilter), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Motion)
	fc.Result = res
	return ec.marshalNMotion2ᚕᚖwhaleᚋpkgᚋmodelsᚐMotionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_motions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Motion_id(ctx, field)
			case "userId":
				return ec.fieldContext_Motion_userId(ctx, field)
			case "cityId":
				return ec.fieldContext_Motion_cityId(ctx, field)
			case "remark":
				return ec.fieldContext_Motion_remark(ctx, field)
			case "active":
				return ec.fieldContext_Motion_active(ctx, field)
			case "inOfferNum":
				return ec.fieldContext_Motion_inOfferNum(ctx, field)
			case "outOfferNum":
				return ec.fieldContext_Motion_outOfferNum(ctx, field)
			case "pendingInNum":
				return ec.fieldContext_Motion_pendingInNum(ctx, field)
			case "pendingOutNum":
				return ec.fieldContext_Motion_pendingOutNum(ctx, field)
			case "activeNum":
				return ec.fieldContext_Motion_activeNum(ctx, field)
			case "discoverable":
				return ec.fieldContext_Motion_discoverable(ctx, field)
			case "relatedMatchingId":
				return ec.fieldContext_Motion_relatedMatchingId(ctx, field)
			case "properties":
				return ec.fieldContext_Motion_properties(ctx, field)
			case "dayRange":
				return ec.fieldContext_Motion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Motion_preferredPeriods(ctx, field)
			case "gender":
				return ec.fieldContext_Motion_gender(ctx, field)
			case "createdAt":
				return ec.fieldContext_Motion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_Motion_liked(ctx, field)
			case "viewCount":
				return ec.fieldContext_Motion_viewCount(ctx, field)
			case "likeCount":
				return ec.fieldContext_Motion_likeCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_Motion_thumbsUpCount(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_Motion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_Motion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_Motion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_Motion_user(ctx, field)
			case "city":
				return ec.fieldContext_Motion_city(ctx, field)
			case "areas":
				return ec.fieldContext_Motion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Motion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_motions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_motionsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_motionsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MotionsCount(rctx, fc.Args["filter"].(*models.MotionFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2ᚖwhaleᚋpkgᚋmodelsᚐSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_motionsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_motionsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_cityTopics(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cityTopics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CityTopics(rctx, fc.Args["cityId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.CityTopics)
	fc.Result = res
	return ec.marshalNCityTopics2ᚖwhaleᚋpkgᚋmodelsᚐCityTopics(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cityTopics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cityId":
				return ec.fieldContext_CityTopics_cityId(ctx, field)
			case "topicIds":
				return ec.fieldContext_CityTopics_topicIds(ctx, field)
			case "updatedAt":
				return ec.fieldContext_CityTopics_updatedAt(ctx, field)
			case "topics":
				return ec.fieldContext_CityTopics_topics(ctx, field)
			case "city":
				return ec.fieldContext_CityTopics_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CityTopics", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cityTopics_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_citiesTopics(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_citiesTopics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CitiesTopics(rctx, fc.Args["filter"].(*models.CitiesTopicsFilter), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.CityTopics)
	fc.Result = res
	return ec.marshalNCityTopics2ᚕᚖwhaleᚋpkgᚋmodelsᚐCityTopicsᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_citiesTopics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cityId":
				return ec.fieldContext_CityTopics_cityId(ctx, field)
			case "topicIds":
				return ec.fieldContext_CityTopics_topicIds(ctx, field)
			case "updatedAt":
				return ec.fieldContext_CityTopics_updatedAt(ctx, field)
			case "topics":
				return ec.fieldContext_CityTopics_topics(ctx, field)
			case "city":
				return ec.fieldContext_CityTopics_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CityTopics", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_citiesTopics_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_citiesTopicsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_citiesTopicsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CitiesTopicsCount(rctx, fc.Args["filter"].(*models.CitiesTopicsFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2ᚖwhaleᚋpkgᚋmodelsᚐSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_citiesTopicsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_citiesTopicsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_hotTopicsInArea(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_hotTopicsInArea(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().HotTopicsInArea(rctx, fc.Args["cityId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.HotTopicsInArea)
	fc.Result = res
	return ec.marshalNHotTopicsInArea2ᚖwhaleᚋpkgᚋmodelsᚐHotTopicsInArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_hotTopicsInArea(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cityId":
				return ec.fieldContext_HotTopicsInArea_cityId(ctx, field)
			case "updatedAt":
				return ec.fieldContext_HotTopicsInArea_updatedAt(ctx, field)
			case "topicMetrics":
				return ec.fieldContext_HotTopicsInArea_topicMetrics(ctx, field)
			case "city":
				return ec.fieldContext_HotTopicsInArea_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HotTopicsInArea", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_hotTopicsInArea_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_hotTopics(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_hotTopics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().HotTopics(rctx, fc.Args["filter"].(*models.HotTopicsFilter), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.HotTopicsInArea)
	fc.Result = res
	return ec.marshalNHotTopicsInArea2ᚕᚖwhaleᚋpkgᚋmodelsᚐHotTopicsInAreaᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_hotTopics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cityId":
				return ec.fieldContext_HotTopicsInArea_cityId(ctx, field)
			case "updatedAt":
				return ec.fieldContext_HotTopicsInArea_updatedAt(ctx, field)
			case "topicMetrics":
				return ec.fieldContext_HotTopicsInArea_topicMetrics(ctx, field)
			case "city":
				return ec.fieldContext_HotTopicsInArea_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HotTopicsInArea", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_hotTopics_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_hotTopicsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_hotTopicsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().HotTopicsCount(rctx, fc.Args["filter"].(*models.HotTopicsFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2ᚖwhaleᚋpkgᚋmodelsᚐSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_hotTopicsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_hotTopicsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userJoinTopics(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userJoinTopics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserJoinTopics(rctx, fc.Args["filter"].(*models.UserJoinTopicFilter), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.UserJoinTopic)
	fc.Result = res
	return ec.marshalNUserJoinTopic2ᚕᚖwhaleᚋpkgᚋmodelsᚐUserJoinTopicᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userJoinTopics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserJoinTopic_id(ctx, field)
			case "topicId":
				return ec.fieldContext_UserJoinTopic_topicId(ctx, field)
			case "cityId":
				return ec.fieldContext_UserJoinTopic_cityId(ctx, field)
			case "userId":
				return ec.fieldContext_UserJoinTopic_userId(ctx, field)
			case "latestMatchingId":
				return ec.fieldContext_UserJoinTopic_latestMatchingId(ctx, field)
			case "createdAt":
				return ec.fieldContext_UserJoinTopic_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_UserJoinTopic_updatedAt(ctx, field)
			case "topic":
				return ec.fieldContext_UserJoinTopic_topic(ctx, field)
			case "city":
				return ec.fieldContext_UserJoinTopic_city(ctx, field)
			case "user":
				return ec.fieldContext_UserJoinTopic_user(ctx, field)
			case "matching":
				return ec.fieldContext_UserJoinTopic_matching(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserJoinTopic", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userJoinTopics_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userJoinTopicsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userJoinTopicsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserJoinTopicsCount(rctx, fc.Args["filter"].(*models.UserJoinTopicFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2ᚖwhaleᚋpkgᚋmodelsᚐSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userJoinTopicsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userJoinTopicsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userJoinTopic(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userJoinTopic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserJoinTopic(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.UserJoinTopic)
	fc.Result = res
	return ec.marshalNUserJoinTopic2ᚖwhaleᚋpkgᚋmodelsᚐUserJoinTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userJoinTopic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserJoinTopic_id(ctx, field)
			case "topicId":
				return ec.fieldContext_UserJoinTopic_topicId(ctx, field)
			case "cityId":
				return ec.fieldContext_UserJoinTopic_cityId(ctx, field)
			case "userId":
				return ec.fieldContext_UserJoinTopic_userId(ctx, field)
			case "latestMatchingId":
				return ec.fieldContext_UserJoinTopic_latestMatchingId(ctx, field)
			case "createdAt":
				return ec.fieldContext_UserJoinTopic_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_UserJoinTopic_updatedAt(ctx, field)
			case "topic":
				return ec.fieldContext_UserJoinTopic_topic(ctx, field)
			case "city":
				return ec.fieldContext_UserJoinTopic_city(ctx, field)
			case "user":
				return ec.fieldContext_UserJoinTopic_user(ctx, field)
			case "matching":
				return ec.fieldContext_UserJoinTopic_matching(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserJoinTopic", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userJoinTopic_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_likedMotions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_likedMotions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().LikedMotions(rctx, fc.Args["userId"].(*string), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.UserLikeMotion)
	fc.Result = res
	return ec.marshalNUserLikeMotion2ᚕᚖwhaleᚋpkgᚋmodelsᚐUserLikeMotionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_likedMotions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "toMotionId":
				return ec.fieldContext_UserLikeMotion_toMotionId(ctx, field)
			case "toUserId":
				return ec.fieldContext_UserLikeMotion_toUserId(ctx, field)
			case "userId":
				return ec.fieldContext_UserLikeMotion_userId(ctx, field)
			case "createdAt":
				return ec.fieldContext_UserLikeMotion_createdAt(ctx, field)
			case "motion":
				return ec.fieldContext_UserLikeMotion_motion(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserLikeMotion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_likedMotions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_likedMotionsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_likedMotionsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().LikedMotionsCount(rctx, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2ᚖwhaleᚋpkgᚋmodelsᚐSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_likedMotionsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_likedMotionsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query__entities(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query__entities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.__resolve_entities(ctx, fc.Args["representations"].([]map[string]interface{})), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]fedruntime.Entity)
	fc.Result = res
	return ec.marshalN_Entity2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋpluginᚋfederationᚋfedruntimeᚐEntity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query__entities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type _Entity does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query__entities_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query__service(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query__service(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.__resolve__service(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(fedruntime.Service)
	fc.Result = res
	return ec.marshalN_Service2githubᚗcomᚋ99designsᚋgqlgenᚋpluginᚋfederationᚋfedruntimeᚐService(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query__service(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sdl":
				return ec.fieldContext__Service_sdl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type _Service", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecentMatching_id(ctx context.Context, field graphql.CollectedField, obj *models.RecentMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecentMatching_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecentMatching_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecentMatching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecentMatching_cityId(ctx context.Context, field graphql.CollectedField, obj *models.RecentMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecentMatching_cityId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecentMatching_cityId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecentMatching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecentMatching_topicId(ctx context.Context, field graphql.CollectedField, obj *models.RecentMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecentMatching_topicId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecentMatching_topicId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecentMatching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecentMatching_matchingIds(ctx context.Context, field graphql.CollectedField, obj *models.RecentMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecentMatching_matchingIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchingIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecentMatching_matchingIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecentMatching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecentMatching_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.RecentMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecentMatching_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecentMatching_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecentMatching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecentMatching_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.RecentMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecentMatching_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecentMatching_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecentMatching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecentMatching_topic(ctx context.Context, field graphql.CollectedField, obj *models.RecentMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecentMatching_topic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RecentMatching().Topic(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Topic)
	fc.Result = res
	return ec.marshalNTopic2ᚖwhaleᚋpkgᚋmodelsᚐTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecentMatching_topic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecentMatching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Topic_id(ctx, field)
			case "recentUsers":
				return ec.fieldContext_Topic_recentUsers(ctx, field)
			case "matchingNum":
				return ec.fieldContext_Topic_matchingNum(ctx, field)
			case "fuzzyMatchingNum":
				return ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Topic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecentMatching_city(ctx context.Context, field graphql.CollectedField, obj *models.RecentMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecentMatching_city(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RecentMatching().City(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Area)
	fc.Result = res
	return ec.marshalNArea2ᚖwhaleᚋpkgᚋmodelsᚐArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecentMatching_city(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecentMatching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecentMatching_matchings(ctx context.Context, field graphql.CollectedField, obj *models.RecentMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecentMatching_matchings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RecentMatching().Matchings(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Matching)
	fc.Result = res
	return ec.marshalNMatching2ᚕᚖwhaleᚋpkgᚋmodelsᚐMatchingᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecentMatching_matchings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecentMatching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Matching_id(ctx, field)
			case "topicId":
				return ec.fieldContext_Matching_topicId(ctx, field)
			case "userId":
				return ec.fieldContext_Matching_userId(ctx, field)
			case "areaIds":
				return ec.fieldContext_Matching_areaIds(ctx, field)
			case "cityId":
				return ec.fieldContext_Matching_cityId(ctx, field)
			case "gender":
				return ec.fieldContext_Matching_gender(ctx, field)
			case "state":
				return ec.fieldContext_Matching_state(ctx, field)
			case "rejectedUserIds":
				return ec.fieldContext_Matching_rejectedUserIds(ctx, field)
			case "inChatGroup":
				return ec.fieldContext_Matching_inChatGroup(ctx, field)
			case "remark":
				return ec.fieldContext_Matching_remark(ctx, field)
			case "dayRange":
				return ec.fieldContext_Matching_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Matching_preferredPeriods(ctx, field)
			case "properties":
				return ec.fieldContext_Matching_properties(ctx, field)
			case "startMatchingAt":
				return ec.fieldContext_Matching_startMatchingAt(ctx, field)
			case "deadline":
				return ec.fieldContext_Matching_deadline(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Matching_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Matching_createdAt(ctx, field)
			case "matchingResult":
				return ec.fieldContext_Matching_matchingResult(ctx, field)
			case "reviewed":
				return ec.fieldContext_Matching_reviewed(ctx, field)
			case "user":
				return ec.fieldContext_Matching_user(ctx, field)
			case "topic":
				return ec.fieldContext_Matching_topic(ctx, field)
			case "areas":
				return ec.fieldContext_Matching_areas(ctx, field)
			case "city":
				return ec.fieldContext_Matching_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Matching", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SimpleAvatarUser_avatar(ctx context.Context, field graphql.CollectedField, obj *models.SimpleAvatarUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SimpleAvatarUser_avatar(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avatar, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SimpleAvatarUser_avatar(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SimpleAvatarUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SimpleAvatarUser_nickname(ctx context.Context, field graphql.CollectedField, obj *models.SimpleAvatarUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SimpleAvatarUser_nickname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nickname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SimpleAvatarUser_nickname(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SimpleAvatarUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Summary_count(ctx context.Context, field graphql.CollectedField, obj *models.Summary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Summary_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Summary_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Summary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Topic_id(ctx context.Context, field graphql.CollectedField, obj *models.Topic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Topic_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Topic_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Topic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Topic_recentUsers(ctx context.Context, field graphql.CollectedField, obj *models.Topic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Topic_recentUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Topic().RecentUsers(rctx, obj, fc.Args["cityId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.SimpleAvatarUser)
	fc.Result = res
	return ec.marshalNSimpleAvatarUser2ᚕᚖwhaleᚋpkgᚋmodelsᚐSimpleAvatarUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Topic_recentUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Topic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "avatar":
				return ec.fieldContext_SimpleAvatarUser_avatar(ctx, field)
			case "nickname":
				return ec.fieldContext_SimpleAvatarUser_nickname(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SimpleAvatarUser", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Topic_recentUsers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Topic_matchingNum(ctx context.Context, field graphql.CollectedField, obj *models.Topic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Topic_matchingNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Topic().MatchingNum(rctx, obj, fc.Args["cityId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Topic_matchingNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Topic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Topic_matchingNum_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Topic_fuzzyMatchingNum(ctx context.Context, field graphql.CollectedField, obj *models.Topic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Topic().FuzzyMatchingNum(rctx, obj, fc.Args["cityId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Topic_fuzzyMatchingNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Topic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Topic_fuzzyMatchingNum_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TopicMetrics_id(ctx context.Context, field graphql.CollectedField, obj *models.TopicMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopicMetrics_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopicMetrics_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopicMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopicMetrics_matched(ctx context.Context, field graphql.CollectedField, obj *models.TopicMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopicMetrics_matched(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Matched, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopicMetrics_matched(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopicMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopicMetrics_matching(ctx context.Context, field graphql.CollectedField, obj *models.TopicMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopicMetrics_matching(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Matching, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopicMetrics_matching(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopicMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopicMetrics_heat(ctx context.Context, field graphql.CollectedField, obj *models.TopicMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopicMetrics_heat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Heat, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopicMetrics_heat(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopicMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopicMetrics_topic(ctx context.Context, field graphql.CollectedField, obj *models.TopicMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopicMetrics_topic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TopicMetrics().Topic(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Topic)
	fc.Result = res
	return ec.marshalNTopic2ᚖwhaleᚋpkgᚋmodelsᚐTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopicMetrics_topic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopicMetrics",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Topic_id(ctx, field)
			case "recentUsers":
				return ec.fieldContext_Topic_recentUsers(ctx, field)
			case "matchingNum":
				return ec.fieldContext_Topic_matchingNum(ctx, field)
			case "fuzzyMatchingNum":
				return ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Topic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopicOptionConfig_topicId(ctx context.Context, field graphql.CollectedField, obj *models.TopicOptionConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopicOptionConfig_topicId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopicOptionConfig_topicId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopicOptionConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopicToMatching_topicId(ctx context.Context, field graphql.CollectedField, obj *models.TopicToMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopicToMatching_topicId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopicToMatching_topicId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopicToMatching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopicToMatching_matchingIds(ctx context.Context, field graphql.CollectedField, obj *models.TopicToMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopicToMatching_matchingIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchingIds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopicToMatching_matchingIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopicToMatching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopicToMatching_topic(ctx context.Context, field graphql.CollectedField, obj *models.TopicToMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopicToMatching_topic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TopicToMatching().Topic(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Topic)
	fc.Result = res
	return ec.marshalNTopic2ᚖwhaleᚋpkgᚋmodelsᚐTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopicToMatching_topic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopicToMatching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Topic_id(ctx, field)
			case "recentUsers":
				return ec.fieldContext_Topic_recentUsers(ctx, field)
			case "matchingNum":
				return ec.fieldContext_Topic_matchingNum(ctx, field)
			case "fuzzyMatchingNum":
				return ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Topic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_matchingQuota(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_matchingQuota(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().MatchingQuota(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.MatchingQuota)
	fc.Result = res
	return ec.marshalNMatchingQuota2ᚖwhaleᚋpkgᚋmodelsᚐMatchingQuota(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_matchingQuota(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userId":
				return ec.fieldContext_MatchingQuota_userId(ctx, field)
			case "remain":
				return ec.fieldContext_MatchingQuota_remain(ctx, field)
			case "total":
				return ec.fieldContext_MatchingQuota_total(ctx, field)
			case "matchingNum":
				return ec.fieldContext_MatchingQuota_matchingNum(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingQuota_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingQuota_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingQuota", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConfirmState_userId(ctx context.Context, field graphql.CollectedField, obj *models.UserConfirmState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConfirmState_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConfirmState_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConfirmState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConfirmState_state(ctx context.Context, field graphql.CollectedField, obj *models.UserConfirmState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConfirmState_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.MatchingResultConfirmState)
	fc.Result = res
	return ec.marshalNMatchingResultConfirmState2whaleᚋpkgᚋmodelsᚐMatchingResultConfirmState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConfirmState_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConfirmState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MatchingResultConfirmState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserJoinTopic_id(ctx context.Context, field graphql.CollectedField, obj *models.UserJoinTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserJoinTopic_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserJoinTopic_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserJoinTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserJoinTopic_topicId(ctx context.Context, field graphql.CollectedField, obj *models.UserJoinTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserJoinTopic_topicId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserJoinTopic_topicId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserJoinTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserJoinTopic_cityId(ctx context.Context, field graphql.CollectedField, obj *models.UserJoinTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserJoinTopic_cityId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserJoinTopic_cityId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserJoinTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserJoinTopic_userId(ctx context.Context, field graphql.CollectedField, obj *models.UserJoinTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserJoinTopic_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserJoinTopic_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserJoinTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserJoinTopic_latestMatchingId(ctx context.Context, field graphql.CollectedField, obj *models.UserJoinTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserJoinTopic_latestMatchingId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestMatchingID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserJoinTopic_latestMatchingId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserJoinTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserJoinTopic_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.UserJoinTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserJoinTopic_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserJoinTopic_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserJoinTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserJoinTopic_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.UserJoinTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserJoinTopic_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserJoinTopic_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserJoinTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserJoinTopic_topic(ctx context.Context, field graphql.CollectedField, obj *models.UserJoinTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserJoinTopic_topic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserJoinTopic().Topic(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Topic)
	fc.Result = res
	return ec.marshalNTopic2ᚖwhaleᚋpkgᚋmodelsᚐTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserJoinTopic_topic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserJoinTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Topic_id(ctx, field)
			case "recentUsers":
				return ec.fieldContext_Topic_recentUsers(ctx, field)
			case "matchingNum":
				return ec.fieldContext_Topic_matchingNum(ctx, field)
			case "fuzzyMatchingNum":
				return ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Topic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserJoinTopic_city(ctx context.Context, field graphql.CollectedField, obj *models.UserJoinTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserJoinTopic_city(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserJoinTopic().City(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Area)
	fc.Result = res
	return ec.marshalNArea2ᚖwhaleᚋpkgᚋmodelsᚐArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserJoinTopic_city(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserJoinTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserJoinTopic_user(ctx context.Context, field graphql.CollectedField, obj *models.UserJoinTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserJoinTopic_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserJoinTopic().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2ᚖwhaleᚋpkgᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserJoinTopic_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserJoinTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "matchingQuota":
				return ec.fieldContext_User_matchingQuota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserJoinTopic_matching(ctx context.Context, field graphql.CollectedField, obj *models.UserJoinTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserJoinTopic_matching(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserJoinTopic().Matching(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Matching)
	fc.Result = res
	return ec.marshalNMatching2ᚖwhaleᚋpkgᚋmodelsᚐMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserJoinTopic_matching(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserJoinTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Matching_id(ctx, field)
			case "topicId":
				return ec.fieldContext_Matching_topicId(ctx, field)
			case "userId":
				return ec.fieldContext_Matching_userId(ctx, field)
			case "areaIds":
				return ec.fieldContext_Matching_areaIds(ctx, field)
			case "cityId":
				return ec.fieldContext_Matching_cityId(ctx, field)
			case "gender":
				return ec.fieldContext_Matching_gender(ctx, field)
			case "state":
				return ec.fieldContext_Matching_state(ctx, field)
			case "rejectedUserIds":
				return ec.fieldContext_Matching_rejectedUserIds(ctx, field)
			case "inChatGroup":
				return ec.fieldContext_Matching_inChatGroup(ctx, field)
			case "remark":
				return ec.fieldContext_Matching_remark(ctx, field)
			case "dayRange":
				return ec.fieldContext_Matching_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Matching_preferredPeriods(ctx, field)
			case "properties":
				return ec.fieldContext_Matching_properties(ctx, field)
			case "startMatchingAt":
				return ec.fieldContext_Matching_startMatchingAt(ctx, field)
			case "deadline":
				return ec.fieldContext_Matching_deadline(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Matching_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Matching_createdAt(ctx, field)
			case "matchingResult":
				return ec.fieldContext_Matching_matchingResult(ctx, field)
			case "reviewed":
				return ec.fieldContext_Matching_reviewed(ctx, field)
			case "user":
				return ec.fieldContext_Matching_user(ctx, field)
			case "topic":
				return ec.fieldContext_Matching_topic(ctx, field)
			case "areas":
				return ec.fieldContext_Matching_areas(ctx, field)
			case "city":
				return ec.fieldContext_Matching_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Matching", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserLikeMotion_toMotionId(ctx context.Context, field graphql.CollectedField, obj *models.UserLikeMotion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserLikeMotion_toMotionId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToMotionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserLikeMotion_toMotionId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserLikeMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserLikeMotion_toUserId(ctx context.Context, field graphql.CollectedField, obj *models.UserLikeMotion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserLikeMotion_toUserId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToUserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserLikeMotion_toUserId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserLikeMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserLikeMotion_userId(ctx context.Context, field graphql.CollectedField, obj *models.UserLikeMotion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserLikeMotion_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserLikeMotion_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserLikeMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserLikeMotion_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.UserLikeMotion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserLikeMotion_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserLikeMotion_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserLikeMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserLikeMotion_motion(ctx context.Context, field graphql.CollectedField, obj *models.UserLikeMotion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserLikeMotion_motion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserLikeMotion().Motion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Motion)
	fc.Result = res
	return ec.marshalNDiscoverMotion2ᚖwhaleᚋpkgᚋmodelsᚐMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserLikeMotion_motion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserLikeMotion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscoverMotion_id(ctx, field)
			case "userId":
				return ec.fieldContext_DiscoverMotion_userId(ctx, field)
			case "topicId":
				return ec.fieldContext_DiscoverMotion_topicId(ctx, field)
			case "properties":
				return ec.fieldContext_DiscoverMotion_properties(ctx, field)
			case "cityId":
				return ec.fieldContext_DiscoverMotion_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_DiscoverMotion_areaIds(ctx, field)
			case "gender":
				return ec.fieldContext_DiscoverMotion_gender(ctx, field)
			case "dayRange":
				return ec.fieldContext_DiscoverMotion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_DiscoverMotion_preferredPeriods(ctx, field)
			case "remark":
				return ec.fieldContext_DiscoverMotion_remark(ctx, field)
			case "likeCount":
				return ec.fieldContext_DiscoverMotion_likeCount(ctx, field)
			case "viewCount":
				return ec.fieldContext_DiscoverMotion_viewCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_DiscoverMotion_thumbsUpCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_DiscoverMotion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_DiscoverMotion_liked(ctx, field)
			case "submitted":
				return ec.fieldContext_DiscoverMotion_submitted(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_DiscoverMotion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_DiscoverMotion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_DiscoverMotion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_DiscoverMotion_user(ctx, field)
			case "city":
				return ec.fieldContext_DiscoverMotion_city(ctx, field)
			case "areas":
				return ec.fieldContext_DiscoverMotion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscoverMotion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserThumbsUpMotion_userId(ctx context.Context, field graphql.CollectedField, obj *models.UserThumbsUpMotion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserThumbsUpMotion_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserThumbsUpMotion_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserThumbsUpMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserThumbsUpMotion_toMotionId(ctx context.Context, field graphql.CollectedField, obj *models.UserThumbsUpMotion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserThumbsUpMotion_toMotionId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToMotionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserThumbsUpMotion_toMotionId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserThumbsUpMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserThumbsUpMotion_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.UserThumbsUpMotion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserThumbsUpMotion_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserThumbsUpMotion_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserThumbsUpMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) __Service_sdl(ctx context.Context, field graphql.CollectedField, obj *fedruntime.Service) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext__Service_sdl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SDL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext__Service_sdl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "_Service",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputCitiesTopicsFilter(ctx context.Context, obj interface{}) (models.CitiesTopicsFilter, error) {
	var it models.CitiesTopicsFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cityId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateCityTopicParam(ctx context.Context, obj interface{}) (models.CreateCityTopicParam, error) {
	var it models.CreateCityTopicParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"topicIds", "cityId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "topicIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicIds"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicIds = data
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateMatchingInvitationParam(ctx context.Context, obj interface{}) (models.CreateMatchingInvitationParam, error) {
	var it models.CreateMatchingInvitationParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"inviteeId", "remark", "topicId", "cityId", "areaIds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "inviteeId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("inviteeId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InviteeID = data
		case "remark":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remark"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Remark = data
		case "topicId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicID = data
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "areaIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("areaIds"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.AreaIds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateMatchingParam(ctx context.Context, obj interface{}) (models.CreateMatchingParam, error) {
	var it models.CreateMatchingParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"topicId", "areaIds", "cityId", "gender", "remark", "deadline"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "topicId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicID = data
		case "areaIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("areaIds"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.AreaIds = data
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "gender":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gender"))
			data, err := ec.unmarshalNGender2whaleᚋpkgᚋmodelsᚐGender(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gender = data
		case "remark":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remark"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Remark = data
		case "deadline":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deadline"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Deadline = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateMatchingParamV2(ctx context.Context, obj interface{}) (models.CreateMatchingParamV2, error) {
	var it models.CreateMatchingParamV2
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"topicId", "areaIds", "cityId", "gender", "dayRange", "preferredPeriods", "properties", "remark", "deadline"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "topicId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicID = data
		case "areaIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("areaIds"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.AreaIds = data
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "gender":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gender"))
			data, err := ec.unmarshalNGender2whaleᚋpkgᚋmodelsᚐGender(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gender = data
		case "dayRange":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dayRange"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.DayRange = data
		case "preferredPeriods":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("preferredPeriods"))
			data, err := ec.unmarshalNDatePeriod2ᚕwhaleᚋpkgᚋmodelsᚐDatePeriodᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PreferredPeriods = data
		case "properties":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("properties"))
			data, err := ec.unmarshalNMatchingPropertyParam2ᚕᚖwhaleᚋpkgᚋmodelsᚐMatchingPropertyParamᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Properties = data
		case "remark":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remark"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Remark = data
		case "deadline":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deadline"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Deadline = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateMotionParam(ctx context.Context, obj interface{}) (models.CreateMotionParam, error) {
	var it models.CreateMotionParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"topicId", "areaIds", "cityId", "gender", "dayRange", "preferredPeriods", "properties", "remark", "quick", "deadline"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "topicId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicID = data
		case "areaIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("areaIds"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.AreaIds = data
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "gender":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gender"))
			data, err := ec.unmarshalNGender2whaleᚋpkgᚋmodelsᚐGender(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gender = data
		case "dayRange":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dayRange"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.DayRange = data
		case "preferredPeriods":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("preferredPeriods"))
			data, err := ec.unmarshalNDatePeriod2ᚕwhaleᚋpkgᚋmodelsᚐDatePeriodᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PreferredPeriods = data
		case "properties":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("properties"))
			data, err := ec.unmarshalNMotionPropertyParam2ᚕᚖwhaleᚋpkgᚋmodelsᚐMotionPropertyParamᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Properties = data
		case "remark":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remark"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Remark = data
		case "quick":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quick"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Quick = data
		case "deadline":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deadline"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Deadline = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateUserJoinTopicParam(ctx context.Context, obj interface{}) (models.CreateUserJoinTopicParam, error) {
	var it models.CreateUserJoinTopicParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"matchingId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "matchingId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchingId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MatchingID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDiscoverTopicCategoryMotionFilter(ctx context.Context, obj interface{}) (models.DiscoverTopicCategoryMotionFilter, error) {
	var it models.DiscoverTopicCategoryMotionFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cityId", "gender", "topicIds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "gender":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gender"))
			data, err := ec.unmarshalOGender2ᚖwhaleᚋpkgᚋmodelsᚐGender(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gender = data
		case "topicIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicIds"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicIds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGraphQLPaginator(ctx context.Context, obj interface{}) (graphqlutil.GraphQLPaginator, error) {
	var it graphqlutil.GraphQLPaginator
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"size", "page"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "size":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("size"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Size = data
		case "page":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHotTopicsFilter(ctx context.Context, obj interface{}) (models.HotTopicsFilter, error) {
	var it models.HotTopicsFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cityId", "topicId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "topicId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMatchingFilter(ctx context.Context, obj interface{}) (models.MatchingFilter, error) {
	var it models.MatchingFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"before", "after", "topicId", "state", "cityId", "userId", "keyword"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "before":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Before = data
		case "after":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.After = data
		case "topicId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicID = data
		case "state":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("state"))
			data, err := ec.unmarshalOMatchingState2ᚖwhaleᚋpkgᚋmodelsᚐMatchingState(ctx, v)
			if err != nil {
				return it, err
			}
			it.State = data
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "keyword":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMatchingInvitationFilter(ctx context.Context, obj interface{}) (models.MatchingInvitationFilter, error) {
	var it models.MatchingInvitationFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "before", "after"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "before":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Before = data
		case "after":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.After = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMatchingPropertyParam(ctx context.Context, obj interface{}) (models.MatchingPropertyParam, error) {
	var it models.MatchingPropertyParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "values"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "values":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("values"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Values = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMatchingResultFilter(ctx context.Context, obj interface{}) (models.MatchingResultFilter, error) {
	var it models.MatchingResultFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "before", "after"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "before":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Before = data
		case "after":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.After = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMotionFilter(ctx context.Context, obj interface{}) (models.MotionFilter, error) {
	var it models.MotionFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "userId", "cityId", "gender"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "gender":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gender"))
			data, err := ec.unmarshalOGender2ᚖwhaleᚋpkgᚋmodelsᚐGender(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gender = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMotionPropertyParam(ctx context.Context, obj interface{}) (models.MotionPropertyParam, error) {
	var it models.MotionPropertyParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "values"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "values":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("values"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Values = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNotifyNewMotionOfferMessageParam(ctx context.Context, obj interface{}) (models.NotifyNewMotionOfferMessageParam, error) {
	var it models.NotifyNewMotionOfferMessageParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"begin", "end"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "begin":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("begin"))
			data, err := ec.unmarshalNTime2timeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Begin = data
		case "end":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
			data, err := ec.unmarshalNTime2timeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.End = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRecentMatchingFilter(ctx context.Context, obj interface{}) (models.RecentMatchingFilter, error) {
	var it models.RecentMatchingFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cityId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputReviewMatchingParam(ctx context.Context, obj interface{}) (models.ReviewMatchingParam, error) {
	var it models.ReviewMatchingParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"toUserId", "score", "comment"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "toUserId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toUserId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToUserID = data
		case "score":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("score"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Score = data
		case "comment":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Comment = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputReviewMotionParam(ctx context.Context, obj interface{}) (models.ReviewMotionParam, error) {
	var it models.ReviewMotionParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"score", "comment"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "score":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("score"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Score = data
		case "comment":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Comment = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateCityTopicParam(ctx context.Context, obj interface{}) (models.UpdateCityTopicParam, error) {
	var it models.UpdateCityTopicParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"topicIds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "topicIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicIds"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicIds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateDurationConstraintParam(ctx context.Context, obj interface{}) (models.UpdateDurationConstraintParam, error) {
	var it models.UpdateDurationConstraintParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"startDate", "stopDate", "totalMotionQuota", "remainMotionQuota"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "startDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDate"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartDate = data
		case "stopDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stopDate"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.StopDate = data
		case "totalMotionQuota":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalMotionQuota"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalMotionQuota = data
		case "remainMotionQuota":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remainMotionQuota"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemainMotionQuota = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateHotTopicMetricsParam(ctx context.Context, obj interface{}) (models.UpdateHotTopicMetricsParam, error) {
	var it models.UpdateHotTopicMetricsParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"topicId", "heat", "matched", "matching"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "topicId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicID = data
		case "heat":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("heat"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Heat = data
		case "matched":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matched"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Matched = data
		case "matching":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matching"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Matching = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateHotTopicParam(ctx context.Context, obj interface{}) (models.UpdateHotTopicParam, error) {
	var it models.UpdateHotTopicParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"topicMetrics"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "topicMetrics":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicMetrics"))
			data, err := ec.unmarshalNUpdateHotTopicMetricsParam2ᚕᚖwhaleᚋpkgᚋmodelsᚐUpdateHotTopicMetricsParamᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicMetrics = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateMatchingDurationConstraintParam(ctx context.Context, obj interface{}) (models.UpdateMatchingDurationConstraintParam, error) {
	var it models.UpdateMatchingDurationConstraintParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"total", "remain", "startDate", "stopDate"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "total":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("total"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Total = data
		case "remain":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remain"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Remain = data
		case "startDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDate"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartDate = data
		case "stopDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stopDate"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.StopDate = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateMatchingInvitationParam(ctx context.Context, obj interface{}) (models.UpdateMatchingInvitationParam, error) {
	var it models.UpdateMatchingInvitationParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"createdAt", "topicId", "inviteeId", "cityId", "remark"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "topicId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicID = data
		case "inviteeId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("inviteeId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.InviteeID = data
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "remark":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remark"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Remark = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateMatchingParam(ctx context.Context, obj interface{}) (models.UpdateMatchingParam, error) {
	var it models.UpdateMatchingParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"topicId", "areaIds", "cityId", "gender", "remark", "startMatchingAt", "createdAt", "deadline"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "topicId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicID = data
		case "areaIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("areaIds"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.AreaIds = data
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "gender":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gender"))
			data, err := ec.unmarshalOGender2ᚖwhaleᚋpkgᚋmodelsᚐGender(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gender = data
		case "remark":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remark"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Remark = data
		case "startMatchingAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startMatchingAt"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartMatchingAt = data
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "deadline":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deadline"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Deadline = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateMatchingQuotaParam(ctx context.Context, obj interface{}) (models.UpdateMatchingQuotaParam, error) {
	var it models.UpdateMatchingQuotaParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"total", "remain"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "total":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("total"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Total = data
		case "remain":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remain"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Remain = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateMotionParam(ctx context.Context, obj interface{}) (models.UpdateMotionParam, error) {
	var it models.UpdateMotionParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"areaIds", "cityId", "gender", "dayRange", "preferredPeriods", "properties", "remark", "quick", "deadline"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "areaIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("areaIds"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.AreaIds = data
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "gender":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gender"))
			data, err := ec.unmarshalOGender2ᚖwhaleᚋpkgᚋmodelsᚐGender(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gender = data
		case "dayRange":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dayRange"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.DayRange = data
		case "preferredPeriods":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("preferredPeriods"))
			data, err := ec.unmarshalODatePeriod2ᚕwhaleᚋpkgᚋmodelsᚐDatePeriodᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PreferredPeriods = data
		case "properties":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("properties"))
			data, err := ec.unmarshalOMotionPropertyParam2ᚕᚖwhaleᚋpkgᚋmodelsᚐMotionPropertyParamᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Properties = data
		case "remark":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remark"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Remark = data
		case "quick":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quick"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Quick = data
		case "deadline":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deadline"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Deadline = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateRecentMatchingParam(ctx context.Context, obj interface{}) (models.UpdateRecentMatchingParam, error) {
	var it models.UpdateRecentMatchingParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"matchingIds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "matchingIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchingIds"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.MatchingIds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUserJoinTopicParam(ctx context.Context, obj interface{}) (models.UpdateUserJoinTopicParam, error) {
	var it models.UpdateUserJoinTopicParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"matchingId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "matchingId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchingId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MatchingID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserJoinTopicFilter(ctx context.Context, obj interface{}) (models.UserJoinTopicFilter, error) {
	var it models.UserJoinTopicFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cityId", "topicId", "userId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "topicId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicID = data
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserMatchingCalenderParam(ctx context.Context, obj interface{}) (models.UserMatchingCalenderParam, error) {
	var it models.UserMatchingCalenderParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"before", "after", "otherUserId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "before":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			data, err := ec.unmarshalNTime2timeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Before = data
		case "after":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			data, err := ec.unmarshalNTime2timeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.After = data
		case "otherUserId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("otherUserId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.OtherUserID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserMatchingFilter(ctx context.Context, obj interface{}) (models.UserMatchingFilter, error) {
	var it models.UserMatchingFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"state", "states"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "state":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("state"))
			data, err := ec.unmarshalOMatchingState2ᚖwhaleᚋpkgᚋmodelsᚐMatchingState(ctx, v)
			if err != nil {
				return it, err
			}
			it.State = data
		case "states":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("states"))
			data, err := ec.unmarshalOMatchingState2ᚕwhaleᚋpkgᚋmodelsᚐMatchingStateᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.States = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserMatchingInTheDayParam(ctx context.Context, obj interface{}) (models.UserMatchingInTheDayParam, error) {
	var it models.UserMatchingInTheDayParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"dayStr", "otherUserId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "dayStr":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dayStr"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DayStr = data
		case "otherUserId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("otherUserId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.OtherUserID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserUpdateMotionParam(ctx context.Context, obj interface{}) (models.UserUpdateMotionParam, error) {
	var it models.UserUpdateMotionParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"areaIds", "gender", "dayRange", "preferredPeriods", "properties", "remark"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "areaIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("areaIds"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.AreaIds = data
		case "gender":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gender"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gender = data
		case "dayRange":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dayRange"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.DayRange = data
		case "preferredPeriods":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("preferredPeriods"))
			data, err := ec.unmarshalODatePeriod2ᚕwhaleᚋpkgᚋmodelsᚐDatePeriodᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PreferredPeriods = data
		case "properties":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("properties"))
			data, err := ec.unmarshalOMotionPropertyParam2ᚕᚖwhaleᚋpkgᚋmodelsᚐMotionPropertyParamᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Properties = data
		case "remark":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remark"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Remark = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) __Entity(ctx context.Context, sel ast.SelectionSet, obj fedruntime.Entity) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case models.Area:
		return ec._Area(ctx, sel, &obj)
	case *models.Area:
		if obj == nil {
			return graphql.Null
		}
		return ec._Area(ctx, sel, obj)
	case models.ChatGroup:
		return ec._ChatGroup(ctx, sel, &obj)
	case *models.ChatGroup:
		if obj == nil {
			return graphql.Null
		}
		return ec._ChatGroup(ctx, sel, obj)
	case models.LevelRights:
		return ec._LevelRights(ctx, sel, &obj)
	case *models.LevelRights:
		if obj == nil {
			return graphql.Null
		}
		return ec._LevelRights(ctx, sel, obj)
	case models.Matching:
		return ec._Matching(ctx, sel, &obj)
	case *models.Matching:
		if obj == nil {
			return graphql.Null
		}
		return ec._Matching(ctx, sel, obj)
	case models.MatchingQuota:
		return ec._MatchingQuota(ctx, sel, &obj)
	case *models.MatchingQuota:
		if obj == nil {
			return graphql.Null
		}
		return ec._MatchingQuota(ctx, sel, obj)
	case models.Topic:
		return ec._Topic(ctx, sel, &obj)
	case *models.Topic:
		if obj == nil {
			return graphql.Null
		}
		return ec._Topic(ctx, sel, obj)
	case models.TopicOptionConfig:
		return ec._TopicOptionConfig(ctx, sel, &obj)
	case *models.TopicOptionConfig:
		if obj == nil {
			return graphql.Null
		}
		return ec._TopicOptionConfig(ctx, sel, obj)
	case models.User:
		return ec._User(ctx, sel, &obj)
	case *models.User:
		if obj == nil {
			return graphql.Null
		}
		return ec._User(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var areaImplementors = []string{"Area", "_Entity"}

func (ec *executionContext) _Area(ctx context.Context, sel ast.SelectionSet, obj *models.Area) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, areaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Area")
		case "code":
			out.Values[i] = ec._Area_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var availableMotionOfferImplementors = []string{"AvailableMotionOffer"}

func (ec *executionContext) _AvailableMotionOffer(ctx context.Context, sel ast.SelectionSet, obj *models.AvailableMotionOffer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, availableMotionOfferImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AvailableMotionOffer")
		case "motion":
			out.Values[i] = ec._AvailableMotionOffer_motion(ctx, field, obj)
		case "nextQuotaTime":
			out.Values[i] = ec._AvailableMotionOffer_nextQuotaTime(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var calendarEventImplementors = []string{"CalendarEvent"}

func (ec *executionContext) _CalendarEvent(ctx context.Context, sel ast.SelectionSet, obj *models.CalendarEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, calendarEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CalendarEvent")
		case "topicId":
			out.Values[i] = ec._CalendarEvent_topicId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "matchedAt":
			out.Values[i] = ec._CalendarEvent_matchedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "finishedAt":
			out.Values[i] = ec._CalendarEvent_finishedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "chatGroupCreatedAt":
			out.Values[i] = ec._CalendarEvent_chatGroupCreatedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var chatGroupImplementors = []string{"ChatGroup", "_Entity"}

func (ec *executionContext) _ChatGroup(ctx context.Context, sel ast.SelectionSet, obj *models.ChatGroup) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chatGroupImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChatGroup")
		case "id":
			out.Values[i] = ec._ChatGroup_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cityToTopicMatchingImplementors = []string{"CityToTopicMatching"}

func (ec *executionContext) _CityToTopicMatching(ctx context.Context, sel ast.SelectionSet, obj *models.CityToTopicMatching) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cityToTopicMatchingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CityToTopicMatching")
		case "cityId":
			out.Values[i] = ec._CityToTopicMatching_cityId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topics":
			out.Values[i] = ec._CityToTopicMatching_topics(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "city":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CityToTopicMatching_city(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cityTopicsImplementors = []string{"CityTopics"}

func (ec *executionContext) _CityTopics(ctx context.Context, sel ast.SelectionSet, obj *models.CityTopics) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cityTopicsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CityTopics")
		case "cityId":
			out.Values[i] = ec._CityTopics_cityId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topicIds":
			out.Values[i] = ec._CityTopics_topicIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._CityTopics_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topics":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CityTopics_topics(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "city":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CityTopics_city(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createMotionOfferResultImplementors = []string{"CreateMotionOfferResult"}

func (ec *executionContext) _CreateMotionOfferResult(ctx context.Context, sel ast.SelectionSet, obj *models.CreateMotionOfferResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createMotionOfferResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateMotionOfferResult")
		case "chatGroupId":
			out.Values[i] = ec._CreateMotionOfferResult_chatGroupId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var discoverMotionImplementors = []string{"DiscoverMotion"}

func (ec *executionContext) _DiscoverMotion(ctx context.Context, sel ast.SelectionSet, obj *models.Motion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, discoverMotionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DiscoverMotion")
		case "id":
			out.Values[i] = ec._DiscoverMotion_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userId":
			out.Values[i] = ec._DiscoverMotion_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topicId":
			out.Values[i] = ec._DiscoverMotion_topicId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "properties":
			out.Values[i] = ec._DiscoverMotion_properties(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cityId":
			out.Values[i] = ec._DiscoverMotion_cityId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "areaIds":
			out.Values[i] = ec._DiscoverMotion_areaIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "gender":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscoverMotion_gender(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "dayRange":
			out.Values[i] = ec._DiscoverMotion_dayRange(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "preferredPeriods":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscoverMotion_preferredPeriods(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "remark":
			out.Values[i] = ec._DiscoverMotion_remark(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "likeCount":
			out.Values[i] = ec._DiscoverMotion_likeCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "viewCount":
			out.Values[i] = ec._DiscoverMotion_viewCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "thumbsUpCount":
			out.Values[i] = ec._DiscoverMotion_thumbsUpCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._DiscoverMotion_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "liked":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscoverMotion_liked(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "submitted":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscoverMotion_submitted(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "thumbsUp":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscoverMotion_thumbsUp(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "topic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscoverMotion_topic(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "topicOptionConfig":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscoverMotion_topicOptionConfig(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscoverMotion_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "city":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscoverMotion_city(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "areas":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscoverMotion_areas(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var discoverMotionResultImplementors = []string{"DiscoverMotionResult"}

func (ec *executionContext) _DiscoverMotionResult(ctx context.Context, sel ast.SelectionSet, obj *models.DiscoverMotionResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, discoverMotionResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DiscoverMotionResult")
		case "motions":
			out.Values[i] = ec._DiscoverMotionResult_motions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nextToken":
			out.Values[i] = ec._DiscoverMotionResult_nextToken(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var durationConstraintImplementors = []string{"DurationConstraint"}

func (ec *executionContext) _DurationConstraint(ctx context.Context, sel ast.SelectionSet, obj *models.DurationConstraint) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, durationConstraintImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DurationConstraint")
		case "userId":
			out.Values[i] = ec._DurationConstraint_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._DurationConstraint_startDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stopDate":
			out.Values[i] = ec._DurationConstraint_stopDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalMotionQuota":
			out.Values[i] = ec._DurationConstraint_totalMotionQuota(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "remainMotionQuota":
			out.Values[i] = ec._DurationConstraint_remainMotionQuota(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._DurationConstraint_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var entityImplementors = []string{"Entity"}

func (ec *executionContext) _Entity(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, entityImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Entity",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Entity")
		case "findLevelRightsByLevel":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entity_findLevelRightsByLevel(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findMatchingByID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entity_findMatchingByID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findMatchingQuotaByUserID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entity_findMatchingQuotaByUserID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findTopicByID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entity_findTopicByID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findUserByID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entity_findUserByID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var evaluatorResultImplementors = []string{"EvaluatorResult"}

func (ec *executionContext) _EvaluatorResult(ctx context.Context, sel ast.SelectionSet, obj *matcher.EvaluatorResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, evaluatorResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EvaluatorResult")
		case "score":
			out.Values[i] = ec._EvaluatorResult_score(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "timeScore":
			out.Values[i] = ec._EvaluatorResult_timeScore(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "properties":
			out.Values[i] = ec._EvaluatorResult_properties(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "failedReason":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EvaluatorResult_failedReason(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hotTopicsInAreaImplementors = []string{"HotTopicsInArea"}

func (ec *executionContext) _HotTopicsInArea(ctx context.Context, sel ast.SelectionSet, obj *models.HotTopicsInArea) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hotTopicsInAreaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HotTopicsInArea")
		case "cityId":
			out.Values[i] = ec._HotTopicsInArea_cityId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._HotTopicsInArea_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topicMetrics":
			out.Values[i] = ec._HotTopicsInArea_topicMetrics(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "city":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._HotTopicsInArea_city(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var levelRightsImplementors = []string{"LevelRights", "_Entity"}

func (ec *executionContext) _LevelRights(ctx context.Context, sel ast.SelectionSet, obj *models.LevelRights) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, levelRightsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LevelRights")
		case "level":
			out.Values[i] = ec._LevelRights_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "matchingQuota":
			out.Values[i] = ec._LevelRights_matchingQuota(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "matchingDurationConstraint":
			out.Values[i] = ec._LevelRights_matchingDurationConstraint(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchingImplementors = []string{"Matching", "_Entity"}

func (ec *executionContext) _Matching(ctx context.Context, sel ast.SelectionSet, obj *models.Matching) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Matching")
		case "id":
			out.Values[i] = ec._Matching_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topicId":
			out.Values[i] = ec._Matching_topicId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userId":
			out.Values[i] = ec._Matching_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "areaIds":
			out.Values[i] = ec._Matching_areaIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cityId":
			out.Values[i] = ec._Matching_cityId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "gender":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Matching_gender(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "state":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Matching_state(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "rejectedUserIds":
			out.Values[i] = ec._Matching_rejectedUserIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "inChatGroup":
			out.Values[i] = ec._Matching_inChatGroup(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "remark":
			out.Values[i] = ec._Matching_remark(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "dayRange":
			out.Values[i] = ec._Matching_dayRange(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "preferredPeriods":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Matching_preferredPeriods(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "properties":
			out.Values[i] = ec._Matching_properties(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "startMatchingAt":
			out.Values[i] = ec._Matching_startMatchingAt(ctx, field, obj)
		case "deadline":
			out.Values[i] = ec._Matching_deadline(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Matching_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Matching_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchingResult":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Matching_matchingResult(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "reviewed":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Matching_reviewed(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Matching_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "topic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Matching_topic(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "areas":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Matching_areas(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "city":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Matching_city(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchingDurationConstraintImplementors = []string{"MatchingDurationConstraint"}

func (ec *executionContext) _MatchingDurationConstraint(ctx context.Context, sel ast.SelectionSet, obj *models.MatchingDurationConstraint) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchingDurationConstraintImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MatchingDurationConstraint")
		case "startDate":
			out.Values[i] = ec._MatchingDurationConstraint_startDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stopDate":
			out.Values[i] = ec._MatchingDurationConstraint_stopDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._MatchingDurationConstraint_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "remain":
			out.Values[i] = ec._MatchingDurationConstraint_remain(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._MatchingDurationConstraint_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchingInvitationImplementors = []string{"MatchingInvitation"}

func (ec *executionContext) _MatchingInvitation(ctx context.Context, sel ast.SelectionSet, obj *models.MatchingInvitation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchingInvitationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MatchingInvitation")
		case "id":
			out.Values[i] = ec._MatchingInvitation_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userId":
			out.Values[i] = ec._MatchingInvitation_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "inviteeId":
			out.Values[i] = ec._MatchingInvitation_inviteeId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topicId":
			out.Values[i] = ec._MatchingInvitation_topicId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "remark":
			out.Values[i] = ec._MatchingInvitation_remark(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cityId":
			out.Values[i] = ec._MatchingInvitation_cityId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "areaIds":
			out.Values[i] = ec._MatchingInvitation_areaIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchingResultId":
			out.Values[i] = ec._MatchingInvitation_matchingResultId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchingIds":
			out.Values[i] = ec._MatchingInvitation_matchingIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "confirmState":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingInvitation_confirmState(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "confirmedAt":
			out.Values[i] = ec._MatchingInvitation_confirmedAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._MatchingInvitation_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._MatchingInvitation_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "invitee":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingInvitation_invitee(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "topic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingInvitation_topic(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "areas":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingInvitation_areas(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "city":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingInvitation_city(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingInvitation_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "matchingResult":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingInvitation_matchingResult(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchingOfTopicImplementors = []string{"MatchingOfTopic"}

func (ec *executionContext) _MatchingOfTopic(ctx context.Context, sel ast.SelectionSet, obj *models.Matching) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchingOfTopicImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MatchingOfTopic")
		case "userId":
			out.Values[i] = ec._MatchingOfTopic_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "gender":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingOfTopic_gender(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "remark":
			out.Values[i] = ec._MatchingOfTopic_remark(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "areaIds":
			out.Values[i] = ec._MatchingOfTopic_areaIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cityId":
			out.Values[i] = ec._MatchingOfTopic_cityId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._MatchingOfTopic_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingOfTopic_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "city":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingOfTopic_city(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "areas":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingOfTopic_areas(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchingPreviewImplementors = []string{"MatchingPreview"}

func (ec *executionContext) _MatchingPreview(ctx context.Context, sel ast.SelectionSet, obj *models.Matching) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchingPreviewImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MatchingPreview")
		case "userId":
			out.Values[i] = ec._MatchingPreview_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "remark":
			out.Values[i] = ec._MatchingPreview_remark(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "properties":
			out.Values[i] = ec._MatchingPreview_properties(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "dayRange":
			out.Values[i] = ec._MatchingPreview_dayRange(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "preferredPeriods":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingPreview_preferredPeriods(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "topicOptionConfig":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingPreview_topicOptionConfig(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingPreview_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchingPropertyImplementors = []string{"MatchingProperty"}

func (ec *executionContext) _MatchingProperty(ctx context.Context, sel ast.SelectionSet, obj *models.MatchingProperty) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchingPropertyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MatchingProperty")
		case "id":
			out.Values[i] = ec._MatchingProperty_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "values":
			out.Values[i] = ec._MatchingProperty_values(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchingQuotaImplementors = []string{"MatchingQuota", "_Entity"}

func (ec *executionContext) _MatchingQuota(ctx context.Context, sel ast.SelectionSet, obj *models.MatchingQuota) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchingQuotaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MatchingQuota")
		case "userId":
			out.Values[i] = ec._MatchingQuota_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "remain":
			out.Values[i] = ec._MatchingQuota_remain(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._MatchingQuota_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "matchingNum":
			out.Values[i] = ec._MatchingQuota_matchingNum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._MatchingQuota_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._MatchingQuota_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchingResultImplementors = []string{"MatchingResult"}

func (ec *executionContext) _MatchingResult(ctx context.Context, sel ast.SelectionSet, obj *models.MatchingResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchingResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MatchingResult")
		case "id":
			out.Values[i] = ec._MatchingResult_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchingIds":
			out.Values[i] = ec._MatchingResult_matchingIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "motionIds":
			out.Values[i] = ec._MatchingResult_motionIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topicId":
			out.Values[i] = ec._MatchingResult_topicId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userIds":
			out.Values[i] = ec._MatchingResult_userIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "confirmStates":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingResult_confirmStates(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "userConfirmStates":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingResult_userConfirmStates(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "chatGroupId":
			out.Values[i] = ec._MatchingResult_chatGroupId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "chatGroupState":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingResult_chatGroupState(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updatedAt":
			out.Values[i] = ec._MatchingResult_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._MatchingResult_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchingScore":
			out.Values[i] = ec._MatchingResult_matchingScore(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "closed":
			out.Values[i] = ec._MatchingResult_closed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "finishedAt":
			out.Values[i] = ec._MatchingResult_finishedAt(ctx, field, obj)
		case "createdBy":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingResult_createdBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "users":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingResult_users(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "discoverMotion":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingResult_discoverMotion(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "matchingPreviews":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingResult_matchingPreviews(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "topic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingResult_topic(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "chatGroup":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingResult_chatGroup(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "matchingDegree":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingResult_matchingDegree(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchingResultConfirmActionImplementors = []string{"MatchingResultConfirmAction"}

func (ec *executionContext) _MatchingResultConfirmAction(ctx context.Context, sel ast.SelectionSet, obj *models.MatchingResultConfirmAction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchingResultConfirmActionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MatchingResultConfirmAction")
		case "id":
			out.Values[i] = ec._MatchingResultConfirmAction_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "matchingResultId":
			out.Values[i] = ec._MatchingResultConfirmAction_matchingResultId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userId":
			out.Values[i] = ec._MatchingResultConfirmAction_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "confirmed":
			out.Values[i] = ec._MatchingResultConfirmAction_confirmed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._MatchingResultConfirmAction_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var motionImplementors = []string{"Motion"}

func (ec *executionContext) _Motion(ctx context.Context, sel ast.SelectionSet, obj *models.Motion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, motionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Motion")
		case "id":
			out.Values[i] = ec._Motion_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userId":
			out.Values[i] = ec._Motion_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cityId":
			out.Values[i] = ec._Motion_cityId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "remark":
			out.Values[i] = ec._Motion_remark(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "active":
			out.Values[i] = ec._Motion_active(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "inOfferNum":
			out.Values[i] = ec._Motion_inOfferNum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "outOfferNum":
			out.Values[i] = ec._Motion_outOfferNum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "pendingInNum":
			out.Values[i] = ec._Motion_pendingInNum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "pendingOutNum":
			out.Values[i] = ec._Motion_pendingOutNum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "activeNum":
			out.Values[i] = ec._Motion_activeNum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "discoverable":
			out.Values[i] = ec._Motion_discoverable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "relatedMatchingId":
			out.Values[i] = ec._Motion_relatedMatchingId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "properties":
			out.Values[i] = ec._Motion_properties(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "dayRange":
			out.Values[i] = ec._Motion_dayRange(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "preferredPeriods":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Motion_preferredPeriods(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "gender":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Motion_gender(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createdAt":
			out.Values[i] = ec._Motion_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "liked":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Motion_liked(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "viewCount":
			out.Values[i] = ec._Motion_viewCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "likeCount":
			out.Values[i] = ec._Motion_likeCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "thumbsUpCount":
			out.Values[i] = ec._Motion_thumbsUpCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "thumbsUp":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Motion_thumbsUp(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "topic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Motion_topic(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "topicOptionConfig":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Motion_topicOptionConfig(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Motion_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "city":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Motion_city(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "areas":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Motion_areas(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var motionOfferRecordImplementors = []string{"MotionOfferRecord"}

func (ec *executionContext) _MotionOfferRecord(ctx context.Context, sel ast.SelectionSet, obj *models.MotionOfferRecord) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, motionOfferRecordImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MotionOfferRecord")
		case "id":
			out.Values[i] = ec._MotionOfferRecord_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "toMotionId":
			out.Values[i] = ec._MotionOfferRecord_toMotionId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "motionId":
			out.Values[i] = ec._MotionOfferRecord_motionId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "state":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MotionOfferRecord_state(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createdAt":
			out.Values[i] = ec._MotionOfferRecord_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "reactAt":
			out.Values[i] = ec._MotionOfferRecord_reactAt(ctx, field, obj)
		case "remark":
			out.Values[i] = ec._MotionOfferRecord_remark(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "chatChance":
			out.Values[i] = ec._MotionOfferRecord_chatChance(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "reviewed":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MotionOfferRecord_reviewed(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "toMotion":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MotionOfferRecord_toMotion(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "motion":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MotionOfferRecord_motion(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var motionPropertyImplementors = []string{"MotionProperty"}

func (ec *executionContext) _MotionProperty(ctx context.Context, sel ast.SelectionSet, obj *models.MotionProperty) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, motionPropertyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MotionProperty")
		case "id":
			out.Values[i] = ec._MotionProperty_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "values":
			out.Values[i] = ec._MotionProperty_values(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "refreshTopicMetrics":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_refreshTopicMetrics(ctx, field)
			})
		case "updateDurationConstraint":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateDurationConstraint(ctx, field)
			})
		case "createMatchingInvitation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMatchingInvitation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cancelMatchingInvitation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelMatchingInvitation(ctx, field)
			})
		case "confirmMatchingInvitation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_confirmMatchingInvitation(ctx, field)
			})
		case "updateMatchingInvitation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateMatchingInvitation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createMatching":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMatching(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createMatchingV2":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMatchingV2(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateMatching":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateMatching(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateMatchingQuota":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateMatchingQuota(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateMatchingDurationConstraint":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateMatchingDurationConstraint(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "confirmMatchingResult":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_confirmMatchingResult(ctx, field)
			})
		case "confirmMatchingResultV2":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_confirmMatchingResultV2(ctx, field)
			})
		case "cancelMatching":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelMatching(ctx, field)
			})
		case "startMatching":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_startMatching(ctx, field)
			})
		case "finishMatching":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_finishMatching(ctx, field)
			})
		case "reviewMatching":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_reviewMatching(ctx, field)
			})
		case "updateRecentMatching":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateRecentMatching(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addMatchingToRecent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addMatchingToRecent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "getMatchingScore":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_getMatchingScore(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "getAvailableMotionOffer":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_getAvailableMotionOffer(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createMotionOffer":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMotionOffer(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cancelMotionOffer":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelMotionOffer(ctx, field)
			})
		case "acceptMotionOffer":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_acceptMotionOffer(ctx, field)
			})
		case "rejectMotionOffer":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_rejectMotionOffer(ctx, field)
			})
		case "sendChatInOffer":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_sendChatInOffer(ctx, field)
			})
		case "finishMotionOffer":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_finishMotionOffer(ctx, field)
			})
		case "notifyNewMotionOffer":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_notifyNewMotionOffer(ctx, field)
			})
		case "sendMotionOfferAcceptMessage":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_sendMotionOfferAcceptMessage(ctx, field)
			})
		case "createMotion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMotion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateMotion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateMotion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userUpdateMotion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_userUpdateMotion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "closeMotion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_closeMotion(ctx, field)
			})
		case "reviewMotionOffer":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_reviewMotionOffer(ctx, field)
			})
		case "createCityTopics":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createCityTopics(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateCityTopics":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateCityTopics(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateHotTopicsInArea":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateHotTopicsInArea(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateUserJoinTopic":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateUserJoinTopic(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createUserJoinTopic":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createUserJoinTopic(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "likeMotion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_likeMotion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unlikeMotion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unlikeMotion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "thumbsUpMotion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_thumbsUpMotion(ctx, field)
			})
		case "cancelThumbsUpMotion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelThumbsUpMotion(ctx, field)
			})
		case "thumbsUpMotions":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_thumbsUpMotions(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "thumbsUpMotionsCount":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_thumbsUpMotionsCount(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "chatGroupByResultId":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_chatGroupByResultId(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userDurationConstraint":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userDurationConstraint(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "yesterdayMatchingCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_yesterdayMatchingCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "motionSummary":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_motionSummary(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "matchingInvitations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_matchingInvitations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "matchingInvitationsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_matchingInvitationsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "invitations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_invitations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "invitation":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_invitation(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "invitationsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_invitationsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "matching":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_matching(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userMatchingQuota":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userMatchingQuota(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userMatchingCalendar":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userMatchingCalendar(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userMatchingsInTheDay":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userMatchingsInTheDay(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "matchingResultByChatGroupId":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_matchingResultByChatGroupId(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "matchings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_matchings(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "matchingsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_matchingsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "matchingResult":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_matchingResult(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "matchingResults":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_matchingResults(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "matchingResultsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_matchingResultsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userMatchings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userMatchings(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "unconfirmedUserMatchings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_unconfirmedUserMatchings(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userMatchingsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userMatchingsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "previewMatchingsOfTopic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_previewMatchingsOfTopic(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "unconfirmedInvitations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_unconfirmedInvitations(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "unconfirmedInvitationCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_unconfirmedInvitationCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "recentMatchings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_recentMatchings(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "recentMatchingsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_recentMatchingsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "recentMatching":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_recentMatching(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "topicDistribution":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_topicDistribution(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "cityDistribution":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cityDistribution(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "matchingDurationConstraints":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_matchingDurationConstraints(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "discoverCategoryMotions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_discoverCategoryMotions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "discoverLatestCategoryMotions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_discoverLatestCategoryMotions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getDiscoverMotion":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getDiscoverMotion(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "outMotionOffers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_outMotionOffers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "inMotionOffers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_inMotionOffers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMotionOffer":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMotionOffer(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "motion":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_motion(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userMotions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userMotions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userMotionsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userMotionsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "activeMotions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_activeMotions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "motions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_motions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "motionsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_motionsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "cityTopics":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cityTopics(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "citiesTopics":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_citiesTopics(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "citiesTopicsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_citiesTopicsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "hotTopicsInArea":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hotTopicsInArea(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "hotTopics":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hotTopics(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "hotTopicsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hotTopicsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userJoinTopics":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userJoinTopics(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userJoinTopicsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userJoinTopicsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userJoinTopic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userJoinTopic(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "likedMotions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_likedMotions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "likedMotionsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_likedMotionsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "_entities":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__entities(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "_service":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__service(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var recentMatchingImplementors = []string{"RecentMatching"}

func (ec *executionContext) _RecentMatching(ctx context.Context, sel ast.SelectionSet, obj *models.RecentMatching) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, recentMatchingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RecentMatching")
		case "id":
			out.Values[i] = ec._RecentMatching_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cityId":
			out.Values[i] = ec._RecentMatching_cityId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topicId":
			out.Values[i] = ec._RecentMatching_topicId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchingIds":
			out.Values[i] = ec._RecentMatching_matchingIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._RecentMatching_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._RecentMatching_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RecentMatching_topic(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "city":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RecentMatching_city(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "matchings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RecentMatching_matchings(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var simpleAvatarUserImplementors = []string{"SimpleAvatarUser"}

func (ec *executionContext) _SimpleAvatarUser(ctx context.Context, sel ast.SelectionSet, obj *models.SimpleAvatarUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, simpleAvatarUserImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SimpleAvatarUser")
		case "avatar":
			out.Values[i] = ec._SimpleAvatarUser_avatar(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nickname":
			out.Values[i] = ec._SimpleAvatarUser_nickname(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var summaryImplementors = []string{"Summary"}

func (ec *executionContext) _Summary(ctx context.Context, sel ast.SelectionSet, obj *models.Summary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, summaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Summary")
		case "count":
			out.Values[i] = ec._Summary_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var topicImplementors = []string{"Topic", "_Entity"}

func (ec *executionContext) _Topic(ctx context.Context, sel ast.SelectionSet, obj *models.Topic) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, topicImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Topic")
		case "id":
			out.Values[i] = ec._Topic_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "recentUsers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Topic_recentUsers(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "matchingNum":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Topic_matchingNum(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "fuzzyMatchingNum":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Topic_fuzzyMatchingNum(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var topicMetricsImplementors = []string{"TopicMetrics"}

func (ec *executionContext) _TopicMetrics(ctx context.Context, sel ast.SelectionSet, obj *models.TopicMetrics) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, topicMetricsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TopicMetrics")
		case "id":
			out.Values[i] = ec._TopicMetrics_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matched":
			out.Values[i] = ec._TopicMetrics_matched(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matching":
			out.Values[i] = ec._TopicMetrics_matching(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "heat":
			out.Values[i] = ec._TopicMetrics_heat(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TopicMetrics_topic(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var topicOptionConfigImplementors = []string{"TopicOptionConfig", "_Entity"}

func (ec *executionContext) _TopicOptionConfig(ctx context.Context, sel ast.SelectionSet, obj *models.TopicOptionConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, topicOptionConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TopicOptionConfig")
		case "topicId":
			out.Values[i] = ec._TopicOptionConfig_topicId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var topicToMatchingImplementors = []string{"TopicToMatching"}

func (ec *executionContext) _TopicToMatching(ctx context.Context, sel ast.SelectionSet, obj *models.TopicToMatching) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, topicToMatchingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TopicToMatching")
		case "topicId":
			out.Values[i] = ec._TopicToMatching_topicId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchingIds":
			out.Values[i] = ec._TopicToMatching_matchingIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TopicToMatching_topic(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User", "_Entity"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *models.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchingQuota":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_matchingQuota(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userConfirmStateImplementors = []string{"UserConfirmState"}

func (ec *executionContext) _UserConfirmState(ctx context.Context, sel ast.SelectionSet, obj *models.UserConfirmState) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userConfirmStateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserConfirmState")
		case "userId":
			out.Values[i] = ec._UserConfirmState_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "state":
			out.Values[i] = ec._UserConfirmState_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userJoinTopicImplementors = []string{"UserJoinTopic"}

func (ec *executionContext) _UserJoinTopic(ctx context.Context, sel ast.SelectionSet, obj *models.UserJoinTopic) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userJoinTopicImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserJoinTopic")
		case "id":
			out.Values[i] = ec._UserJoinTopic_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topicId":
			out.Values[i] = ec._UserJoinTopic_topicId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cityId":
			out.Values[i] = ec._UserJoinTopic_cityId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userId":
			out.Values[i] = ec._UserJoinTopic_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "latestMatchingId":
			out.Values[i] = ec._UserJoinTopic_latestMatchingId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._UserJoinTopic_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._UserJoinTopic_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserJoinTopic_topic(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "city":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserJoinTopic_city(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserJoinTopic_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "matching":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserJoinTopic_matching(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userLikeMotionImplementors = []string{"UserLikeMotion"}

func (ec *executionContext) _UserLikeMotion(ctx context.Context, sel ast.SelectionSet, obj *models.UserLikeMotion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userLikeMotionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserLikeMotion")
		case "toMotionId":
			out.Values[i] = ec._UserLikeMotion_toMotionId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "toUserId":
			out.Values[i] = ec._UserLikeMotion_toUserId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userId":
			out.Values[i] = ec._UserLikeMotion_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._UserLikeMotion_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "motion":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserLikeMotion_motion(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userThumbsUpMotionImplementors = []string{"UserThumbsUpMotion"}

func (ec *executionContext) _UserThumbsUpMotion(ctx context.Context, sel ast.SelectionSet, obj *models.UserThumbsUpMotion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userThumbsUpMotionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserThumbsUpMotion")
		case "userId":
			out.Values[i] = ec._UserThumbsUpMotion_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "toMotionId":
			out.Values[i] = ec._UserThumbsUpMotion_toMotionId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._UserThumbsUpMotion_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var _ServiceImplementors = []string{"_Service"}

func (ec *executionContext) __Service(ctx context.Context, sel ast.SelectionSet, obj *fedruntime.Service) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, _ServiceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("_Service")
		case "sdl":
			out.Values[i] = ec.__Service_sdl(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNArea2whaleᚋpkgᚋmodelsᚐArea(ctx context.Context, sel ast.SelectionSet, v models.Area) graphql.Marshaler {
	return ec._Area(ctx, sel, &v)
}

func (ec *executionContext) marshalNArea2ᚕᚖwhaleᚋpkgᚋmodelsᚐAreaᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Area) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNArea2ᚖwhaleᚋpkgᚋmodelsᚐArea(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNArea2ᚖwhaleᚋpkgᚋmodelsᚐArea(ctx context.Context, sel ast.SelectionSet, v *models.Area) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Area(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAreaCode2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAreaCode2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNAvailableMotionOffer2whaleᚋpkgᚋmodelsᚐAvailableMotionOffer(ctx context.Context, sel ast.SelectionSet, v models.AvailableMotionOffer) graphql.Marshaler {
	return ec._AvailableMotionOffer(ctx, sel, &v)
}

func (ec *executionContext) marshalNAvailableMotionOffer2ᚖwhaleᚋpkgᚋmodelsᚐAvailableMotionOffer(ctx context.Context, sel ast.SelectionSet, v *models.AvailableMotionOffer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AvailableMotionOffer(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCalendarEvent2ᚕᚖwhaleᚋpkgᚋmodelsᚐCalendarEventᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.CalendarEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCalendarEvent2ᚖwhaleᚋpkgᚋmodelsᚐCalendarEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCalendarEvent2ᚖwhaleᚋpkgᚋmodelsᚐCalendarEvent(ctx context.Context, sel ast.SelectionSet, v *models.CalendarEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CalendarEvent(ctx, sel, v)
}

func (ec *executionContext) marshalNChatGroup2whaleᚋpkgᚋmodelsᚐChatGroup(ctx context.Context, sel ast.SelectionSet, v models.ChatGroup) graphql.Marshaler {
	return ec._ChatGroup(ctx, sel, &v)
}

func (ec *executionContext) marshalNChatGroup2ᚖwhaleᚋpkgᚋmodelsᚐChatGroup(ctx context.Context, sel ast.SelectionSet, v *models.ChatGroup) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChatGroup(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChatGroupState2whaleᚋpkgᚋmodelsᚐChatGroupState(ctx context.Context, v interface{}) (models.ChatGroupState, error) {
	var res models.ChatGroupState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChatGroupState2whaleᚋpkgᚋmodelsᚐChatGroupState(ctx context.Context, sel ast.SelectionSet, v models.ChatGroupState) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCityToTopicMatching2ᚕᚖwhaleᚋpkgᚋmodelsᚐCityToTopicMatchingᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.CityToTopicMatching) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCityToTopicMatching2ᚖwhaleᚋpkgᚋmodelsᚐCityToTopicMatching(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCityToTopicMatching2ᚖwhaleᚋpkgᚋmodelsᚐCityToTopicMatching(ctx context.Context, sel ast.SelectionSet, v *models.CityToTopicMatching) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CityToTopicMatching(ctx, sel, v)
}

func (ec *executionContext) marshalNCityTopics2whaleᚋpkgᚋmodelsᚐCityTopics(ctx context.Context, sel ast.SelectionSet, v models.CityTopics) graphql.Marshaler {
	return ec._CityTopics(ctx, sel, &v)
}

func (ec *executionContext) marshalNCityTopics2ᚕᚖwhaleᚋpkgᚋmodelsᚐCityTopicsᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.CityTopics) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCityTopics2ᚖwhaleᚋpkgᚋmodelsᚐCityTopics(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCityTopics2ᚖwhaleᚋpkgᚋmodelsᚐCityTopics(ctx context.Context, sel ast.SelectionSet, v *models.CityTopics) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CityTopics(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateCityTopicParam2whaleᚋpkgᚋmodelsᚐCreateCityTopicParam(ctx context.Context, v interface{}) (models.CreateCityTopicParam, error) {
	res, err := ec.unmarshalInputCreateCityTopicParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateMatchingInvitationParam2whaleᚋpkgᚋmodelsᚐCreateMatchingInvitationParam(ctx context.Context, v interface{}) (models.CreateMatchingInvitationParam, error) {
	res, err := ec.unmarshalInputCreateMatchingInvitationParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateMatchingParam2whaleᚋpkgᚋmodelsᚐCreateMatchingParam(ctx context.Context, v interface{}) (models.CreateMatchingParam, error) {
	res, err := ec.unmarshalInputCreateMatchingParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateMatchingParamV22whaleᚋpkgᚋmodelsᚐCreateMatchingParamV2(ctx context.Context, v interface{}) (models.CreateMatchingParamV2, error) {
	res, err := ec.unmarshalInputCreateMatchingParamV2(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateMotionOfferResult2whaleᚋpkgᚋmodelsᚐCreateMotionOfferResult(ctx context.Context, sel ast.SelectionSet, v models.CreateMotionOfferResult) graphql.Marshaler {
	return ec._CreateMotionOfferResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateMotionOfferResult2ᚖwhaleᚋpkgᚋmodelsᚐCreateMotionOfferResult(ctx context.Context, sel ast.SelectionSet, v *models.CreateMotionOfferResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateMotionOfferResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateMotionParam2whaleᚋpkgᚋmodelsᚐCreateMotionParam(ctx context.Context, v interface{}) (models.CreateMotionParam, error) {
	res, err := ec.unmarshalInputCreateMotionParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateUserJoinTopicParam2whaleᚋpkgᚋmodelsᚐCreateUserJoinTopicParam(ctx context.Context, v interface{}) (models.CreateUserJoinTopicParam, error) {
	res, err := ec.unmarshalInputCreateUserJoinTopicParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDatePeriod2whaleᚋpkgᚋmodelsᚐDatePeriod(ctx context.Context, v interface{}) (models.DatePeriod, error) {
	var res models.DatePeriod
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDatePeriod2whaleᚋpkgᚋmodelsᚐDatePeriod(ctx context.Context, sel ast.SelectionSet, v models.DatePeriod) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDatePeriod2ᚕwhaleᚋpkgᚋmodelsᚐDatePeriodᚄ(ctx context.Context, v interface{}) ([]models.DatePeriod, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]models.DatePeriod, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDatePeriod2whaleᚋpkgᚋmodelsᚐDatePeriod(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNDatePeriod2ᚕwhaleᚋpkgᚋmodelsᚐDatePeriodᚄ(ctx context.Context, sel ast.SelectionSet, v []models.DatePeriod) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDatePeriod2whaleᚋpkgᚋmodelsᚐDatePeriod(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDiscoverMotion2whaleᚋpkgᚋmodelsᚐMotion(ctx context.Context, sel ast.SelectionSet, v models.Motion) graphql.Marshaler {
	return ec._DiscoverMotion(ctx, sel, &v)
}

func (ec *executionContext) marshalNDiscoverMotion2ᚕᚖwhaleᚋpkgᚋmodelsᚐMotionᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Motion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDiscoverMotion2ᚖwhaleᚋpkgᚋmodelsᚐMotion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDiscoverMotion2ᚖwhaleᚋpkgᚋmodelsᚐMotion(ctx context.Context, sel ast.SelectionSet, v *models.Motion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DiscoverMotion(ctx, sel, v)
}

func (ec *executionContext) marshalNDiscoverMotionResult2whaleᚋpkgᚋmodelsᚐDiscoverMotionResult(ctx context.Context, sel ast.SelectionSet, v models.DiscoverMotionResult) graphql.Marshaler {
	return ec._DiscoverMotionResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNDiscoverMotionResult2ᚖwhaleᚋpkgᚋmodelsᚐDiscoverMotionResult(ctx context.Context, sel ast.SelectionSet, v *models.DiscoverMotionResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DiscoverMotionResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDiscoverTopicCategoryMotionFilter2whaleᚋpkgᚋmodelsᚐDiscoverTopicCategoryMotionFilter(ctx context.Context, v interface{}) (models.DiscoverTopicCategoryMotionFilter, error) {
	res, err := ec.unmarshalInputDiscoverTopicCategoryMotionFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDurationConstraint2whaleᚋpkgᚋmodelsᚐDurationConstraint(ctx context.Context, sel ast.SelectionSet, v models.DurationConstraint) graphql.Marshaler {
	return ec._DurationConstraint(ctx, sel, &v)
}

func (ec *executionContext) marshalNDurationConstraint2ᚖwhaleᚋpkgᚋmodelsᚐDurationConstraint(ctx context.Context, sel ast.SelectionSet, v *models.DurationConstraint) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DurationConstraint(ctx, sel, v)
}

func (ec *executionContext) marshalNEvaluatorResult2whaleᚋpkgᚋmatcherᚐEvaluatorResult(ctx context.Context, sel ast.SelectionSet, v matcher.EvaluatorResult) graphql.Marshaler {
	return ec._EvaluatorResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNEvaluatorResult2ᚖwhaleᚋpkgᚋmatcherᚐEvaluatorResult(ctx context.Context, sel ast.SelectionSet, v *matcher.EvaluatorResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EvaluatorResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFieldSet2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFieldSet2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNGender2whaleᚋpkgᚋmodelsᚐGender(ctx context.Context, v interface{}) (models.Gender, error) {
	var res models.Gender
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGender2whaleᚋpkgᚋmodelsᚐGender(ctx context.Context, sel ast.SelectionSet, v models.Gender) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNHotTopicsInArea2whaleᚋpkgᚋmodelsᚐHotTopicsInArea(ctx context.Context, sel ast.SelectionSet, v models.HotTopicsInArea) graphql.Marshaler {
	return ec._HotTopicsInArea(ctx, sel, &v)
}

func (ec *executionContext) marshalNHotTopicsInArea2ᚕᚖwhaleᚋpkgᚋmodelsᚐHotTopicsInAreaᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.HotTopicsInArea) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHotTopicsInArea2ᚖwhaleᚋpkgᚋmodelsᚐHotTopicsInArea(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNHotTopicsInArea2ᚖwhaleᚋpkgᚋmodelsᚐHotTopicsInArea(ctx context.Context, sel ast.SelectionSet, v *models.HotTopicsInArea) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HotTopicsInArea(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2ᚕintᚄ(ctx context.Context, v interface{}) ([]int, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNInt2ᚕintᚄ(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInvitationConfirmState2whaleᚋpkgᚋmodelsᚐInvitationConfirmState(ctx context.Context, v interface{}) (models.InvitationConfirmState, error) {
	var res models.InvitationConfirmState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInvitationConfirmState2whaleᚋpkgᚋmodelsᚐInvitationConfirmState(ctx context.Context, sel ast.SelectionSet, v models.InvitationConfirmState) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNLevelRights2whaleᚋpkgᚋmodelsᚐLevelRights(ctx context.Context, sel ast.SelectionSet, v models.LevelRights) graphql.Marshaler {
	return ec._LevelRights(ctx, sel, &v)
}

func (ec *executionContext) marshalNLevelRights2ᚖwhaleᚋpkgᚋmodelsᚐLevelRights(ctx context.Context, sel ast.SelectionSet, v *models.LevelRights) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LevelRights(ctx, sel, v)
}

func (ec *executionContext) marshalNMatching2whaleᚋpkgᚋmodelsᚐMatching(ctx context.Context, sel ast.SelectionSet, v models.Matching) graphql.Marshaler {
	return ec._Matching(ctx, sel, &v)
}

func (ec *executionContext) marshalNMatching2ᚕᚖwhaleᚋpkgᚋmodelsᚐMatchingᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Matching) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatching2ᚖwhaleᚋpkgᚋmodelsᚐMatching(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMatching2ᚖwhaleᚋpkgᚋmodelsᚐMatching(ctx context.Context, sel ast.SelectionSet, v *models.Matching) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Matching(ctx, sel, v)
}

func (ec *executionContext) marshalNMatchingDurationConstraint2whaleᚋpkgᚋmodelsᚐMatchingDurationConstraint(ctx context.Context, sel ast.SelectionSet, v models.MatchingDurationConstraint) graphql.Marshaler {
	return ec._MatchingDurationConstraint(ctx, sel, &v)
}

func (ec *executionContext) marshalNMatchingDurationConstraint2ᚖwhaleᚋpkgᚋmodelsᚐMatchingDurationConstraint(ctx context.Context, sel ast.SelectionSet, v *models.MatchingDurationConstraint) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MatchingDurationConstraint(ctx, sel, v)
}

func (ec *executionContext) marshalNMatchingInvitation2whaleᚋpkgᚋmodelsᚐMatchingInvitation(ctx context.Context, sel ast.SelectionSet, v models.MatchingInvitation) graphql.Marshaler {
	return ec._MatchingInvitation(ctx, sel, &v)
}

func (ec *executionContext) marshalNMatchingInvitation2ᚕᚖwhaleᚋpkgᚋmodelsᚐMatchingInvitationᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.MatchingInvitation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatchingInvitation2ᚖwhaleᚋpkgᚋmodelsᚐMatchingInvitation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMatchingInvitation2ᚖwhaleᚋpkgᚋmodelsᚐMatchingInvitation(ctx context.Context, sel ast.SelectionSet, v *models.MatchingInvitation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MatchingInvitation(ctx, sel, v)
}

func (ec *executionContext) marshalNMatchingOfTopic2ᚕᚖwhaleᚋpkgᚋmodelsᚐMatchingᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Matching) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatchingOfTopic2ᚖwhaleᚋpkgᚋmodelsᚐMatching(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMatchingOfTopic2ᚖwhaleᚋpkgᚋmodelsᚐMatching(ctx context.Context, sel ast.SelectionSet, v *models.Matching) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MatchingOfTopic(ctx, sel, v)
}

func (ec *executionContext) marshalNMatchingPreview2ᚕᚖwhaleᚋpkgᚋmodelsᚐMatchingᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Matching) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatchingPreview2ᚖwhaleᚋpkgᚋmodelsᚐMatching(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMatchingPreview2ᚖwhaleᚋpkgᚋmodelsᚐMatching(ctx context.Context, sel ast.SelectionSet, v *models.Matching) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MatchingPreview(ctx, sel, v)
}

func (ec *executionContext) marshalNMatchingProperty2whaleᚋpkgᚋmodelsᚐMatchingProperty(ctx context.Context, sel ast.SelectionSet, v models.MatchingProperty) graphql.Marshaler {
	return ec._MatchingProperty(ctx, sel, &v)
}

func (ec *executionContext) marshalNMatchingProperty2ᚕwhaleᚋpkgᚋmodelsᚐMatchingPropertyᚄ(ctx context.Context, sel ast.SelectionSet, v []models.MatchingProperty) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatchingProperty2whaleᚋpkgᚋmodelsᚐMatchingProperty(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMatchingPropertyParam2ᚕᚖwhaleᚋpkgᚋmodelsᚐMatchingPropertyParamᚄ(ctx context.Context, v interface{}) ([]*models.MatchingPropertyParam, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.MatchingPropertyParam, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMatchingPropertyParam2ᚖwhaleᚋpkgᚋmodelsᚐMatchingPropertyParam(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMatchingPropertyParam2ᚖwhaleᚋpkgᚋmodelsᚐMatchingPropertyParam(ctx context.Context, v interface{}) (*models.MatchingPropertyParam, error) {
	res, err := ec.unmarshalInputMatchingPropertyParam(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMatchingQuota2whaleᚋpkgᚋmodelsᚐMatchingQuota(ctx context.Context, sel ast.SelectionSet, v models.MatchingQuota) graphql.Marshaler {
	return ec._MatchingQuota(ctx, sel, &v)
}

func (ec *executionContext) marshalNMatchingQuota2ᚖwhaleᚋpkgᚋmodelsᚐMatchingQuota(ctx context.Context, sel ast.SelectionSet, v *models.MatchingQuota) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MatchingQuota(ctx, sel, v)
}

func (ec *executionContext) marshalNMatchingResult2whaleᚋpkgᚋmodelsᚐMatchingResult(ctx context.Context, sel ast.SelectionSet, v models.MatchingResult) graphql.Marshaler {
	return ec._MatchingResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNMatchingResult2ᚕᚖwhaleᚋpkgᚋmodelsᚐMatchingResultᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.MatchingResult) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatchingResult2ᚖwhaleᚋpkgᚋmodelsᚐMatchingResult(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMatchingResult2ᚖwhaleᚋpkgᚋmodelsᚐMatchingResult(ctx context.Context, sel ast.SelectionSet, v *models.MatchingResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MatchingResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMatchingResultConfirmState2whaleᚋpkgᚋmodelsᚐMatchingResultConfirmState(ctx context.Context, v interface{}) (models.MatchingResultConfirmState, error) {
	var res models.MatchingResultConfirmState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMatchingResultConfirmState2whaleᚋpkgᚋmodelsᚐMatchingResultConfirmState(ctx context.Context, sel ast.SelectionSet, v models.MatchingResultConfirmState) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMatchingResultConfirmState2ᚕwhaleᚋpkgᚋmodelsᚐMatchingResultConfirmStateᚄ(ctx context.Context, v interface{}) ([]models.MatchingResultConfirmState, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]models.MatchingResultConfirmState, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMatchingResultConfirmState2whaleᚋpkgᚋmodelsᚐMatchingResultConfirmState(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNMatchingResultConfirmState2ᚕwhaleᚋpkgᚋmodelsᚐMatchingResultConfirmStateᚄ(ctx context.Context, sel ast.SelectionSet, v []models.MatchingResultConfirmState) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatchingResultConfirmState2whaleᚋpkgᚋmodelsᚐMatchingResultConfirmState(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMatchingState2whaleᚋpkgᚋmodelsᚐMatchingState(ctx context.Context, v interface{}) (models.MatchingState, error) {
	var res models.MatchingState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMatchingState2whaleᚋpkgᚋmodelsᚐMatchingState(ctx context.Context, sel ast.SelectionSet, v models.MatchingState) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNMotion2whaleᚋpkgᚋmodelsᚐMotion(ctx context.Context, sel ast.SelectionSet, v models.Motion) graphql.Marshaler {
	return ec._Motion(ctx, sel, &v)
}

func (ec *executionContext) marshalNMotion2ᚕᚖwhaleᚋpkgᚋmodelsᚐMotionᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Motion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMotion2ᚖwhaleᚋpkgᚋmodelsᚐMotion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMotion2ᚖwhaleᚋpkgᚋmodelsᚐMotion(ctx context.Context, sel ast.SelectionSet, v *models.Motion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Motion(ctx, sel, v)
}

func (ec *executionContext) marshalNMotionOfferRecord2whaleᚋpkgᚋmodelsᚐMotionOfferRecord(ctx context.Context, sel ast.SelectionSet, v models.MotionOfferRecord) graphql.Marshaler {
	return ec._MotionOfferRecord(ctx, sel, &v)
}

func (ec *executionContext) marshalNMotionOfferRecord2ᚕᚖwhaleᚋpkgᚋmodelsᚐMotionOfferRecordᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.MotionOfferRecord) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMotionOfferRecord2ᚖwhaleᚋpkgᚋmodelsᚐMotionOfferRecord(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMotionOfferRecord2ᚖwhaleᚋpkgᚋmodelsᚐMotionOfferRecord(ctx context.Context, sel ast.SelectionSet, v *models.MotionOfferRecord) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MotionOfferRecord(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMotionOfferState2whaleᚋpkgᚋmodelsᚐMotionOfferState(ctx context.Context, v interface{}) (models.MotionOfferState, error) {
	var res models.MotionOfferState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMotionOfferState2whaleᚋpkgᚋmodelsᚐMotionOfferState(ctx context.Context, sel ast.SelectionSet, v models.MotionOfferState) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNMotionProperty2whaleᚋpkgᚋmodelsᚐMotionProperty(ctx context.Context, sel ast.SelectionSet, v models.MotionProperty) graphql.Marshaler {
	return ec._MotionProperty(ctx, sel, &v)
}

func (ec *executionContext) marshalNMotionProperty2ᚕwhaleᚋpkgᚋmodelsᚐMotionPropertyᚄ(ctx context.Context, sel ast.SelectionSet, v []models.MotionProperty) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMotionProperty2whaleᚋpkgᚋmodelsᚐMotionProperty(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMotionPropertyParam2ᚕᚖwhaleᚋpkgᚋmodelsᚐMotionPropertyParamᚄ(ctx context.Context, v interface{}) ([]*models.MotionPropertyParam, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.MotionPropertyParam, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMotionPropertyParam2ᚖwhaleᚋpkgᚋmodelsᚐMotionPropertyParam(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMotionPropertyParam2ᚖwhaleᚋpkgᚋmodelsᚐMotionPropertyParam(ctx context.Context, v interface{}) (*models.MotionPropertyParam, error) {
	res, err := ec.unmarshalInputMotionPropertyParam(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRecentMatching2whaleᚋpkgᚋmodelsᚐRecentMatching(ctx context.Context, sel ast.SelectionSet, v models.RecentMatching) graphql.Marshaler {
	return ec._RecentMatching(ctx, sel, &v)
}

func (ec *executionContext) marshalNRecentMatching2ᚕᚖwhaleᚋpkgᚋmodelsᚐRecentMatchingᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.RecentMatching) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRecentMatching2ᚖwhaleᚋpkgᚋmodelsᚐRecentMatching(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRecentMatching2ᚖwhaleᚋpkgᚋmodelsᚐRecentMatching(ctx context.Context, sel ast.SelectionSet, v *models.RecentMatching) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RecentMatching(ctx, sel, v)
}

func (ec *executionContext) unmarshalNResultCreatedBy2whaleᚋpkgᚋmodelsᚐResultCreatedBy(ctx context.Context, v interface{}) (models.ResultCreatedBy, error) {
	var res models.ResultCreatedBy
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNResultCreatedBy2whaleᚋpkgᚋmodelsᚐResultCreatedBy(ctx context.Context, sel ast.SelectionSet, v models.ResultCreatedBy) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNReviewMatchingParam2whaleᚋpkgᚋmodelsᚐReviewMatchingParam(ctx context.Context, v interface{}) (models.ReviewMatchingParam, error) {
	res, err := ec.unmarshalInputReviewMatchingParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNReviewMotionParam2whaleᚋpkgᚋmodelsᚐReviewMotionParam(ctx context.Context, v interface{}) (models.ReviewMotionParam, error) {
	res, err := ec.unmarshalInputReviewMotionParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSimpleAvatarUser2ᚕᚖwhaleᚋpkgᚋmodelsᚐSimpleAvatarUserᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.SimpleAvatarUser) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSimpleAvatarUser2ᚖwhaleᚋpkgᚋmodelsᚐSimpleAvatarUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSimpleAvatarUser2ᚖwhaleᚋpkgᚋmodelsᚐSimpleAvatarUser(ctx context.Context, sel ast.SelectionSet, v *models.SimpleAvatarUser) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SimpleAvatarUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSummary2whaleᚋpkgᚋmodelsᚐSummary(ctx context.Context, sel ast.SelectionSet, v models.Summary) graphql.Marshaler {
	return ec._Summary(ctx, sel, &v)
}

func (ec *executionContext) marshalNSummary2ᚖwhaleᚋpkgᚋmodelsᚐSummary(ctx context.Context, sel ast.SelectionSet, v *models.Summary) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Summary(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTopic2whaleᚋpkgᚋmodelsᚐTopic(ctx context.Context, sel ast.SelectionSet, v models.Topic) graphql.Marshaler {
	return ec._Topic(ctx, sel, &v)
}

func (ec *executionContext) marshalNTopic2ᚕᚖwhaleᚋpkgᚋmodelsᚐTopicᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Topic) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTopic2ᚖwhaleᚋpkgᚋmodelsᚐTopic(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTopic2ᚖwhaleᚋpkgᚋmodelsᚐTopic(ctx context.Context, sel ast.SelectionSet, v *models.Topic) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Topic(ctx, sel, v)
}

func (ec *executionContext) marshalNTopicMetrics2whaleᚋpkgᚋmodelsᚐTopicMetrics(ctx context.Context, sel ast.SelectionSet, v models.TopicMetrics) graphql.Marshaler {
	return ec._TopicMetrics(ctx, sel, &v)
}

func (ec *executionContext) marshalNTopicMetrics2ᚕwhaleᚋpkgᚋmodelsᚐTopicMetricsᚄ(ctx context.Context, sel ast.SelectionSet, v []models.TopicMetrics) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTopicMetrics2whaleᚋpkgᚋmodelsᚐTopicMetrics(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTopicToMatching2ᚕᚖwhaleᚋpkgᚋmodelsᚐTopicToMatchingᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.TopicToMatching) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTopicToMatching2ᚖwhaleᚋpkgᚋmodelsᚐTopicToMatching(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTopicToMatching2ᚖwhaleᚋpkgᚋmodelsᚐTopicToMatching(ctx context.Context, sel ast.SelectionSet, v *models.TopicToMatching) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TopicToMatching(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateCityTopicParam2whaleᚋpkgᚋmodelsᚐUpdateCityTopicParam(ctx context.Context, v interface{}) (models.UpdateCityTopicParam, error) {
	res, err := ec.unmarshalInputUpdateCityTopicParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateDurationConstraintParam2whaleᚋpkgᚋmodelsᚐUpdateDurationConstraintParam(ctx context.Context, v interface{}) (models.UpdateDurationConstraintParam, error) {
	res, err := ec.unmarshalInputUpdateDurationConstraintParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateHotTopicMetricsParam2ᚕᚖwhaleᚋpkgᚋmodelsᚐUpdateHotTopicMetricsParamᚄ(ctx context.Context, v interface{}) ([]*models.UpdateHotTopicMetricsParam, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.UpdateHotTopicMetricsParam, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUpdateHotTopicMetricsParam2ᚖwhaleᚋpkgᚋmodelsᚐUpdateHotTopicMetricsParam(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNUpdateHotTopicMetricsParam2ᚖwhaleᚋpkgᚋmodelsᚐUpdateHotTopicMetricsParam(ctx context.Context, v interface{}) (*models.UpdateHotTopicMetricsParam, error) {
	res, err := ec.unmarshalInputUpdateHotTopicMetricsParam(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateHotTopicParam2whaleᚋpkgᚋmodelsᚐUpdateHotTopicParam(ctx context.Context, v interface{}) (models.UpdateHotTopicParam, error) {
	res, err := ec.unmarshalInputUpdateHotTopicParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateMatchingDurationConstraintParam2whaleᚋpkgᚋmodelsᚐUpdateMatchingDurationConstraintParam(ctx context.Context, v interface{}) (models.UpdateMatchingDurationConstraintParam, error) {
	res, err := ec.unmarshalInputUpdateMatchingDurationConstraintParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateMatchingInvitationParam2whaleᚋpkgᚋmodelsᚐUpdateMatchingInvitationParam(ctx context.Context, v interface{}) (models.UpdateMatchingInvitationParam, error) {
	res, err := ec.unmarshalInputUpdateMatchingInvitationParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateMatchingParam2whaleᚋpkgᚋmodelsᚐUpdateMatchingParam(ctx context.Context, v interface{}) (models.UpdateMatchingParam, error) {
	res, err := ec.unmarshalInputUpdateMatchingParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateMatchingQuotaParam2whaleᚋpkgᚋmodelsᚐUpdateMatchingQuotaParam(ctx context.Context, v interface{}) (models.UpdateMatchingQuotaParam, error) {
	res, err := ec.unmarshalInputUpdateMatchingQuotaParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateMotionParam2whaleᚋpkgᚋmodelsᚐUpdateMotionParam(ctx context.Context, v interface{}) (models.UpdateMotionParam, error) {
	res, err := ec.unmarshalInputUpdateMotionParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateRecentMatchingParam2whaleᚋpkgᚋmodelsᚐUpdateRecentMatchingParam(ctx context.Context, v interface{}) (models.UpdateRecentMatchingParam, error) {
	res, err := ec.unmarshalInputUpdateRecentMatchingParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateUserJoinTopicParam2whaleᚋpkgᚋmodelsᚐUpdateUserJoinTopicParam(ctx context.Context, v interface{}) (models.UpdateUserJoinTopicParam, error) {
	res, err := ec.unmarshalInputUpdateUserJoinTopicParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2whaleᚋpkgᚋmodelsᚐUser(ctx context.Context, sel ast.SelectionSet, v models.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2ᚕᚖwhaleᚋpkgᚋmodelsᚐUserᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2ᚖwhaleᚋpkgᚋmodelsᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUser2ᚖwhaleᚋpkgᚋmodelsᚐUser(ctx context.Context, sel ast.SelectionSet, v *models.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalNUserConfirmState2ᚕᚖwhaleᚋpkgᚋmodelsᚐUserConfirmStateᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.UserConfirmState) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserConfirmState2ᚖwhaleᚋpkgᚋmodelsᚐUserConfirmState(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUserConfirmState2ᚖwhaleᚋpkgᚋmodelsᚐUserConfirmState(ctx context.Context, sel ast.SelectionSet, v *models.UserConfirmState) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserConfirmState(ctx, sel, v)
}

func (ec *executionContext) marshalNUserJoinTopic2whaleᚋpkgᚋmodelsᚐUserJoinTopic(ctx context.Context, sel ast.SelectionSet, v models.UserJoinTopic) graphql.Marshaler {
	return ec._UserJoinTopic(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserJoinTopic2ᚕᚖwhaleᚋpkgᚋmodelsᚐUserJoinTopicᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.UserJoinTopic) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserJoinTopic2ᚖwhaleᚋpkgᚋmodelsᚐUserJoinTopic(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUserJoinTopic2ᚖwhaleᚋpkgᚋmodelsᚐUserJoinTopic(ctx context.Context, sel ast.SelectionSet, v *models.UserJoinTopic) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserJoinTopic(ctx, sel, v)
}

func (ec *executionContext) marshalNUserLikeMotion2ᚕᚖwhaleᚋpkgᚋmodelsᚐUserLikeMotionᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.UserLikeMotion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserLikeMotion2ᚖwhaleᚋpkgᚋmodelsᚐUserLikeMotion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUserLikeMotion2ᚖwhaleᚋpkgᚋmodelsᚐUserLikeMotion(ctx context.Context, sel ast.SelectionSet, v *models.UserLikeMotion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserLikeMotion(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserMatchingCalenderParam2whaleᚋpkgᚋmodelsᚐUserMatchingCalenderParam(ctx context.Context, v interface{}) (models.UserMatchingCalenderParam, error) {
	res, err := ec.unmarshalInputUserMatchingCalenderParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUserMatchingInTheDayParam2whaleᚋpkgᚋmodelsᚐUserMatchingInTheDayParam(ctx context.Context, v interface{}) (models.UserMatchingInTheDayParam, error) {
	res, err := ec.unmarshalInputUserMatchingInTheDayParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserThumbsUpMotion2ᚕᚖwhaleᚋpkgᚋmodelsᚐUserThumbsUpMotionᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.UserThumbsUpMotion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserThumbsUpMotion2ᚖwhaleᚋpkgᚋmodelsᚐUserThumbsUpMotion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUserThumbsUpMotion2ᚖwhaleᚋpkgᚋmodelsᚐUserThumbsUpMotion(ctx context.Context, sel ast.SelectionSet, v *models.UserThumbsUpMotion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserThumbsUpMotion(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserUpdateMotionParam2whaleᚋpkgᚋmodelsᚐUserUpdateMotionParam(ctx context.Context, v interface{}) (models.UserUpdateMotionParam, error) {
	res, err := ec.unmarshalInputUserUpdateMotionParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalN_Any2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN_Any2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN_Any2ᚕmapᚄ(ctx context.Context, v interface{}) ([]map[string]interface{}, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]map[string]interface{}, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN_Any2map(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN_Any2ᚕmapᚄ(ctx context.Context, sel ast.SelectionSet, v []map[string]interface{}) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalN_Any2map(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN_Entity2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋpluginᚋfederationᚋfedruntimeᚐEntity(ctx context.Context, sel ast.SelectionSet, v []fedruntime.Entity) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalO_Entity2githubᚗcomᚋ99designsᚋgqlgenᚋpluginᚋfederationᚋfedruntimeᚐEntity(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalN_Service2githubᚗcomᚋ99designsᚋgqlgenᚋpluginᚋfederationᚋfedruntimeᚐService(ctx context.Context, sel ast.SelectionSet, v fedruntime.Service) graphql.Marshaler {
	return ec.__Service(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOChatGroup2ᚖwhaleᚋpkgᚋmodelsᚐChatGroup(ctx context.Context, sel ast.SelectionSet, v *models.ChatGroup) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ChatGroup(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCitiesTopicsFilter2ᚖwhaleᚋpkgᚋmodelsᚐCitiesTopicsFilter(ctx context.Context, v interface{}) (*models.CitiesTopicsFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCitiesTopicsFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalODatePeriod2ᚕwhaleᚋpkgᚋmodelsᚐDatePeriodᚄ(ctx context.Context, v interface{}) ([]models.DatePeriod, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]models.DatePeriod, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDatePeriod2whaleᚋpkgᚋmodelsᚐDatePeriod(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalODatePeriod2ᚕwhaleᚋpkgᚋmodelsᚐDatePeriodᚄ(ctx context.Context, sel ast.SelectionSet, v []models.DatePeriod) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDatePeriod2whaleᚋpkgᚋmodelsᚐDatePeriod(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalODiscoverTopicCategoryMotionFilter2ᚖwhaleᚋpkgᚋmodelsᚐDiscoverTopicCategoryMotionFilter(ctx context.Context, v interface{}) (*models.DiscoverTopicCategoryMotionFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDiscoverTopicCategoryMotionFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGender2ᚖwhaleᚋpkgᚋmodelsᚐGender(ctx context.Context, v interface{}) (*models.Gender, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(models.Gender)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGender2ᚖwhaleᚋpkgᚋmodelsᚐGender(ctx context.Context, sel ast.SelectionSet, v *models.Gender) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOGraphQLPaginator2ᚖgithubᚗcomᚋletjoyᚑclubᚋmidaᚑtoolᚋgraphqlutilᚐGraphQLPaginator(ctx context.Context, v interface{}) (*graphqlutil.GraphQLPaginator, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGraphQLPaginator(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOHotTopicsFilter2ᚖwhaleᚋpkgᚋmodelsᚐHotTopicsFilter(ctx context.Context, v interface{}) (*models.HotTopicsFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputHotTopicsFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	return res
}

func (ec *executionContext) unmarshalOMatchingFilter2ᚖwhaleᚋpkgᚋmodelsᚐMatchingFilter(ctx context.Context, v interface{}) (*models.MatchingFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMatchingFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMatchingInvitation2ᚕᚖwhaleᚋpkgᚋmodelsᚐMatchingInvitationᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.MatchingInvitation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatchingInvitation2ᚖwhaleᚋpkgᚋmodelsᚐMatchingInvitation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOMatchingInvitationFilter2ᚖwhaleᚋpkgᚋmodelsᚐMatchingInvitationFilter(ctx context.Context, v interface{}) (*models.MatchingInvitationFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMatchingInvitationFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMatchingResult2ᚖwhaleᚋpkgᚋmodelsᚐMatchingResult(ctx context.Context, sel ast.SelectionSet, v *models.MatchingResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MatchingResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMatchingResultFilter2ᚖwhaleᚋpkgᚋmodelsᚐMatchingResultFilter(ctx context.Context, v interface{}) (*models.MatchingResultFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMatchingResultFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMatchingState2ᚕwhaleᚋpkgᚋmodelsᚐMatchingStateᚄ(ctx context.Context, v interface{}) ([]models.MatchingState, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]models.MatchingState, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMatchingState2whaleᚋpkgᚋmodelsᚐMatchingState(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOMatchingState2ᚕwhaleᚋpkgᚋmodelsᚐMatchingStateᚄ(ctx context.Context, sel ast.SelectionSet, v []models.MatchingState) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatchingState2whaleᚋpkgᚋmodelsᚐMatchingState(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOMatchingState2ᚖwhaleᚋpkgᚋmodelsᚐMatchingState(ctx context.Context, v interface{}) (*models.MatchingState, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(models.MatchingState)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMatchingState2ᚖwhaleᚋpkgᚋmodelsᚐMatchingState(ctx context.Context, sel ast.SelectionSet, v *models.MatchingState) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOMotion2ᚖwhaleᚋpkgᚋmodelsᚐMotion(ctx context.Context, sel ast.SelectionSet, v *models.Motion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Motion(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMotionFilter2ᚖwhaleᚋpkgᚋmodelsᚐMotionFilter(ctx context.Context, v interface{}) (*models.MotionFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMotionFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMotionPropertyParam2ᚕᚖwhaleᚋpkgᚋmodelsᚐMotionPropertyParamᚄ(ctx context.Context, v interface{}) ([]*models.MotionPropertyParam, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.MotionPropertyParam, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMotionPropertyParam2ᚖwhaleᚋpkgᚋmodelsᚐMotionPropertyParam(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalONotifyNewMotionOfferMessageParam2ᚖwhaleᚋpkgᚋmodelsᚐNotifyNewMotionOfferMessageParam(ctx context.Context, v interface{}) (*models.NotifyNewMotionOfferMessageParam, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNotifyNewMotionOfferMessageParam(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalORecentMatchingFilter2ᚖwhaleᚋpkgᚋmodelsᚐRecentMatchingFilter(ctx context.Context, v interface{}) (*models.RecentMatchingFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRecentMatchingFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOTopicOptionConfig2ᚖwhaleᚋpkgᚋmodelsᚐTopicOptionConfig(ctx context.Context, sel ast.SelectionSet, v *models.TopicOptionConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TopicOptionConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserJoinTopicFilter2ᚖwhaleᚋpkgᚋmodelsᚐUserJoinTopicFilter(ctx context.Context, v interface{}) (*models.UserJoinTopicFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserJoinTopicFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUserMatchingFilter2ᚖwhaleᚋpkgᚋmodelsᚐUserMatchingFilter(ctx context.Context, v interface{}) (*models.UserMatchingFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserMatchingFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalO_Entity2githubᚗcomᚋ99designsᚋgqlgenᚋpluginᚋfederationᚋfedruntimeᚐEntity(ctx context.Context, sel ast.SelectionSet, v fedruntime.Entity) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.__Entity(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************

// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"
	"whale/pkg/matcher"
	"whale/pkg/models"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/99designs/gqlgen/plugin/federation/fedruntime"
	"github.com/letjoy-club/mida-tool/graphqlutil"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	CityToTopicMatching() CityToTopicMatchingResolver
	CityTopics() CityTopicsResolver
	DiscoverMotion() DiscoverMotionResolver
	Entity() EntityResolver
	EvaluatorResult() EvaluatorResultResolver
	HotTopicsInArea() HotTopicsInAreaResolver
	Matching() MatchingResolver
	MatchingInvitation() MatchingInvitationResolver
	MatchingOfTopic() MatchingOfTopicResolver
	MatchingPreview() MatchingPreviewResolver
	MatchingResult() MatchingResultResolver
	Motion() MotionResolver
	MotionOfferRecord() MotionOfferRecordResolver
	Mutation() MutationResolver
	Query() QueryResolver
	RecentMatching() RecentMatchingResolver
	Topic() TopicResolver
	TopicMetrics() TopicMetricsResolver
	TopicToMatching() TopicToMatchingResolver
	User() UserResolver
	UserJoinTopic() UserJoinTopicResolver
	UserLikeMotion() UserLikeMotionResolver
}

type DirectiveRoot struct {
	AdminOnly        func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	ComposeDirective func(ctx context.Context, obj interface{}, next graphql.Resolver, name string) (res interface{}, err error)
	InterfaceObject  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	Area struct {
		Code func(childComplexity int) int
	}

	AvailableMotionOffer struct {
		Motion        func(childComplexity int) int
		NextQuotaTime func(childComplexity int) int
	}

	CalendarEvent struct {
		ChatGroupCreatedAt func(childComplexity int) int
		FinishedAt         func(childComplexity int) int
		MatchedAt          func(childComplexity int) int
		TopicID            func(childComplexity int) int
	}

	ChatGroup struct {
		ID func(childComplexity int) int
	}

	CityToTopicMatching struct {
		City   func(childComplexity int) int
		CityID func(childComplexity int) int
		Topics func(childComplexity int) int
	}

	CityTopics struct {
		City      func(childComplexity int) int
		CityID    func(childComplexity int) int
		TopicIDs  func(childComplexity int) int
		Topics    func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	CreateMotionOfferResult struct {
		ChatGroupID func(childComplexity int) int
	}

	DiscoverMotion struct {
		AreaIDs           func(childComplexity int) int
		Areas             func(childComplexity int) int
		City              func(childComplexity int) int
		CityID            func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		DayRange          func(childComplexity int) int
		Gender            func(childComplexity int) int
		ID                func(childComplexity int) int
		LikeCount         func(childComplexity int) int
		Liked             func(childComplexity int, userID *string) int
		PreferredPeriods  func(childComplexity int) int
		Properties        func(childComplexity int) int
		Remark            func(childComplexity int) int
		Submitted         func(childComplexity int, userID *string) int
		ThumbsUp          func(childComplexity int, userID *string) int
		ThumbsUpCount     func(childComplexity int) int
		Topic             func(childComplexity int) int
		TopicID           func(childComplexity int) int
		TopicOptionConfig func(childComplexity int) int
		User              func(childComplexity int) int
		UserID            func(childComplexity int) int
		ViewCount         func(childComplexity int) int
	}

	DiscoverMotionResult struct {
		Motions   func(childComplexity int) int
		NextToken func(childComplexity int) int
	}

	DurationConstraint struct {
		RemainMotionQuota func(childComplexity int) int
		StartDate         func(childComplexity int) int
		StopDate          func(childComplexity int) int
		TotalMotionQuota  func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
		UserID            func(childComplexity int) int
	}

	Entity struct {
		FindLevelRightsByLevel    func(childComplexity int, level int) int
		FindMatchingByID          func(childComplexity int, id string) int
		FindMatchingQuotaByUserID func(childComplexity int, userID string) int
		FindTopicByID             func(childComplexity int, id string) int
		FindUserByID              func(childComplexity int, id string) int
	}

	EvaluatorResult struct {
		FailedReason func(childComplexity int) int
		Properties   func(childComplexity int) int
		Score        func(childComplexity int) int
		TimeScore    func(childComplexity int) int
	}

	HotTopicsInArea struct {
		City         func(childComplexity int) int
		CityID       func(childComplexity int) int
		TopicMetrics func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
	}

	LevelRights struct {
		Level                      func(childComplexity int) int
		MatchingDurationConstraint func(childComplexity int) int
		MatchingQuota              func(childComplexity int) int
	}

	Matching struct {
		AreaIDs          func(childComplexity int) int
		Areas            func(childComplexity int) int
		City             func(childComplexity int) int
		CityID           func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		DayRange         func(childComplexity int) int
		Deadline         func(childComplexity int) int
		Gender           func(childComplexity int) int
		ID               func(childComplexity int) int
		InChatGroup      func(childComplexity int) int
		MatchingResult   func(childComplexity int) int
		PreferredPeriods func(childComplexity int) int
		Properties       func(childComplexity int) int
		RejectedUserIDs  func(childComplexity int) int
		Remark           func(childComplexity int) int
		Reviewed         func(childComplexity int) int
		StartMatchingAt  func(childComplexity int) int
		State            func(childComplexity int) int
		Topic            func(childComplexity int) int
		TopicID          func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
		User             func(childComplexity int) int
		UserID           func(childComplexity int) int
	}

	MatchingDurationConstraint struct {
		Remain    func(childComplexity int) int
		StartDate func(childComplexity int) int
		StopDate  func(childComplexity int) int
		Total     func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	MatchingInvitation struct {
		AreaIDs          func(childComplexity int) int
		Areas            func(childComplexity int) int
		City             func(childComplexity int) int
		CityID           func(childComplexity int) int
		ConfirmState     func(childComplexity int) int
		ConfirmedAt      func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		ID               func(childComplexity int) int
		Invitee          func(childComplexity int) int
		InviteeID        func(childComplexity int) int
		MatchingIds      func(childComplexity int) int
		MatchingResult   func(childComplexity int) int
		MatchingResultId func(childComplexity int) int
		Remark           func(childComplexity int) int
		Topic            func(childComplexity int) int
		TopicID          func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
		User             func(childComplexity int) int
		UserID           func(childComplexity int) int
	}

	MatchingOfTopic struct {
		AreaIDs   func(childComplexity int) int
		Areas     func(childComplexity int) int
		City      func(childComplexity int) int
		CityID    func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		Gender    func(childComplexity int) int
		Remark    func(childComplexity int) int
		User      func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	MatchingPreview struct {
		DayRange          func(childComplexity int) int
		PreferredPeriods  func(childComplexity int) int
		Properties        func(childComplexity int) int
		Remark            func(childComplexity int) int
		TopicOptionConfig func(childComplexity int) int
		User              func(childComplexity int) int
		UserID            func(childComplexity int) int
	}

	MatchingProperty struct {
		ID     func(childComplexity int) int
		Values func(childComplexity int) int
	}

	MatchingQuota struct {
		CreatedAt   func(childComplexity int) int
		MatchingNum func(childComplexity int) int
		Remain      func(childComplexity int) int
		Total       func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		UserID      func(childComplexity int) int
	}

	MatchingResult struct {
		ChatGroup         func(childComplexity int) int
		ChatGroupID       func(childComplexity int) int
		ChatGroupState    func(childComplexity int) int
		Closed            func(childComplexity int) int
		ConfirmStates     func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		CreatedBy         func(childComplexity int) int
		DiscoverMotion    func(childComplexity int) int
		FinishedAt        func(childComplexity int) int
		ID                func(childComplexity int) int
		MatchingDegree    func(childComplexity int) int
		MatchingIDs       func(childComplexity int) int
		MatchingPreviews  func(childComplexity int) int
		MatchingScore     func(childComplexity int) int
		MotionIDs         func(childComplexity int) int
		Topic             func(childComplexity int) int
		TopicID           func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
		UserConfirmStates func(childComplexity int) int
		UserIDs           func(childComplexity int) int
		Users             func(childComplexity int) int
	}

	MatchingResultConfirmAction struct {
		Confirmed        func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		ID               func(childComplexity int) int
		MatchingResultID func(childComplexity int) int
		UserID           func(childComplexity int) int
	}

	Motion struct {
		Active            func(childComplexity int) int
		ActiveNum         func(childComplexity int) int
		Areas             func(childComplexity int) int
		City              func(childComplexity int) int
		CityID            func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		DayRange          func(childComplexity int) int
		Discoverable      func(childComplexity int) int
		Gender            func(childComplexity int) int
		ID                func(childComplexity int) int
		InOfferNum        func(childComplexity int) int
		LikeCount         func(childComplexity int) int
		Liked             func(childComplexity int) int
		OutOfferNum       func(childComplexity int) int
		PendingInNum      func(childComplexity int) int
		PendingOutNum     func(childComplexity int) int
		PreferredPeriods  func(childComplexity int) int
		Properties        func(childComplexity int) int
		RelatedMatchingID func(childComplexity int) int
		Remark            func(childComplexity int) int
		ThumbsUp          func(childComplexity int) int
		ThumbsUpCount     func(childComplexity int) int
		Topic             func(childComplexity int) int
		TopicOptionConfig func(childComplexity int) int
		User              func(childComplexity int) int
		UserID            func(childComplexity int) int
		ViewCount         func(childComplexity int) int
	}

	MotionOfferRecord struct {
		ChatChance func(childComplexity int) int
		CreatedAt  func(childComplexity int) int
		ID         func(childComplexity int) int
		Motion     func(childComplexity int) int
		MotionID   func(childComplexity int) int
		ReactAt    func(childComplexity int) int
		Remark     func(childComplexity int) int
		Reviewed   func(childComplexity int, userID *string) int
		State      func(childComplexity int) int
		ToMotion   func(childComplexity int) int
		ToMotionID func(childComplexity int) int
	}

	MotionProperty struct {
		ID     func(childComplexity int) int
		Values func(childComplexity int) int
	}

	Mutation struct {
		AcceptMotionOffer                func(childComplexity int, myMotionID string, targetMotionID string) int
		AddMatchingToRecent              func(childComplexity int, matchingID string) int
		CancelMatching                   func(childComplexity int, matchingID string) int
		CancelMatchingInvitation         func(childComplexity int, invitationID string) int
		CancelMotionOffer                func(childComplexity int, myMotionID string, targetMotionID string) int
		CancelThumbsUpMotion             func(childComplexity int, userID *string, motionID string) int
		CloseMotion                      func(childComplexity int, id string) int
		ConfirmMatchingInvitation        func(childComplexity int, userID *string, invitationID string, confirm bool) int
		ConfirmMatchingResult            func(childComplexity int, userID *string, matchingID string, reject bool) int
		ConfirmMatchingResultV2          func(childComplexity int, userID *string, matchingID string, confirm bool) int
		CreateCityTopics                 func(childComplexity int, param models.CreateCityTopicParam) int
		CreateMatching                   func(childComplexity int, userID *string, param models.CreateMatchingParam) int
		CreateMatchingInvitation         func(childComplexity int, userID *string, param models.CreateMatchingInvitationParam) int
		CreateMatchingV2                 func(childComplexity int, userID *string, param models.CreateMatchingParamV2) int
		CreateMotion                     func(childComplexity int, userID *string, param models.CreateMotionParam) int
		CreateMotionOffer                func(childComplexity int, myMotionID string, targetMotionID string) int
		CreateUserJoinTopic              func(childComplexity int, param models.CreateUserJoinTopicParam) int
		FinishMatching                   func(childComplexity int, matchingID string) int
		FinishMotionOffer                func(childComplexity int, fromMotionID string, toMotionID string) int
		GetAvailableMotionOffer          func(childComplexity int, userID *string, targetMotionID string) int
		GetMatchingScore                 func(childComplexity int, id1 string, id2 string) int
		LikeMotion                       func(childComplexity int, userID *string, motionID string) int
		NotifyNewMotionOffer             func(childComplexity int, param *models.NotifyNewMotionOfferMessageParam) int
		RefreshTopicMetrics              func(childComplexity int) int
		RejectMotionOffer                func(childComplexity int, myMotionID string, targetMotionID string) int
		ReviewMatching                   func(childComplexity int, matchingID string, param models.ReviewMatchingParam) int
		ReviewMotionOffer                func(childComplexity int, userID *string, fromMotionID string, toMotionID string, param models.ReviewMotionParam) int
		SendChatInOffer                  func(childComplexity int, myMotionID string, targetMotionID string, sentence string) int
		SendMotionOfferAcceptMessage     func(childComplexity int, id int) int
		StartMatching                    func(childComplexity int) int
		ThumbsUpMotion                   func(childComplexity int, userID *string, motionID string) int
		ThumbsUpMotions                  func(childComplexity int, userID *string, paginator *graphqlutil.GraphQLPaginator) int
		ThumbsUpMotionsCount             func(childComplexity int, userID *string) int
		UnlikeMotion                     func(childComplexity int, userID *string, motionID string) int
		UpdateCityTopics                 func(childComplexity int, cityID string, param models.UpdateCityTopicParam) int
		UpdateDurationConstraint         func(childComplexity int, userID string, param models.UpdateDurationConstraintParam) int
		UpdateHotTopicsInArea            func(childComplexity int, cityID string, param models.UpdateHotTopicParam) int
		UpdateMatching                   func(childComplexity int, matchingID string, param models.UpdateMatchingParam) int
		UpdateMatchingDurationConstraint func(childComplexity int, userID string, param models.UpdateMatchingDurationConstraintParam) int
		UpdateMatchingInvitation         func(childComplexity int, invitationID string, param models.UpdateMatchingInvitationParam) int
		UpdateMatchingQuota              func(childComplexity int, userID string, param models.UpdateMatchingQuotaParam) int
		UpdateMotion                     func(childComplexity int, id string, param models.UpdateMotionParam) int
		UpdateRecentMatching             func(childComplexity int, id string, param models.UpdateRecentMatchingParam) int
		UpdateUserJoinTopic              func(childComplexity int, id int, param models.UpdateUserJoinTopicParam) int
		UserUpdateMotion                 func(childComplexity int, myMotionID string, param models.UserUpdateMotionParam) int
	}

	Query struct {
		ActiveMotions                 func(childComplexity int, userID *string) int
		ChatGroupByResultID           func(childComplexity int, resultID int) int
		CitiesTopics                  func(childComplexity int, filter *models.CitiesTopicsFilter, paginator *graphqlutil.GraphQLPaginator) int
		CitiesTopicsCount             func(childComplexity int, filter *models.CitiesTopicsFilter) int
		CityDistribution              func(childComplexity int) int
		CityTopics                    func(childComplexity int, cityID string) int
		DiscoverCategoryMotions       func(childComplexity int, userID *string, filter *models.DiscoverTopicCategoryMotionFilter, topicCategoryID string, nextToken *string) int
		DiscoverLatestCategoryMotions func(childComplexity int, filter models.DiscoverTopicCategoryMotionFilter, topicCategoryID string, lastID *string) int
		GetDiscoverMotion             func(childComplexity int, motionID string) int
		GetMotionOffer                func(childComplexity int, motionID string, toMotionID string) int
		HotTopics                     func(childComplexity int, filter *models.HotTopicsFilter, paginator *graphqlutil.GraphQLPaginator) int
		HotTopicsCount                func(childComplexity int, filter *models.HotTopicsFilter) int
		HotTopicsInArea               func(childComplexity int, cityID *string) int
		InMotionOffers                func(childComplexity int, motionID string) int
		Invitation                    func(childComplexity int, userID *string, id string) int
		Invitations                   func(childComplexity int, userID *string, paginator *graphqlutil.GraphQLPaginator) int
		InvitationsCount              func(childComplexity int, userID *string) int
		LikedMotions                  func(childComplexity int, userID *string, paginator *graphqlutil.GraphQLPaginator) int
		LikedMotionsCount             func(childComplexity int, userID *string) int
		Matching                      func(childComplexity int, id string) int
		MatchingDurationConstraints   func(childComplexity int, userID string) int
		MatchingInvitations           func(childComplexity int, filter *models.MatchingInvitationFilter, paginator *graphqlutil.GraphQLPaginator) int
		MatchingInvitationsCount      func(childComplexity int, filter *models.MatchingInvitationFilter) int
		MatchingResult                func(childComplexity int, id int) int
		MatchingResultByChatGroupID   func(childComplexity int, userID *string, chatGroupID string) int
		MatchingResults               func(childComplexity int, filter *models.MatchingResultFilter, paginator *graphqlutil.GraphQLPaginator) int
		MatchingResultsCount          func(childComplexity int, filter *models.MatchingResultFilter) int
		Matchings                     func(childComplexity int, filter *models.MatchingFilter, paginator *graphqlutil.GraphQLPaginator) int
		MatchingsCount                func(childComplexity int, filter *models.MatchingFilter) int
		Motion                        func(childComplexity int, id string) int
		MotionSummary                 func(childComplexity int) int
		Motions                       func(childComplexity int, filter *models.MotionFilter, paginator *graphqlutil.GraphQLPaginator) int
		MotionsCount                  func(childComplexity int, filter *models.MotionFilter) int
		OutMotionOffers               func(childComplexity int, motionID string) int
		PreviewMatchingsOfTopic       func(childComplexity int, cityID string, topicID string, limit *int) int
		RecentMatching                func(childComplexity int, id string) int
		RecentMatchings               func(childComplexity int, filter *models.RecentMatchingFilter, paginator *graphqlutil.GraphQLPaginator) int
		RecentMatchingsCount          func(childComplexity int, filter *models.RecentMatchingFilter) int
		TopicDistribution             func(childComplexity int) int
		UnconfirmedInvitationCount    func(childComplexity int, userID *string) int
		UnconfirmedInvitations        func(childComplexity int, userID *string) int
		UnconfirmedUserMatchings      func(childComplexity int, userID *string) int
		UserDurationConstraint        func(childComplexity int, userID string) int
		UserJoinTopic                 func(childComplexity int, id int) int
		UserJoinTopics                func(childComplexity int, filter *models.UserJoinTopicFilter, paginator *graphqlutil.GraphQLPaginator) int
		UserJoinTopicsCount           func(childComplexity int, filter *models.UserJoinTopicFilter) int
		UserMatchingCalendar          func(childComplexity int, userID *string, param models.UserMatchingCalenderParam) int
		UserMatchingQuota             func(childComplexity int, userID string) int
		UserMatchings                 func(childComplexity int, userID *string, filter *models.UserMatchingFilter, paginator *graphqlutil.GraphQLPaginator) int
		UserMatchingsCount            func(childComplexity int, userID *string, filter *models.UserMatchingFilter) int
		UserMatchingsInTheDay         func(childComplexity int, userID *string, param models.UserMatchingInTheDayParam) int
		UserMotions                   func(childComplexity int, userID *string, paginator *graphqlutil.GraphQLPaginator) int
		UserMotionsCount              func(childComplexity int, userID *string) int
		YesterdayMatchingCount        func(childComplexity int) int
		__resolve__service            func(childComplexity int) int
		__resolve_entities            func(childComplexity int, representations []map[string]interface{}) int
	}

	RecentMatching struct {
		City        func(childComplexity int) int
		CityID      func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		MatchingIDs func(childComplexity int) int
		Matchings   func(childComplexity int) int
		Topic       func(childComplexity int) int
		TopicID     func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	SimpleAvatarUser struct {
		Avatar   func(childComplexity int) int
		Nickname func(childComplexity int) int
	}

	Summary struct {
		Count func(childComplexity int) int
	}

	Topic struct {
		FuzzyMatchingNum func(childComplexity int, cityID *string) int
		ID               func(childComplexity int) int
		MatchingNum      func(childComplexity int, cityID *string) int
		RecentUsers      func(childComplexity int, cityID *string) int
	}

	TopicMetrics struct {
		Heat     func(childComplexity int) int
		ID       func(childComplexity int) int
		Matched  func(childComplexity int) int
		Matching func(childComplexity int) int
		Topic    func(childComplexity int) int
	}

	TopicOptionConfig struct {
		TopicID func(childComplexity int) int
	}

	TopicToMatching struct {
		MatchingIds func(childComplexity int) int
		Topic       func(childComplexity int) int
		TopicID     func(childComplexity int) int
	}

	User struct {
		ID            func(childComplexity int) int
		MatchingQuota func(childComplexity int) int
	}

	UserConfirmState struct {
		State  func(childComplexity int) int
		UserID func(childComplexity int) int
	}

	UserJoinTopic struct {
		City             func(childComplexity int) int
		CityID           func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		ID               func(childComplexity int) int
		LatestMatchingID func(childComplexity int) int
		Matching         func(childComplexity int) int
		Topic            func(childComplexity int) int
		TopicID          func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
		User             func(childComplexity int) int
		UserID           func(childComplexity int) int
	}

	UserLikeMotion struct {
		CreatedAt  func(childComplexity int) int
		Motion     func(childComplexity int) int
		ToMotionID func(childComplexity int) int
		ToUserID   func(childComplexity int) int
		UserID     func(childComplexity int) int
	}

	UserThumbsUpMotion struct {
		CreatedAt  func(childComplexity int) int
		ToMotionID func(childComplexity int) int
		UserID     func(childComplexity int) int
	}

	_Service struct {
		SDL func(childComplexity int) int
	}
}

type CityToTopicMatchingResolver interface {
	City(ctx context.Context, obj *models.CityToTopicMatching) (*models.Area, error)
}
type CityTopicsResolver interface {
	Topics(ctx context.Context, obj *models.CityTopics) ([]*models.Topic, error)
	City(ctx context.Context, obj *models.CityTopics) (*models.Area, error)
}
type DiscoverMotionResolver interface {
	Gender(ctx context.Context, obj *models.Motion) (models.Gender, error)

	PreferredPeriods(ctx context.Context, obj *models.Motion) ([]models.DatePeriod, error)

	Liked(ctx context.Context, obj *models.Motion, userID *string) (bool, error)
	Submitted(ctx context.Context, obj *models.Motion, userID *string) (bool, error)
	ThumbsUp(ctx context.Context, obj *models.Motion, userID *string) (bool, error)
	Topic(ctx context.Context, obj *models.Motion) (*models.Topic, error)
	TopicOptionConfig(ctx context.Context, obj *models.Motion) (*models.TopicOptionConfig, error)
	User(ctx context.Context, obj *models.Motion) (*models.User, error)
	City(ctx context.Context, obj *models.Motion) (*models.Area, error)
	Areas(ctx context.Context, obj *models.Motion) ([]*models.Area, error)
}
type EntityResolver interface {
	FindLevelRightsByLevel(ctx context.Context, level int) (*models.LevelRights, error)
	FindMatchingByID(ctx context.Context, id string) (*models.Matching, error)
	FindMatchingQuotaByUserID(ctx context.Context, userID string) (*models.MatchingQuota, error)
	FindTopicByID(ctx context.Context, id string) (*models.Topic, error)
	FindUserByID(ctx context.Context, id string) (*models.User, error)
}
type EvaluatorResultResolver interface {
	FailedReason(ctx context.Context, obj *matcher.EvaluatorResult) (string, error)
}
type HotTopicsInAreaResolver interface {
	City(ctx context.Context, obj *models.HotTopicsInArea) (*models.Area, error)
}
type MatchingResolver interface {
	Gender(ctx context.Context, obj *models.Matching) (models.Gender, error)
	State(ctx context.Context, obj *models.Matching) (models.MatchingState, error)

	PreferredPeriods(ctx context.Context, obj *models.Matching) ([]models.DatePeriod, error)

	MatchingResult(ctx context.Context, obj *models.Matching) (*models.MatchingResult, error)
	Reviewed(ctx context.Context, obj *models.Matching) (bool, error)
	User(ctx context.Context, obj *models.Matching) (*models.User, error)
	Topic(ctx context.Context, obj *models.Matching) (*models.Topic, error)
	Areas(ctx context.Context, obj *models.Matching) ([]*models.Area, error)
	City(ctx context.Context, obj *models.Matching) (*models.Area, error)
}
type MatchingInvitationResolver interface {
	ConfirmState(ctx context.Context, obj *models.MatchingInvitation) (models.InvitationConfirmState, error)

	Invitee(ctx context.Context, obj *models.MatchingInvitation) (*models.User, error)
	Topic(ctx context.Context, obj *models.MatchingInvitation) (*models.Topic, error)
	Areas(ctx context.Context, obj *models.MatchingInvitation) ([]*models.Area, error)
	City(ctx context.Context, obj *models.MatchingInvitation) (*models.Area, error)
	User(ctx context.Context, obj *models.MatchingInvitation) (*models.User, error)
	MatchingResult(ctx context.Context, obj *models.MatchingInvitation) (*models.MatchingResult, error)
}
type MatchingOfTopicResolver interface {
	Gender(ctx context.Context, obj *models.Matching) (models.Gender, error)

	User(ctx context.Context, obj *models.Matching) (*models.User, error)
	City(ctx context.Context, obj *models.Matching) (*models.Area, error)
	Areas(ctx context.Context, obj *models.Matching) ([]*models.Area, error)
}
type MatchingPreviewResolver interface {
	PreferredPeriods(ctx context.Context, obj *models.Matching) ([]models.DatePeriod, error)
	TopicOptionConfig(ctx context.Context, obj *models.Matching) (*models.TopicOptionConfig, error)
	User(ctx context.Context, obj *models.Matching) (*models.User, error)
}
type MatchingResultResolver interface {
	ConfirmStates(ctx context.Context, obj *models.MatchingResult) ([]models.MatchingResultConfirmState, error)
	UserConfirmStates(ctx context.Context, obj *models.MatchingResult) ([]*models.UserConfirmState, error)

	ChatGroupState(ctx context.Context, obj *models.MatchingResult) (models.ChatGroupState, error)

	CreatedBy(ctx context.Context, obj *models.MatchingResult) (models.ResultCreatedBy, error)
	Users(ctx context.Context, obj *models.MatchingResult) ([]*models.User, error)
	DiscoverMotion(ctx context.Context, obj *models.MatchingResult) ([]*models.Motion, error)
	MatchingPreviews(ctx context.Context, obj *models.MatchingResult) ([]*models.Matching, error)
	Topic(ctx context.Context, obj *models.MatchingResult) (*models.Topic, error)
	ChatGroup(ctx context.Context, obj *models.MatchingResult) (*models.ChatGroup, error)
	MatchingDegree(ctx context.Context, obj *models.MatchingResult) (int, error)
}
type MotionResolver interface {
	PreferredPeriods(ctx context.Context, obj *models.Motion) ([]models.DatePeriod, error)
	Gender(ctx context.Context, obj *models.Motion) (models.Gender, error)

	Liked(ctx context.Context, obj *models.Motion) (bool, error)

	ThumbsUp(ctx context.Context, obj *models.Motion) (bool, error)
	Topic(ctx context.Context, obj *models.Motion) (*models.Topic, error)
	TopicOptionConfig(ctx context.Context, obj *models.Motion) (*models.TopicOptionConfig, error)
	User(ctx context.Context, obj *models.Motion) (*models.User, error)
	City(ctx context.Context, obj *models.Motion) (*models.Area, error)
	Areas(ctx context.Context, obj *models.Motion) ([]*models.Area, error)
}
type MotionOfferRecordResolver interface {
	State(ctx context.Context, obj *models.MotionOfferRecord) (models.MotionOfferState, error)

	Reviewed(ctx context.Context, obj *models.MotionOfferRecord, userID *string) (bool, error)
	ToMotion(ctx context.Context, obj *models.MotionOfferRecord) (*models.Motion, error)
	Motion(ctx context.Context, obj *models.MotionOfferRecord) (*models.Motion, error)
}
type MutationResolver interface {
	RefreshTopicMetrics(ctx context.Context) (*string, error)
	UpdateDurationConstraint(ctx context.Context, userID string, param models.UpdateDurationConstraintParam) (*string, error)
	CreateMatchingInvitation(ctx context.Context, userID *string, param models.CreateMatchingInvitationParam) (*models.MatchingInvitation, error)
	CancelMatchingInvitation(ctx context.Context, invitationID string) (*string, error)
	ConfirmMatchingInvitation(ctx context.Context, userID *string, invitationID string, confirm bool) (*string, error)
	UpdateMatchingInvitation(ctx context.Context, invitationID string, param models.UpdateMatchingInvitationParam) (*models.MatchingInvitation, error)
	CreateMatching(ctx context.Context, userID *string, param models.CreateMatchingParam) (*models.Matching, error)
	CreateMatchingV2(ctx context.Context, userID *string, param models.CreateMatchingParamV2) (*models.Matching, error)
	UpdateMatching(ctx context.Context, matchingID string, param models.UpdateMatchingParam) (*models.Matching, error)
	UpdateMatchingQuota(ctx context.Context, userID string, param models.UpdateMatchingQuotaParam) (string, error)
	UpdateMatchingDurationConstraint(ctx context.Context, userID string, param models.UpdateMatchingDurationConstraintParam) (string, error)
	ConfirmMatchingResult(ctx context.Context, userID *string, matchingID string, reject bool) (*string, error)
	ConfirmMatchingResultV2(ctx context.Context, userID *string, matchingID string, confirm bool) (*string, error)
	CancelMatching(ctx context.Context, matchingID string) (*string, error)
	StartMatching(ctx context.Context) (*string, error)
	FinishMatching(ctx context.Context, matchingID string) (*string, error)
	ReviewMatching(ctx context.Context, matchingID string, param models.ReviewMatchingParam) (*string, error)
	UpdateRecentMatching(ctx context.Context, id string, param models.UpdateRecentMatchingParam) (*models.RecentMatching, error)
	AddMatchingToRecent(ctx context.Context, matchingID string) (*models.RecentMatching, error)
	GetMatchingScore(ctx context.Context, id1 string, id2 string) (*matcher.EvaluatorResult, error)
	GetAvailableMotionOffer(ctx context.Context, userID *string, targetMotionID string) (*models.AvailableMotionOffer, error)
	CreateMotionOffer(ctx context.Context, myMotionID string, targetMotionID string) (*models.CreateMotionOfferResult, error)
	CancelMotionOffer(ctx context.Context, myMotionID string, targetMotionID string) (*string, error)
	AcceptMotionOffer(ctx context.Context, myMotionID string, targetMotionID string) (*string, error)
	RejectMotionOffer(ctx context.Context, myMotionID string, targetMotionID string) (*string, error)
	SendChatInOffer(ctx context.Context, myMotionID string, targetMotionID string, sentence string) (*string, error)
	FinishMotionOffer(ctx context.Context, fromMotionID string, toMotionID string) (*string, error)
	NotifyNewMotionOffer(ctx context.Context, param *models.NotifyNewMotionOfferMessageParam) (*string, error)
	SendMotionOfferAcceptMessage(ctx context.Context, id int) (*string, error)
	CreateMotion(ctx context.Context, userID *string, param models.CreateMotionParam) (*models.Motion, error)
	UpdateMotion(ctx context.Context, id string, param models.UpdateMotionParam) (*models.Motion, error)
	UserUpdateMotion(ctx context.Context, myMotionID string, param models.UserUpdateMotionParam) (*models.Motion, error)
	CloseMotion(ctx context.Context, id string) (*string, error)
	ReviewMotionOffer(ctx context.Context, userID *string, fromMotionID string, toMotionID string, param models.ReviewMotionParam) (*string, error)
	CreateCityTopics(ctx context.Context, param models.CreateCityTopicParam) (*models.CityTopics, error)
	UpdateCityTopics(ctx context.Context, cityID string, param models.UpdateCityTopicParam) (*models.CityTopics, error)
	UpdateHotTopicsInArea(ctx context.Context, cityID string, param models.UpdateHotTopicParam) (*models.HotTopicsInArea, error)
	UpdateUserJoinTopic(ctx context.Context, id int, param models.UpdateUserJoinTopicParam) (*models.UserJoinTopic, error)
	CreateUserJoinTopic(ctx context.Context, param models.CreateUserJoinTopicParam) (*models.UserJoinTopic, error)
	LikeMotion(ctx context.Context, userID *string, motionID string) (int, error)
	UnlikeMotion(ctx context.Context, userID *string, motionID string) (int, error)
	ThumbsUpMotion(ctx context.Context, userID *string, motionID string) (*string, error)
	CancelThumbsUpMotion(ctx context.Context, userID *string, motionID string) (*string, error)
	ThumbsUpMotions(ctx context.Context, userID *string, paginator *graphqlutil.GraphQLPaginator) ([]*models.UserThumbsUpMotion, error)
	ThumbsUpMotionsCount(ctx context.Context, userID *string) (*models.Summary, error)
}
type QueryResolver interface {
	ChatGroupByResultID(ctx context.Context, resultID int) (*models.ChatGroup, error)
	UserDurationConstraint(ctx context.Context, userID string) (*models.DurationConstraint, error)
	YesterdayMatchingCount(ctx context.Context) (int, error)
	MotionSummary(ctx context.Context) (map[string]interface{}, error)
	MatchingInvitations(ctx context.Context, filter *models.MatchingInvitationFilter, paginator *graphqlutil.GraphQLPaginator) ([]*models.MatchingInvitation, error)
	MatchingInvitationsCount(ctx context.Context, filter *models.MatchingInvitationFilter) (*models.Summary, error)
	Invitations(ctx context.Context, userID *string, paginator *graphqlutil.GraphQLPaginator) ([]*models.MatchingInvitation, error)
	Invitation(ctx context.Context, userID *string, id string) (*models.MatchingInvitation, error)
	InvitationsCount(ctx context.Context, userID *string) (*models.Summary, error)
	Matching(ctx context.Context, id string) (*models.Matching, error)
	UserMatchingQuota(ctx context.Context, userID string) (*models.MatchingQuota, error)
	UserMatchingCalendar(ctx context.Context, userID *string, param models.UserMatchingCalenderParam) ([]*models.CalendarEvent, error)
	UserMatchingsInTheDay(ctx context.Context, userID *string, param models.UserMatchingInTheDayParam) ([]*models.MatchingResult, error)
	MatchingResultByChatGroupID(ctx context.Context, userID *string, chatGroupID string) (*models.MatchingResult, error)
	Matchings(ctx context.Context, filter *models.MatchingFilter, paginator *graphqlutil.GraphQLPaginator) ([]*models.Matching, error)
	MatchingsCount(ctx context.Context, filter *models.MatchingFilter) (*models.Summary, error)
	MatchingResult(ctx context.Context, id int) (*models.MatchingResult, error)
	MatchingResults(ctx context.Context, filter *models.MatchingResultFilter, paginator *graphqlutil.GraphQLPaginator) ([]*models.MatchingResult, error)
	MatchingResultsCount(ctx context.Context, filter *models.MatchingResultFilter) (*models.Summary, error)
	UserMatchings(ctx context.Context, userID *string, filter *models.UserMatchingFilter, paginator *graphqlutil.GraphQLPaginator) ([]*models.Matching, error)
	UnconfirmedUserMatchings(ctx context.Context, userID *string) ([]*models.Matching, error)
	UserMatchingsCount(ctx context.Context, userID *string, filter *models.UserMatchingFilter) (*models.Summary, error)
	PreviewMatchingsOfTopic(ctx context.Context, cityID string, topicID string, limit *int) ([]*models.Matching, error)
	UnconfirmedInvitations(ctx context.Context, userID *string) ([]*models.MatchingInvitation, error)
	UnconfirmedInvitationCount(ctx context.Context, userID *string) (*models.Summary, error)
	RecentMatchings(ctx context.Context, filter *models.RecentMatchingFilter, paginator *graphqlutil.GraphQLPaginator) ([]*models.RecentMatching, error)
	RecentMatchingsCount(ctx context.Context, filter *models.RecentMatchingFilter) (*models.Summary, error)
	RecentMatching(ctx context.Context, id string) (*models.RecentMatching, error)
	TopicDistribution(ctx context.Context) ([]*models.TopicToMatching, error)
	CityDistribution(ctx context.Context) ([]*models.CityToTopicMatching, error)
	MatchingDurationConstraints(ctx context.Context, userID string) (*models.MatchingDurationConstraint, error)
	DiscoverCategoryMotions(ctx context.Context, userID *string, filter *models.DiscoverTopicCategoryMotionFilter, topicCategoryID string, nextToken *string) (*models.DiscoverMotionResult, error)
	DiscoverLatestCategoryMotions(ctx context.Context, filter models.DiscoverTopicCategoryMotionFilter, topicCategoryID string, lastID *string) ([]*models.Motion, error)
	GetDiscoverMotion(ctx context.Context, motionID string) (*models.Motion, error)
	OutMotionOffers(ctx context.Context, motionID string) ([]*models.MotionOfferRecord, error)
	InMotionOffers(ctx context.Context, motionID string) ([]*models.MotionOfferRecord, error)
	GetMotionOffer(ctx context.Context, motionID string, toMotionID string) (*models.MotionOfferRecord, error)
	Motion(ctx context.Context, id string) (*models.Motion, error)
	UserMotions(ctx context.Context, userID *string, paginator *graphqlutil.GraphQLPaginator) ([]*models.Motion, error)
	UserMotionsCount(ctx context.Context, userID *string) (*models.Summary, error)
	ActiveMotions(ctx context.Context, userID *string) ([]*models.Motion, error)
	Motions(ctx context.Context, filter *models.MotionFilter, paginator *graphqlutil.GraphQLPaginator) ([]*models.Motion, error)
	MotionsCount(ctx context.Context, filter *models.MotionFilter) (*models.Summary, error)
	CityTopics(ctx context.Context, cityID string) (*models.CityTopics, error)
	CitiesTopics(ctx context.Context, filter *models.CitiesTopicsFilter, paginator *graphqlutil.GraphQLPaginator) ([]*models.CityTopics, error)
	CitiesTopicsCount(ctx context.Context, filter *models.CitiesTopicsFilter) (*models.Summary, error)
	HotTopicsInArea(ctx context.Context, cityID *string) (*models.HotTopicsInArea, error)
	HotTopics(ctx context.Context, filter *models.HotTopicsFilter, paginator *graphqlutil.GraphQLPaginator) ([]*models.HotTopicsInArea, error)
	HotTopicsCount(ctx context.Context, filter *models.HotTopicsFilter) (*models.Summary, error)
	UserJoinTopics(ctx context.Context, filter *models.UserJoinTopicFilter, paginator *graphqlutil.GraphQLPaginator) ([]*models.UserJoinTopic, error)
	UserJoinTopicsCount(ctx context.Context, filter *models.UserJoinTopicFilter) (*models.Summary, error)
	UserJoinTopic(ctx context.Context, id int) (*models.UserJoinTopic, error)
	LikedMotions(ctx context.Context, userID *string, paginator *graphqlutil.GraphQLPaginator) ([]*models.UserLikeMotion, error)
	LikedMotionsCount(ctx context.Context, userID *string) (*models.Summary, error)
}
type RecentMatchingResolver interface {
	Topic(ctx context.Context, obj *models.RecentMatching) (*models.Topic, error)
	City(ctx context.Context, obj *models.RecentMatching) (*models.Area, error)
	Matchings(ctx context.Context, obj *models.RecentMatching) ([]*models.Matching, error)
}
type TopicResolver interface {
	RecentUsers(ctx context.Context, obj *models.Topic, cityID *string) ([]*models.SimpleAvatarUser, error)
	MatchingNum(ctx context.Context, obj *models.Topic, cityID *string) (int, error)
	FuzzyMatchingNum(ctx context.Context, obj *models.Topic, cityID *string) (int, error)
}
type TopicMetricsResolver interface {
	Topic(ctx context.Context, obj *models.TopicMetrics) (*models.Topic, error)
}
type TopicToMatchingResolver interface {
	Topic(ctx context.Context, obj *models.TopicToMatching) (*models.Topic, error)
}
type UserResolver interface {
	MatchingQuota(ctx context.Context, obj *models.User) (*models.MatchingQuota, error)
}
type UserJoinTopicResolver interface {
	Topic(ctx context.Context, obj *models.UserJoinTopic) (*models.Topic, error)
	City(ctx context.Context, obj *models.UserJoinTopic) (*models.Area, error)
	User(ctx context.Context, obj *models.UserJoinTopic) (*models.User, error)
	Matching(ctx context.Context, obj *models.UserJoinTopic) (*models.Matching, error)
}
type UserLikeMotionResolver interface {
	Motion(ctx context.Context, obj *models.UserLikeMotion) (*models.Motion, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Area.code":
		if e.complexity.Area.Code == nil {
			break
		}

		return e.complexity.Area.Code(childComplexity), true

	case "AvailableMotionOffer.motion":
		if e.complexity.AvailableMotionOffer.Motion == nil {
			break
		}

		return e.complexity.AvailableMotionOffer.Motion(childComplexity), true

	case "AvailableMotionOffer.nextQuotaTime":
		if e.complexity.AvailableMotionOffer.NextQuotaTime == nil {
			break
		}

		return e.complexity.AvailableMotionOffer.NextQuotaTime(childComplexity), true

	case "CalendarEvent.chatGroupCreatedAt":
		if e.complexity.CalendarEvent.ChatGroupCreatedAt == nil {
			break
		}

		return e.complexity.CalendarEvent.ChatGroupCreatedAt(childComplexity), true

	case "CalendarEvent.finishedAt":
		if e.complexity.CalendarEvent.FinishedAt == nil {
			break
		}

		return e.complexity.CalendarEvent.FinishedAt(childComplexity), true

	case "CalendarEvent.matchedAt":
		if e.complexity.CalendarEvent.MatchedAt == nil {
			break
		}

		return e.complexity.CalendarEvent.MatchedAt(childComplexity), true

	case "CalendarEvent.topicId":
		if e.complexity.CalendarEvent.TopicID == nil {
			break
		}

		return e.complexity.CalendarEvent.TopicID(childComplexity), true

	case "ChatGroup.id":
		if e.complexity.ChatGroup.ID == nil {
			break
		}

		return e.complexity.ChatGroup.ID(childComplexity), true

	case "CityToTopicMatching.city":
		if e.complexity.CityToTopicMatching.City == nil {
			break
		}

		return e.complexity.CityToTopicMatching.City(childComplexity), true

	case "CityToTopicMatching.cityId":
		if e.complexity.CityToTopicMatching.CityID == nil {
			break
		}

		return e.complexity.CityToTopicMatching.CityID(childComplexity), true

	case "CityToTopicMatching.topics":
		if e.complexity.CityToTopicMatching.Topics == nil {
			break
		}

		return e.complexity.CityToTopicMatching.Topics(childComplexity), true

	case "CityTopics.city":
		if e.complexity.CityTopics.City == nil {
			break
		}

		return e.complexity.CityTopics.City(childComplexity), true

	case "CityTopics.cityId":
		if e.complexity.CityTopics.CityID == nil {
			break
		}

		return e.complexity.CityTopics.CityID(childComplexity), true

	case "CityTopics.topicIds":
		if e.complexity.CityTopics.TopicIDs == nil {
			break
		}

		return e.complexity.CityTopics.TopicIDs(childComplexity), true

	case "CityTopics.topics":
		if e.complexity.CityTopics.Topics == nil {
			break
		}

		return e.complexity.CityTopics.Topics(childComplexity), true

	case "CityTopics.updatedAt":
		if e.complexity.CityTopics.UpdatedAt == nil {
			break
		}

		return e.complexity.CityTopics.UpdatedAt(childComplexity), true

	case "CreateMotionOfferResult.chatGroupId":
		if e.complexity.CreateMotionOfferResult.ChatGroupID == nil {
			break
		}

		return e.complexity.CreateMotionOfferResult.ChatGroupID(childComplexity), true

	case "DiscoverMotion.areaIds":
		if e.complexity.DiscoverMotion.AreaIDs == nil {
			break
		}

		return e.complexity.DiscoverMotion.AreaIDs(childComplexity), true

	case "DiscoverMotion.areas":
		if e.complexity.DiscoverMotion.Areas == nil {
			break
		}

		return e.complexity.DiscoverMotion.Areas(childComplexity), true

	case "DiscoverMotion.city":
		if e.complexity.DiscoverMotion.City == nil {
			break
		}

		return e.complexity.DiscoverMotion.City(childComplexity), true

	case "DiscoverMotion.cityId":
		if e.complexity.DiscoverMotion.CityID == nil {
			break
		}

		return e.complexity.DiscoverMotion.CityID(childComplexity), true

	case "DiscoverMotion.createdAt":
		if e.complexity.DiscoverMotion.CreatedAt == nil {
			break
		}

		return e.complexity.DiscoverMotion.CreatedAt(childComplexity), true

	case "DiscoverMotion.dayRange":
		if e.complexity.DiscoverMotion.DayRange == nil {
			break
		}

		return e.complexity.DiscoverMotion.DayRange(childComplexity), true

	case "DiscoverMotion.gender":
		if e.complexity.DiscoverMotion.Gender == nil {
			break
		}

		return e.complexity.DiscoverMotion.Gender(childComplexity), true

	case "DiscoverMotion.id":
		if e.complexity.DiscoverMotion.ID == nil {
			break
		}

		return e.complexity.DiscoverMotion.ID(childComplexity), true

	case "DiscoverMotion.likeCount":
		if e.complexity.DiscoverMotion.LikeCount == nil {
			break
		}

		return e.complexity.DiscoverMotion.LikeCount(childComplexity), true

	case "DiscoverMotion.liked":
		if e.complexity.DiscoverMotion.Liked == nil {
			break
		}

		args, err := ec.field_DiscoverMotion_liked_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DiscoverMotion.Liked(childComplexity, args["userId"].(*string)), true

	case "DiscoverMotion.preferredPeriods":
		if e.complexity.DiscoverMotion.PreferredPeriods == nil {
			break
		}

		return e.complexity.DiscoverMotion.PreferredPeriods(childComplexity), true

	case "DiscoverMotion.properties":
		if e.complexity.DiscoverMotion.Properties == nil {
			break
		}

		return e.complexity.DiscoverMotion.Properties(childComplexity), true

	case "DiscoverMotion.remark":
		if e.complexity.DiscoverMotion.Remark == nil {
			break
		}

		return e.complexity.DiscoverMotion.Remark(childComplexity), true

	case "DiscoverMotion.submitted":
		if e.complexity.DiscoverMotion.Submitted == nil {
			break
		}

		args, err := ec.field_DiscoverMotion_submitted_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DiscoverMotion.Submitted(childComplexity, args["userId"].(*string)), true

	case "DiscoverMotion.thumbsUp":
		if e.complexity.DiscoverMotion.ThumbsUp == nil {
			break
		}

		args, err := ec.field_DiscoverMotion_thumbsUp_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DiscoverMotion.ThumbsUp(childComplexity, args["userId"].(*string)), true

	case "DiscoverMotion.thumbsUpCount":
		if e.complexity.DiscoverMotion.ThumbsUpCount == nil {
			break
		}

		return e.complexity.DiscoverMotion.ThumbsUpCount(childComplexity), true

	case "DiscoverMotion.topic":
		if e.complexity.DiscoverMotion.Topic == nil {
			break
		}

		return e.complexity.DiscoverMotion.Topic(childComplexity), true

	case "DiscoverMotion.topicId":
		if e.complexity.DiscoverMotion.TopicID == nil {
			break
		}

		return e.complexity.DiscoverMotion.TopicID(childComplexity), true

	case "DiscoverMotion.topicOptionConfig":
		if e.complexity.DiscoverMotion.TopicOptionConfig == nil {
			break
		}

		return e.complexity.DiscoverMotion.TopicOptionConfig(childComplexity), true

	case "DiscoverMotion.user":
		if e.complexity.DiscoverMotion.User == nil {
			break
		}

		return e.complexity.DiscoverMotion.User(childComplexity), true

	case "DiscoverMotion.userId":
		if e.complexity.DiscoverMotion.UserID == nil {
			break
		}

		return e.complexity.DiscoverMotion.UserID(childComplexity), true

	case "DiscoverMotion.viewCount":
		if e.complexity.DiscoverMotion.ViewCount == nil {
			break
		}

		return e.complexity.DiscoverMotion.ViewCount(childComplexity), true

	case "DiscoverMotionResult.motions":
		if e.complexity.DiscoverMotionResult.Motions == nil {
			break
		}

		return e.complexity.DiscoverMotionResult.Motions(childComplexity), true

	case "DiscoverMotionResult.nextToken":
		if e.complexity.DiscoverMotionResult.NextToken == nil {
			break
		}

		return e.complexity.DiscoverMotionResult.NextToken(childComplexity), true

	case "DurationConstraint.remainMotionQuota":
		if e.complexity.DurationConstraint.RemainMotionQuota == nil {
			break
		}

		return e.complexity.DurationConstraint.RemainMotionQuota(childComplexity), true

	case "DurationConstraint.startDate":
		if e.complexity.DurationConstraint.StartDate == nil {
			break
		}

		return e.complexity.DurationConstraint.StartDate(childComplexity), true

	case "DurationConstraint.stopDate":
		if e.complexity.DurationConstraint.StopDate == nil {
			break
		}

		return e.complexity.DurationConstraint.StopDate(childComplexity), true

	case "DurationConstraint.totalMotionQuota":
		if e.complexity.DurationConstraint.TotalMotionQuota == nil {
			break
		}

		return e.complexity.DurationConstraint.TotalMotionQuota(childComplexity), true

	case "DurationConstraint.updatedAt":
		if e.complexity.DurationConstraint.UpdatedAt == nil {
			break
		}

		return e.complexity.DurationConstraint.UpdatedAt(childComplexity), true

	case "DurationConstraint.userId":
		if e.complexity.DurationConstraint.UserID == nil {
			break
		}

		return e.complexity.DurationConstraint.UserID(childComplexity), true

	case "Entity.findLevelRightsByLevel":
		if e.complexity.Entity.FindLevelRightsByLevel == nil {
			break
		}

		args, err := ec.field_Entity_findLevelRightsByLevel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Entity.FindLevelRightsByLevel(childComplexity, args["level"].(int)), true

	case "Entity.findMatchingByID":
		if e.complexity.Entity.FindMatchingByID == nil {
			break
		}

		args, err := ec.field_Entity_findMatchingByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Entity.FindMatchingByID(childComplexity, args["id"].(string)), true

	case "Entity.findMatchingQuotaByUserID":
		if e.complexity.Entity.FindMatchingQuotaByUserID == nil {
			break
		}

		args, err := ec.field_Entity_findMatchingQuotaByUserID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Entity.FindMatchingQuotaByUserID(childComplexity, args["userID"].(string)), true

	case "Entity.findTopicByID":
		if e.complexity.Entity.FindTopicByID == nil {
			break
		}

		args, err := ec.field_Entity_findTopicByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Entity.FindTopicByID(childComplexity, args["id"].(string)), true

	case "Entity.findUserByID":
		if e.complexity.Entity.FindUserByID == nil {
			break
		}

		args, err := ec.field_Entity_findUserByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Entity.FindUserByID(childComplexity, args["id"].(string)), true

	case "EvaluatorResult.failedReason":
		if e.complexity.EvaluatorResult.FailedReason == nil {
			break
		}

		return e.complexity.EvaluatorResult.FailedReason(childComplexity), true

	case "EvaluatorResult.properties":
		if e.complexity.EvaluatorResult.Properties == nil {
			break
		}

		return e.complexity.EvaluatorResult.Properties(childComplexity), true

	case "EvaluatorResult.score":
		if e.complexity.EvaluatorResult.Score == nil {
			break
		}

		return e.complexity.EvaluatorResult.Score(childComplexity), true

	case "EvaluatorResult.timeScore":
		if e.complexity.EvaluatorResult.TimeScore == nil {
			break
		}

		return e.complexity.EvaluatorResult.TimeScore(childComplexity), true

	case "HotTopicsInArea.city":
		if e.complexity.HotTopicsInArea.City == nil {
			break
		}

		return e.complexity.HotTopicsInArea.City(childComplexity), true

	case "HotTopicsInArea.cityId":
		if e.complexity.HotTopicsInArea.CityID == nil {
			break
		}

		return e.complexity.HotTopicsInArea.CityID(childComplexity), true

	case "HotTopicsInArea.topicMetrics":
		if e.complexity.HotTopicsInArea.TopicMetrics == nil {
			break
		}

		return e.complexity.HotTopicsInArea.TopicMetrics(childComplexity), true

	case "HotTopicsInArea.updatedAt":
		if e.complexity.HotTopicsInArea.UpdatedAt == nil {
			break
		}

		return e.complexity.HotTopicsInArea.UpdatedAt(childComplexity), true

	case "LevelRights.level":
		if e.complexity.LevelRights.Level == nil {
			break
		}

		return e.complexity.LevelRights.Level(childComplexity), true

	case "LevelRights.matchingDurationConstraint":
		if e.complexity.LevelRights.MatchingDurationConstraint == nil {
			break
		}

		return e.complexity.LevelRights.MatchingDurationConstraint(childComplexity), true

	case "LevelRights.matchingQuota":
		if e.complexity.LevelRights.MatchingQuota == nil {
			break
		}

		return e.complexity.LevelRights.MatchingQuota(childComplexity), true

	case "Matching.areaIds":
		if e.complexity.Matching.AreaIDs == nil {
			break
		}

		return e.complexity.Matching.AreaIDs(childComplexity), true

	case "Matching.areas":
		if e.complexity.Matching.Areas == nil {
			break
		}

		return e.complexity.Matching.Areas(childComplexity), true

	case "Matching.city":
		if e.complexity.Matching.City == nil {
			break
		}

		return e.complexity.Matching.City(childComplexity), true

	case "Matching.cityId":
		if e.complexity.Matching.CityID == nil {
			break
		}

		return e.complexity.Matching.CityID(childComplexity), true

	case "Matching.createdAt":
		if e.complexity.Matching.CreatedAt == nil {
			break
		}

		return e.complexity.Matching.CreatedAt(childComplexity), true

	case "Matching.dayRange":
		if e.complexity.Matching.DayRange == nil {
			break
		}

		return e.complexity.Matching.DayRange(childComplexity), true

	case "Matching.deadline":
		if e.complexity.Matching.Deadline == nil {
			break
		}

		return e.complexity.Matching.Deadline(childComplexity), true

	case "Matching.gender":
		if e.complexity.Matching.Gender == nil {
			break
		}

		return e.complexity.Matching.Gender(childComplexity), true

	case "Matching.id":
		if e.complexity.Matching.ID == nil {
			break
		}

		return e.complexity.Matching.ID(childComplexity), true

	case "Matching.inChatGroup":
		if e.complexity.Matching.InChatGroup == nil {
			break
		}

		return e.complexity.Matching.InChatGroup(childComplexity), true

	case "Matching.matchingResult":
		if e.complexity.Matching.MatchingResult == nil {
			break
		}

		return e.complexity.Matching.MatchingResult(childComplexity), true

	case "Matching.preferredPeriods":
		if e.complexity.Matching.PreferredPeriods == nil {
			break
		}

		return e.complexity.Matching.PreferredPeriods(childComplexity), true

	case "Matching.properties":
		if e.complexity.Matching.Properties == nil {
			break
		}

		return e.complexity.Matching.Properties(childComplexity), true

	case "Matching.rejectedUserIds":
		if e.complexity.Matching.RejectedUserIDs == nil {
			break
		}

		return e.complexity.Matching.RejectedUserIDs(childComplexity), true

	case "Matching.remark":
		if e.complexity.Matching.Remark == nil {
			break
		}

		return e.complexity.Matching.Remark(childComplexity), true

	case "Matching.reviewed":
		if e.complexity.Matching.Reviewed == nil {
			break
		}

		return e.complexity.Matching.Reviewed(childComplexity), true

	case "Matching.startMatchingAt":
		if e.complexity.Matching.StartMatchingAt == nil {
			break
		}

		return e.complexity.Matching.StartMatchingAt(childComplexity), true

	case "Matching.state":
		if e.complexity.Matching.State == nil {
			break
		}

		return e.complexity.Matching.State(childComplexity), true

	case "Matching.topic":
		if e.complexity.Matching.Topic == nil {
			break
		}

		return e.complexity.Matching.Topic(childComplexity), true

	case "Matching.topicId":
		if e.complexity.Matching.TopicID == nil {
			break
		}

		return e.complexity.Matching.TopicID(childComplexity), true

	case "Matching.updatedAt":
		if e.complexity.Matching.UpdatedAt == nil {
			break
		}

		return e.complexity.Matching.UpdatedAt(childComplexity), true

	case "Matching.user":
		if e.complexity.Matching.User == nil {
			break
		}

		return e.complexity.Matching.User(childComplexity), true

	case "Matching.userId":
		if e.complexity.Matching.UserID == nil {
			break
		}

		return e.complexity.Matching.UserID(childComplexity), true

	case "MatchingDurationConstraint.remain":
		if e.complexity.MatchingDurationConstraint.Remain == nil {
			break
		}

		return e.complexity.MatchingDurationConstraint.Remain(childComplexity), true

	case "MatchingDurationConstraint.startDate":
		if e.complexity.MatchingDurationConstraint.StartDate == nil {
			break
		}

		return e.complexity.MatchingDurationConstraint.StartDate(childComplexity), true

	case "MatchingDurationConstraint.stopDate":
		if e.complexity.MatchingDurationConstraint.StopDate == nil {
			break
		}

		return e.complexity.MatchingDurationConstraint.StopDate(childComplexity), true

	case "MatchingDurationConstraint.total":
		if e.complexity.MatchingDurationConstraint.Total == nil {
			break
		}

		return e.complexity.MatchingDurationConstraint.Total(childComplexity), true

	case "MatchingDurationConstraint.updatedAt":
		if e.complexity.MatchingDurationConstraint.UpdatedAt == nil {
			break
		}

		return e.complexity.MatchingDurationConstraint.UpdatedAt(childComplexity), true

	case "MatchingInvitation.areaIds":
		if e.complexity.MatchingInvitation.AreaIDs == nil {
			break
		}

		return e.complexity.MatchingInvitation.AreaIDs(childComplexity), true

	case "MatchingInvitation.areas":
		if e.complexity.MatchingInvitation.Areas == nil {
			break
		}

		return e.complexity.MatchingInvitation.Areas(childComplexity), true

	case "MatchingInvitation.city":
		if e.complexity.MatchingInvitation.City == nil {
			break
		}

		return e.complexity.MatchingInvitation.City(childComplexity), true

	case "MatchingInvitation.cityId":
		if e.complexity.MatchingInvitation.CityID == nil {
			break
		}

		return e.complexity.MatchingInvitation.CityID(childComplexity), true

	case "MatchingInvitation.confirmState":
		if e.complexity.MatchingInvitation.ConfirmState == nil {
			break
		}

		return e.complexity.MatchingInvitation.ConfirmState(childComplexity), true

	case "MatchingInvitation.confirmedAt":
		if e.complexity.MatchingInvitation.ConfirmedAt == nil {
			break
		}

		return e.complexity.MatchingInvitation.ConfirmedAt(childComplexity), true

	case "MatchingInvitation.createdAt":
		if e.complexity.MatchingInvitation.CreatedAt == nil {
			break
		}

		return e.complexity.MatchingInvitation.CreatedAt(childComplexity), true

	case "MatchingInvitation.id":
		if e.complexity.MatchingInvitation.ID == nil {
			break
		}

		return e.complexity.MatchingInvitation.ID(childComplexity), true

	case "MatchingInvitation.invitee":
		if e.complexity.MatchingInvitation.Invitee == nil {
			break
		}

		return e.complexity.MatchingInvitation.Invitee(childComplexity), true

	case "MatchingInvitation.inviteeId":
		if e.complexity.MatchingInvitation.InviteeID == nil {
			break
		}

		return e.complexity.MatchingInvitation.InviteeID(childComplexity), true

	case "MatchingInvitation.matchingIds":
		if e.complexity.MatchingInvitation.MatchingIds == nil {
			break
		}

		return e.complexity.MatchingInvitation.MatchingIds(childComplexity), true

	case "MatchingInvitation.matchingResult":
		if e.complexity.MatchingInvitation.MatchingResult == nil {
			break
		}

		return e.complexity.MatchingInvitation.MatchingResult(childComplexity), true

	case "MatchingInvitation.matchingResultId":
		if e.complexity.MatchingInvitation.MatchingResultId == nil {
			break
		}

		return e.complexity.MatchingInvitation.MatchingResultId(childComplexity), true

	case "MatchingInvitation.remark":
		if e.complexity.MatchingInvitation.Remark == nil {
			break
		}

		return e.complexity.MatchingInvitation.Remark(childComplexity), true

	case "MatchingInvitation.topic":
		if e.complexity.MatchingInvitation.Topic == nil {
			break
		}

		return e.complexity.MatchingInvitation.Topic(childComplexity), true

	case "MatchingInvitation.topicId":
		if e.complexity.MatchingInvitation.TopicID == nil {
			break
		}

		return e.complexity.MatchingInvitation.TopicID(childComplexity), true

	case "MatchingInvitation.updatedAt":
		if e.complexity.MatchingInvitation.UpdatedAt == nil {
			break
		}

		return e.complexity.MatchingInvitation.UpdatedAt(childComplexity), true

	case "MatchingInvitation.user":
		if e.complexity.MatchingInvitation.User == nil {
			break
		}

		return e.complexity.MatchingInvitation.User(childComplexity), true

	case "MatchingInvitation.userId":
		if e.complexity.MatchingInvitation.UserID == nil {
			break
		}

		return e.complexity.MatchingInvitation.UserID(childComplexity), true

	case "MatchingOfTopic.areaIds":
		if e.complexity.MatchingOfTopic.AreaIDs == nil {
			break
		}

		return e.complexity.MatchingOfTopic.AreaIDs(childComplexity), true

	case "MatchingOfTopic.areas":
		if e.complexity.MatchingOfTopic.Areas == nil {
			break
		}

		return e.complexity.MatchingOfTopic.Areas(childComplexity), true

	case "MatchingOfTopic.city":
		if e.complexity.MatchingOfTopic.City == nil {
			break
		}

		return e.complexity.MatchingOfTopic.City(childComplexity), true

	case "MatchingOfTopic.cityId":
		if e.complexity.MatchingOfTopic.CityID == nil {
			break
		}

		return e.complexity.MatchingOfTopic.CityID(childComplexity), true

	case "MatchingOfTopic.createdAt":
		if e.complexity.MatchingOfTopic.CreatedAt == nil {
			break
		}

		return e.complexity.MatchingOfTopic.CreatedAt(childComplexity), true

	case "MatchingOfTopic.gender":
		if e.complexity.MatchingOfTopic.Gender == nil {
			break
		}

		return e.complexity.MatchingOfTopic.Gender(childComplexity), true

	case "MatchingOfTopic.remark":
		if e.complexity.MatchingOfTopic.Remark == nil {
			break
		}

		return e.complexity.MatchingOfTopic.Remark(childComplexity), true

	case "MatchingOfTopic.user":
		if e.complexity.MatchingOfTopic.User == nil {
			break
		}

		return e.complexity.MatchingOfTopic.User(childComplexity), true

	case "MatchingOfTopic.userId":
		if e.complexity.MatchingOfTopic.UserID == nil {
			break
		}

		return e.complexity.MatchingOfTopic.UserID(childComplexity), true

	case "MatchingPreview.dayRange":
		if e.complexity.MatchingPreview.DayRange == nil {
			break
		}

		return e.complexity.MatchingPreview.DayRange(childComplexity), true

	case "MatchingPreview.preferredPeriods":
		if e.complexity.MatchingPreview.PreferredPeriods == nil {
			break
		}

		return e.complexity.MatchingPreview.PreferredPeriods(childComplexity), true

	case "MatchingPreview.properties":
		if e.complexity.MatchingPreview.Properties == nil {
			break
		}

		return e.complexity.MatchingPreview.Properties(childComplexity), true

	case "MatchingPreview.remark":
		if e.complexity.MatchingPreview.Remark == nil {
			break
		}

		return e.complexity.MatchingPreview.Remark(childComplexity), true

	case "MatchingPreview.topicOptionConfig":
		if e.complexity.MatchingPreview.TopicOptionConfig == nil {
			break
		}

		return e.complexity.MatchingPreview.TopicOptionConfig(childComplexity), true

	case "MatchingPreview.user":
		if e.complexity.MatchingPreview.User == nil {
			break
		}

		return e.complexity.MatchingPreview.User(childComplexity), true

	case "MatchingPreview.userId":
		if e.complexity.MatchingPreview.UserID == nil {
			break
		}

		return e.complexity.MatchingPreview.UserID(childComplexity), true

	case "MatchingProperty.id":
		if e.complexity.MatchingProperty.ID == nil {
			break
		}

		return e.complexity.MatchingProperty.ID(childComplexity), true

	case "MatchingProperty.values":
		if e.complexity.MatchingProperty.Values == nil {
			break
		}

		return e.complexity.MatchingProperty.Values(childComplexity), true

	case "MatchingQuota.createdAt":
		if e.complexity.MatchingQuota.CreatedAt == nil {
			break
		}

		return e.complexity.MatchingQuota.CreatedAt(childComplexity), true

	case "MatchingQuota.matchingNum":
		if e.complexity.MatchingQuota.MatchingNum == nil {
			break
		}

		return e.complexity.MatchingQuota.MatchingNum(childComplexity), true

	case "MatchingQuota.remain":
		if e.complexity.MatchingQuota.Remain == nil {
			break
		}

		return e.complexity.MatchingQuota.Remain(childComplexity), true

	case "MatchingQuota.total":
		if e.complexity.MatchingQuota.Total == nil {
			break
		}

		return e.complexity.MatchingQuota.Total(childComplexity), true

	case "MatchingQuota.updatedAt":
		if e.complexity.MatchingQuota.UpdatedAt == nil {
			break
		}

		return e.complexity.MatchingQuota.UpdatedAt(childComplexity), true

	case "MatchingQuota.userId":
		if e.complexity.MatchingQuota.UserID == nil {
			break
		}

		return e.complexity.MatchingQuota.UserID(childComplexity), true

	case "MatchingResult.chatGroup":
		if e.complexity.MatchingResult.ChatGroup == nil {
			break
		}

		return e.complexity.MatchingResult.ChatGroup(childComplexity), true

	case "MatchingResult.chatGroupId":
		if e.complexity.MatchingResult.ChatGroupID == nil {
			break
		}

		return e.complexity.MatchingResult.ChatGroupID(childComplexity), true

	case "MatchingResult.chatGroupState":
		if e.complexity.MatchingResult.ChatGroupState == nil {
			break
		}

		return e.complexity.MatchingResult.ChatGroupState(childComplexity), true

	case "MatchingResult.closed":
		if e.complexity.MatchingResult.Closed == nil {
			break
		}

		return e.complexity.MatchingResult.Closed(childComplexity), true

	case "MatchingResult.confirmStates":
		if e.complexity.MatchingResult.ConfirmStates == nil {
			break
		}

		return e.complexity.MatchingResult.ConfirmStates(childComplexity), true

	case "MatchingResult.createdAt":
		if e.complexity.MatchingResult.CreatedAt == nil {
			break
		}

		return e.complexity.MatchingResult.CreatedAt(childComplexity), true

	case "MatchingResult.createdBy":
		if e.complexity.MatchingResult.CreatedBy == nil {
			break
		}

		return e.complexity.MatchingResult.CreatedBy(childComplexity), true

	case "MatchingResult.discoverMotion":
		if e.complexity.MatchingResult.DiscoverMotion == nil {
			break
		}

		return e.complexity.MatchingResult.DiscoverMotion(childComplexity), true

	case "MatchingResult.finishedAt":
		if e.complexity.MatchingResult.FinishedAt == nil {
			break
		}

		return e.complexity.MatchingResult.FinishedAt(childComplexity), true

	case "MatchingResult.id":
		if e.complexity.MatchingResult.ID == nil {
			break
		}

		return e.complexity.MatchingResult.ID(childComplexity), true

	case "MatchingResult.matchingDegree":
		if e.complexity.MatchingResult.MatchingDegree == nil {
			break
		}

		return e.complexity.MatchingResult.MatchingDegree(childComplexity), true

	case "MatchingResult.matchingIds":
		if e.complexity.MatchingResult.MatchingIDs == nil {
			break
		}

		return e.complexity.MatchingResult.MatchingIDs(childComplexity), true

	case "MatchingResult.matchingPreviews":
		if e.complexity.MatchingResult.MatchingPreviews == nil {
			break
		}

		return e.complexity.MatchingResult.MatchingPreviews(childComplexity), true

	case "MatchingResult.matchingScore":
		if e.complexity.MatchingResult.MatchingScore == nil {
			break
		}

		return e.complexity.MatchingResult.MatchingScore(childComplexity), true

	case "MatchingResult.motionIds":
		if e.complexity.MatchingResult.MotionIDs == nil {
			break
		}

		return e.complexity.MatchingResult.MotionIDs(childComplexity), true

	case "MatchingResult.topic":
		if e.complexity.MatchingResult.Topic == nil {
			break
		}

		return e.complexity.MatchingResult.Topic(childComplexity), true

	case "MatchingResult.topicId":
		if e.complexity.MatchingResult.TopicID == nil {
			break
		}

		return e.complexity.MatchingResult.TopicID(childComplexity), true

	case "MatchingResult.updatedAt":
		if e.complexity.MatchingResult.UpdatedAt == nil {
			break
		}

		return e.complexity.MatchingResult.UpdatedAt(childComplexity), true

	case "MatchingResult.userConfirmStates":
		if e.complexity.MatchingResult.UserConfirmStates == nil {
			break
		}

		return e.complexity.MatchingResult.UserConfirmStates(childComplexity), true

	case "MatchingResult.userIds":
		if e.complexity.MatchingResult.UserIDs == nil {
			break
		}

		return e.complexity.MatchingResult.UserIDs(childComplexity), true

	case "MatchingResult.users":
		if e.complexity.MatchingResult.Users == nil {
			break
		}

		return e.complexity.MatchingResult.Users(childComplexity), true

	case "MatchingResultConfirmAction.confirmed":
		if e.complexity.MatchingResultConfirmAction.Confirmed == nil {
			break
		}

		return e.complexity.MatchingResultConfirmAction.Confirmed(childComplexity), true

	case "MatchingResultConfirmAction.createdAt":
		if e.complexity.MatchingResultConfirmAction.CreatedAt == nil {
			break
		}

		return e.complexity.MatchingResultConfirmAction.CreatedAt(childComplexity), true

	case "MatchingResultConfirmAction.id":
		if e.complexity.MatchingResultConfirmAction.ID == nil {
			break
		}

		return e.complexity.MatchingResultConfirmAction.ID(childComplexity), true

	case "MatchingResultConfirmAction.matchingResultId":
		if e.complexity.MatchingResultConfirmAction.MatchingResultID == nil {
			break
		}

		return e.complexity.MatchingResultConfirmAction.MatchingResultID(childComplexity), true

	case "MatchingResultConfirmAction.userId":
		if e.complexity.MatchingResultConfirmAction.UserID == nil {
			break
		}

		return e.complexity.MatchingResultConfirmAction.UserID(childComplexity), true

	case "Motion.active":
		if e.complexity.Motion.Active == nil {
			break
		}

		return e.complexity.Motion.Active(childComplexity), true

	case "Motion.activeNum":
		if e.complexity.Motion.ActiveNum == nil {
			break
		}

		return e.complexity.Motion.ActiveNum(childComplexity), true

	case "Motion.areas":
		if e.complexity.Motion.Areas == nil {
			break
		}

		return e.complexity.Motion.Areas(childComplexity), true

	case "Motion.city":
		if e.complexity.Motion.City == nil {
			break
		}

		return e.complexity.Motion.City(childComplexity), true

	case "Motion.cityId":
		if e.complexity.Motion.CityID == nil {
			break
		}

		return e.complexity.Motion.CityID(childComplexity), true

	case "Motion.createdAt":
		if e.complexity.Motion.CreatedAt == nil {
			break
		}

		return e.complexity.Motion.CreatedAt(childComplexity), true

	case "Motion.dayRange":
		if e.complexity.Motion.DayRange == nil {
			break
		}

		return e.complexity.Motion.DayRange(childComplexity), true

	case "Motion.discoverable":
		if e.complexity.Motion.Discoverable == nil {
			break
		}

		return e.complexity.Motion.Discoverable(childComplexity), true

	case "Motion.gender":
		if e.complexity.Motion.Gender == nil {
			break
		}

		return e.complexity.Motion.Gender(childComplexity), true

	case "Motion.id":
		if e.complexity.Motion.ID == nil {
			break
		}

		return e.complexity.Motion.ID(childComplexity), true

	case "Motion.inOfferNum":
		if e.complexity.Motion.InOfferNum == nil {
			break
		}

		return e.complexity.Motion.InOfferNum(childComplexity), true

	case "Motion.likeCount":
		if e.complexity.Motion.LikeCount == nil {
			break
		}

		return e.complexity.Motion.LikeCount(childComplexity), true

	case "Motion.liked":
		if e.complexity.Motion.Liked == nil {
			break
		}

		return e.complexity.Motion.Liked(childComplexity), true

	case "Motion.outOfferNum":
		if e.complexity.Motion.OutOfferNum == nil {
			break
		}

		return e.complexity.Motion.OutOfferNum(childComplexity), true

	case "Motion.pendingInNum":
		if e.complexity.Motion.PendingInNum == nil {
			break
		}

		return e.complexity.Motion.PendingInNum(childComplexity), true

	case "Motion.pendingOutNum":
		if e.complexity.Motion.PendingOutNum == nil {
			break
		}

		return e.complexity.Motion.PendingOutNum(childComplexity), true

	case "Motion.preferredPeriods":
		if e.complexity.Motion.PreferredPeriods == nil {
			break
		}

		return e.complexity.Motion.PreferredPeriods(childComplexity), true

	case "Motion.properties":
		if e.complexity.Motion.Properties == nil {
			break
		}

		return e.complexity.Motion.Properties(childComplexity), true

	case "Motion.relatedMatchingId":
		if e.complexity.Motion.RelatedMatchingID == nil {
			break
		}

		return e.complexity.Motion.RelatedMatchingID(childComplexity), true

	case "Motion.remark":
		if e.complexity.Motion.Remark == nil {
			break
		}

		return e.complexity.Motion.Remark(childComplexity), true

	case "Motion.thumbsUp":
		if e.complexity.Motion.ThumbsUp == nil {
			break
		}

		return e.complexity.Motion.ThumbsUp(childComplexity), true

	case "Motion.thumbsUpCount":
		if e.complexity.Motion.ThumbsUpCount == nil {
			break
		}

		return e.complexity.Motion.ThumbsUpCount(childComplexity), true

	case "Motion.topic":
		if e.complexity.Motion.Topic == nil {
			break
		}

		return e.complexity.Motion.Topic(childComplexity), true

	case "Motion.topicOptionConfig":
		if e.complexity.Motion.TopicOptionConfig == nil {
			break
		}

		return e.complexity.Motion.TopicOptionConfig(childComplexity), true

	case "Motion.user":
		if e.complexity.Motion.User == nil {
			break
		}

		return e.complexity.Motion.User(childComplexity), true

	case "Motion.userId":
		if e.complexity.Motion.UserID == nil {
			break
		}

		return e.complexity.Motion.UserID(childComplexity), true

	case "Motion.viewCount":
		if e.complexity.Motion.ViewCount == nil {
			break
		}

		return e.complexity.Motion.ViewCount(childComplexity), true

	case "MotionOfferRecord.chatChance":
		if e.complexity.MotionOfferRecord.ChatChance == nil {
			break
		}

		return e.complexity.MotionOfferRecord.ChatChance(childComplexity), true

	case "MotionOfferRecord.createdAt":
		if e.complexity.MotionOfferRecord.CreatedAt == nil {
			break
		}

		return e.complexity.MotionOfferRecord.CreatedAt(childComplexity), true

	case "MotionOfferRecord.id":
		if e.complexity.MotionOfferRecord.ID == nil {
			break
		}

		return e.complexity.MotionOfferRecord.ID(childComplexity), true

	case "MotionOfferRecord.motion":
		if e.complexity.MotionOfferRecord.Motion == nil {
			break
		}

		return e.complexity.MotionOfferRecord.Motion(childComplexity), true

	case "MotionOfferRecord.motionId":
		if e.complexity.MotionOfferRecord.MotionID == nil {
			break
		}

		return e.complexity.MotionOfferRecord.MotionID(childComplexity), true

	case "MotionOfferRecord.reactAt":
		if e.complexity.MotionOfferRecord.ReactAt == nil {
			break
		}

		return e.complexity.MotionOfferRecord.ReactAt(childComplexity), true

	case "MotionOfferRecord.remark":
		if e.complexity.MotionOfferRecord.Remark == nil {
			break
		}

		return e.complexity.MotionOfferRecord.Remark(childComplexity), true

	case "MotionOfferRecord.reviewed":
		if e.complexity.MotionOfferRecord.Reviewed == nil {
			break
		}

		args, err := ec.field_MotionOfferRecord_reviewed_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.MotionOfferRecord.Reviewed(childComplexity, args["userId"].(*string)), true

	case "MotionOfferRecord.state":
		if e.complexity.MotionOfferRecord.State == nil {
			break
		}

		return e.complexity.MotionOfferRecord.State(childComplexity), true

	case "MotionOfferRecord.toMotion":
		if e.complexity.MotionOfferRecord.ToMotion == nil {
			break
		}

		return e.complexity.MotionOfferRecord.ToMotion(childComplexity), true

	case "MotionOfferRecord.toMotionId":
		if e.complexity.MotionOfferRecord.ToMotionID == nil {
			break
		}

		return e.complexity.MotionOfferRecord.ToMotionID(childComplexity), true

	case "MotionProperty.id":
		if e.complexity.MotionProperty.ID == nil {
			break
		}

		return e.complexity.MotionProperty.ID(childComplexity), true

	case "MotionProperty.values":
		if e.complexity.MotionProperty.Values == nil {
			break
		}

		return e.complexity.MotionProperty.Values(childComplexity), true

	case "Mutation.acceptMotionOffer":
		if e.complexity.Mutation.AcceptMotionOffer == nil {
			break
		}

		args, err := ec.field_Mutation_acceptMotionOffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AcceptMotionOffer(childComplexity, args["myMotionId"].(string), args["targetMotionId"].(string)), true

	case "Mutation.addMatchingToRecent":
		if e.complexity.Mutation.AddMatchingToRecent == nil {
			break
		}

		args, err := ec.field_Mutation_addMatchingToRecent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddMatchingToRecent(childComplexity, args["matchingId"].(string)), true

	case "Mutation.cancelMatching":
		if e.complexity.Mutation.CancelMatching == nil {
			break
		}

		args, err := ec.field_Mutation_cancelMatching_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelMatching(childComplexity, args["matchingId"].(string)), true

	case "Mutation.cancelMatchingInvitation":
		if e.complexity.Mutation.CancelMatchingInvitation == nil {
			break
		}

		args, err := ec.field_Mutation_cancelMatchingInvitation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelMatchingInvitation(childComplexity, args["invitationId"].(string)), true

	case "Mutation.cancelMotionOffer":
		if e.complexity.Mutation.CancelMotionOffer == nil {
			break
		}

		args, err := ec.field_Mutation_cancelMotionOffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelMotionOffer(childComplexity, args["myMotionId"].(string), args["targetMotionId"].(string)), true

	case "Mutation.cancelThumbsUpMotion":
		if e.complexity.Mutation.CancelThumbsUpMotion == nil {
			break
		}

		args, err := ec.field_Mutation_cancelThumbsUpMotion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelThumbsUpMotion(childComplexity, args["userId"].(*string), args["motionId"].(string)), true

	case "Mutation.closeMotion":
		if e.complexity.Mutation.CloseMotion == nil {
			break
		}

		args, err := ec.field_Mutation_closeMotion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CloseMotion(childComplexity, args["id"].(string)), true

	case "Mutation.confirmMatchingInvitation":
		if e.complexity.Mutation.ConfirmMatchingInvitation == nil {
			break
		}

		args, err := ec.field_Mutation_confirmMatchingInvitation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfirmMatchingInvitation(childComplexity, args["userId"].(*string), args["invitationId"].(string), args["confirm"].(bool)), true

	case "Mutation.confirmMatchingResult":
		if e.complexity.Mutation.ConfirmMatchingResult == nil {
			break
		}

		args, err := ec.field_Mutation_confirmMatchingResult_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfirmMatchingResult(childComplexity, args["userId"].(*string), args["matchingId"].(string), args["reject"].(bool)), true

	case "Mutation.confirmMatchingResultV2":
		if e.complexity.Mutation.ConfirmMatchingResultV2 == nil {
			break
		}

		args, err := ec.field_Mutation_confirmMatchingResultV2_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfirmMatchingResultV2(childComplexity, args["userId"].(*string), args["matchingId"].(string), args["confirm"].(bool)), true

	case "Mutation.createCityTopics":
		if e.complexity.Mutation.CreateCityTopics == nil {
			break
		}

		args, err := ec.field_Mutation_createCityTopics_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCityTopics(childComplexity, args["param"].(models.CreateCityTopicParam)), true

	case "Mutation.createMatching":
		if e.complexity.Mutation.CreateMatching == nil {
			break
		}

		args, err := ec.field_Mutation_createMatching_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMatching(childComplexity, args["userId"].(*string), args["param"].(models.CreateMatchingParam)), true

	case "Mutation.createMatchingInvitation":
		if e.complexity.Mutation.CreateMatchingInvitation == nil {
			break
		}

		args, err := ec.field_Mutation_createMatchingInvitation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMatchingInvitation(childComplexity, args["userId"].(*string), args["param"].(models.CreateMatchingInvitationParam)), true

	case "Mutation.createMatchingV2":
		if e.complexity.Mutation.CreateMatchingV2 == nil {
			break
		}

		args, err := ec.field_Mutation_createMatchingV2_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMatchingV2(childComplexity, args["userId"].(*string), args["param"].(models.CreateMatchingParamV2)), true

	case "Mutation.createMotion":
		if e.complexity.Mutation.CreateMotion == nil {
			break
		}

		args, err := ec.field_Mutation_createMotion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMotion(childComplexity, args["userId"].(*string), args["param"].(models.CreateMotionParam)), true

	case "Mutation.createMotionOffer":
		if e.complexity.Mutation.CreateMotionOffer == nil {
			break
		}

		args, err := ec.field_Mutation_createMotionOffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMotionOffer(childComplexity, args["myMotionId"].(string), args["targetMotionId"].(string)), true

	case "Mutation.createUserJoinTopic":
		if e.complexity.Mutation.CreateUserJoinTopic == nil {
			break
		}

		args, err := ec.field_Mutation_createUserJoinTopic_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUserJoinTopic(childComplexity, args["param"].(models.CreateUserJoinTopicParam)), true

	case "Mutation.finishMatching":
		if e.complexity.Mutation.FinishMatching == nil {
			break
		}

		args, err := ec.field_Mutation_finishMatching_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FinishMatching(childComplexity, args["matchingId"].(string)), true

	case "Mutation.finishMotionOffer":
		if e.complexity.Mutation.FinishMotionOffer == nil {
			break
		}

		args, err := ec.field_Mutation_finishMotionOffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FinishMotionOffer(childComplexity, args["fromMotionId"].(string), args["toMotionId"].(string)), true

	case "Mutation.getAvailableMotionOffer":
		if e.complexity.Mutation.GetAvailableMotionOffer == nil {
			break
		}

		args, err := ec.field_Mutation_getAvailableMotionOffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GetAvailableMotionOffer(childComplexity, args["userId"].(*string), args["targetMotionId"].(string)), true

	case "Mutation.getMatchingScore":
		if e.complexity.Mutation.GetMatchingScore == nil {
			break
		}

		args, err := ec.field_Mutation_getMatchingScore_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GetMatchingScore(childComplexity, args["id1"].(string), args["id2"].(string)), true

	case "Mutation.likeMotion":
		if e.complexity.Mutation.LikeMotion == nil {
			break
		}

		args, err := ec.field_Mutation_likeMotion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.LikeMotion(childComplexity, args["userId"].(*string), args["motionId"].(string)), true

	case "Mutation.notifyNewMotionOffer":
		if e.complexity.Mutation.NotifyNewMotionOffer == nil {
			break
		}

		args, err := ec.field_Mutation_notifyNewMotionOffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.NotifyNewMotionOffer(childComplexity, args["param"].(*models.NotifyNewMotionOfferMessageParam)), true

	case "Mutation.refreshTopicMetrics":
		if e.complexity.Mutation.RefreshTopicMetrics == nil {
			break
		}

		return e.complexity.Mutation.RefreshTopicMetrics(childComplexity), true

	case "Mutation.rejectMotionOffer":
		if e.complexity.Mutation.RejectMotionOffer == nil {
			break
		}

		args, err := ec.field_Mutation_rejectMotionOffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RejectMotionOffer(childComplexity, args["myMotionId"].(string), args["targetMotionId"].(string)), true

	case "Mutation.reviewMatching":
		if e.complexity.Mutation.ReviewMatching == nil {
			break
		}

		args, err := ec.field_Mutation_reviewMatching_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ReviewMatching(childComplexity, args["matchingId"].(string), args["param"].(models.ReviewMatchingParam)), true

	case "Mutation.reviewMotionOffer":
		if e.complexity.Mutation.ReviewMotionOffer == nil {
			break
		}

		args, err := ec.field_Mutation_reviewMotionOffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ReviewMotionOffer(childComplexity, args["userId"].(*string), args["fromMotionId"].(string), args["toMotionId"].(string), args["param"].(models.ReviewMotionParam)), true

	case "Mutation.sendChatInOffer":
		if e.complexity.Mutation.SendChatInOffer == nil {
			break
		}

		args, err := ec.field_Mutation_sendChatInOffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SendChatInOffer(childComplexity, args["myMotionId"].(string), args["targetMotionId"].(string), args["sentence"].(string)), true

	case "Mutation.sendMotionOfferAcceptMessage":
		if e.complexity.Mutation.SendMotionOfferAcceptMessage == nil {
			break
		}

		args, err := ec.field_Mutation_sendMotionOfferAcceptMessage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SendMotionOfferAcceptMessage(childComplexity, args["id"].(int)), true

	case "Mutation.startMatching":
		if e.complexity.Mutation.StartMatching == nil {
			break
		}

		return e.complexity.Mutation.StartMatching(childComplexity), true

	case "Mutation.thumbsUpMotion":
		if e.complexity.Mutation.ThumbsUpMotion == nil {
			break
		}

		args, err := ec.field_Mutation_thumbsUpMotion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ThumbsUpMotion(childComplexity, args["userId"].(*string), args["motionId"].(string)), true

	case "Mutation.thumbsUpMotions":
		if e.complexity.Mutation.ThumbsUpMotions == nil {
			break
		}

		args, err := ec.field_Mutation_thumbsUpMotions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ThumbsUpMotions(childComplexity, args["userId"].(*string), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Mutation.thumbsUpMotionsCount":
		if e.complexity.Mutation.ThumbsUpMotionsCount == nil {
			break
		}

		args, err := ec.field_Mutation_thumbsUpMotionsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ThumbsUpMotionsCount(childComplexity, args["userId"].(*string)), true

	case "Mutation.unlikeMotion":
		if e.complexity.Mutation.UnlikeMotion == nil {
			break
		}

		args, err := ec.field_Mutation_unlikeMotion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnlikeMotion(childComplexity, args["userId"].(*string), args["motionId"].(string)), true

	case "Mutation.updateCityTopics":
		if e.complexity.Mutation.UpdateCityTopics == nil {
			break
		}

		args, err := ec.field_Mutation_updateCityTopics_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCityTopics(childComplexity, args["cityId"].(string), args["param"].(models.UpdateCityTopicParam)), true

	case "Mutation.updateDurationConstraint":
		if e.complexity.Mutation.UpdateDurationConstraint == nil {
			break
		}

		args, err := ec.field_Mutation_updateDurationConstraint_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateDurationConstraint(childComplexity, args["userId"].(string), args["param"].(models.UpdateDurationConstraintParam)), true

	case "Mutation.updateHotTopicsInArea":
		if e.complexity.Mutation.UpdateHotTopicsInArea == nil {
			break
		}

		args, err := ec.field_Mutation_updateHotTopicsInArea_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateHotTopicsInArea(childComplexity, args["cityId"].(string), args["param"].(models.UpdateHotTopicParam)), true

	case "Mutation.updateMatching":
		if e.complexity.Mutation.UpdateMatching == nil {
			break
		}

		args, err := ec.field_Mutation_updateMatching_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMatching(childComplexity, args["matchingId"].(string), args["param"].(models.UpdateMatchingParam)), true

	case "Mutation.updateMatchingDurationConstraint":
		if e.complexity.Mutation.UpdateMatchingDurationConstraint == nil {
			break
		}

		args, err := ec.field_Mutation_updateMatchingDurationConstraint_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMatchingDurationConstraint(childComplexity, args["userId"].(string), args["param"].(models.UpdateMatchingDurationConstraintParam)), true

	case "Mutation.updateMatchingInvitation":
		if e.complexity.Mutation.UpdateMatchingInvitation == nil {
			break
		}

		args, err := ec.field_Mutation_updateMatchingInvitation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMatchingInvitation(childComplexity, args["invitationId"].(string), args["param"].(models.UpdateMatchingInvitationParam)), true

	case "Mutation.updateMatchingQuota":
		if e.complexity.Mutation.UpdateMatchingQuota == nil {
			break
		}

		args, err := ec.field_Mutation_updateMatchingQuota_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMatchingQuota(childComplexity, args["userId"].(string), args["param"].(models.UpdateMatchingQuotaParam)), true

	case "Mutation.updateMotion":
		if e.complexity.Mutation.UpdateMotion == nil {
			break
		}

		args, err := ec.field_Mutation_updateMotion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMotion(childComplexity, args["id"].(string), args["param"].(models.UpdateMotionParam)), true

	case "Mutation.updateRecentMatching":
		if e.complexity.Mutation.UpdateRecentMatching == nil {
			break
		}

		args, err := ec.field_Mutation_updateRecentMatching_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRecentMatching(childComplexity, args["id"].(string), args["param"].(models.UpdateRecentMatchingParam)), true

	case "Mutation.updateUserJoinTopic":
		if e.complexity.Mutation.UpdateUserJoinTopic == nil {
			break
		}

		args, err := ec.field_Mutation_updateUserJoinTopic_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUserJoinTopic(childComplexity, args["id"].(int), args["param"].(models.UpdateUserJoinTopicParam)), true

	case "Mutation.userUpdateMotion":
		if e.complexity.Mutation.UserUpdateMotion == nil {
			break
		}

		args, err := ec.field_Mutation_userUpdateMotion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserUpdateMotion(childComplexity, args["myMotionId"].(string), args["param"].(models.UserUpdateMotionParam)), true

	case "Query.activeMotions":
		if e.complexity.Query.ActiveMotions == nil {
			break
		}

		args, err := ec.field_Query_activeMotions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ActiveMotions(childComplexity, args["userId"].(*string)), true

	case "Query.chatGroupByResultId":
		if e.complexity.Query.ChatGroupByResultID == nil {
			break
		}

		args, err := ec.field_Query_chatGroupByResultId_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ChatGroupByResultID(childComplexity, args["resultId"].(int)), true

	case "Query.citiesTopics":
		if e.complexity.Query.CitiesTopics == nil {
			break
		}

		args, err := ec.field_Query_citiesTopics_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CitiesTopics(childComplexity, args["filter"].(*models.CitiesTopicsFilter), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.citiesTopicsCount":
		if e.complexity.Query.CitiesTopicsCount == nil {
			break
		}

		args, err := ec.field_Query_citiesTopicsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CitiesTopicsCount(childComplexity, args["filter"].(*models.CitiesTopicsFilter)), true

	case "Query.cityDistribution":
		if e.complexity.Query.CityDistribution == nil {
			break
		}

		return e.complexity.Query.CityDistribution(childComplexity), true

	case "Query.cityTopics":
		if e.complexity.Query.CityTopics == nil {
			break
		}

		args, err := ec.field_Query_cityTopics_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CityTopics(childComplexity, args["cityId"].(string)), true

	case "Query.discoverCategoryMotions":
		if e.complexity.Query.DiscoverCategoryMotions == nil {
			break
		}

		args, err := ec.field_Query_discoverCategoryMotions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DiscoverCategoryMotions(childComplexity, args["userId"].(*string), args["filter"].(*models.DiscoverTopicCategoryMotionFilter), args["topicCategoryId"].(string), args["nextToken"].(*string)), true

	case "Query.discoverLatestCategoryMotions":
		if e.complexity.Query.DiscoverLatestCategoryMotions == nil {
			break
		}

		args, err := ec.field_Query_discoverLatestCategoryMotions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DiscoverLatestCategoryMotions(childComplexity, args["filter"].(models.DiscoverTopicCategoryMotionFilter), args["topicCategoryId"].(string), args["lastId"].(*string)), true

	case "Query.getDiscoverMotion":
		if e.complexity.Query.GetDiscoverMotion == nil {
			break
		}

		args, err := ec.field_Query_getDiscoverMotion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetDiscoverMotion(childComplexity, args["motionId"].(string)), true

	case "Query.getMotionOffer":
		if e.complexity.Query.GetMotionOffer == nil {
			break
		}

		args, err := ec.field_Query_getMotionOffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMotionOffer(childComplexity, args["motionId"].(string), args["toMotionId"].(string)), true

	case "Query.hotTopics":
		if e.complexity.Query.HotTopics == nil {
			break
		}

		args, err := ec.field_Query_hotTopics_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HotTopics(childComplexity, args["filter"].(*models.HotTopicsFilter), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.hotTopicsCount":
		if e.complexity.Query.HotTopicsCount == nil {
			break
		}

		args, err := ec.field_Query_hotTopicsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HotTopicsCount(childComplexity, args["filter"].(*models.HotTopicsFilter)), true

	case "Query.hotTopicsInArea":
		if e.complexity.Query.HotTopicsInArea == nil {
			break
		}

		args, err := ec.field_Query_hotTopicsInArea_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HotTopicsInArea(childComplexity, args["cityId"].(*string)), true

	case "Query.inMotionOffers":
		if e.complexity.Query.InMotionOffers == nil {
			break
		}

		args, err := ec.field_Query_inMotionOffers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.InMotionOffers(childComplexity, args["motionId"].(string)), true

	case "Query.invitation":
		if e.complexity.Query.Invitation == nil {
			break
		}

		args, err := ec.field_Query_invitation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Invitation(childComplexity, args["userId"].(*string), args["id"].(string)), true

	case "Query.invitations":
		if e.complexity.Query.Invitations == nil {
			break
		}

		args, err := ec.field_Query_invitations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Invitations(childComplexity, args["userId"].(*string), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.invitationsCount":
		if e.complexity.Query.InvitationsCount == nil {
			break
		}

		args, err := ec.field_Query_invitationsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.InvitationsCount(childComplexity, args["userId"].(*string)), true

	case "Query.likedMotions":
		if e.complexity.Query.LikedMotions == nil {
			break
		}

		args, err := ec.field_Query_likedMotions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.LikedMotions(childComplexity, args["userId"].(*string), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.likedMotionsCount":
		if e.complexity.Query.LikedMotionsCount == nil {
			break
		}

		args, err := ec.field_Query_likedMotionsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.LikedMotionsCount(childComplexity, args["userId"].(*string)), true

	case "Query.matching":
		if e.complexity.Query.Matching == nil {
			break
		}

		args, err := ec.field_Query_matching_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Matching(childComplexity, args["id"].(string)), true

	case "Query.matchingDurationConstraints":
		if e.complexity.Query.MatchingDurationConstraints == nil {
			break
		}

		args, err := ec.field_Query_matchingDurationConstraints_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MatchingDurationConstraints(childComplexity, args["userId"].(string)), true

	case "Query.matchingInvitations":
		if e.complexity.Query.MatchingInvitations == nil {
			break
		}

		args, err := ec.field_Query_matchingInvitations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MatchingInvitations(childComplexity, args["filter"].(*models.MatchingInvitationFilter), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.matchingInvitationsCount":
		if e.complexity.Query.MatchingInvitationsCount == nil {
			break
		}

		args, err := ec.field_Query_matchingInvitationsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MatchingInvitationsCount(childComplexity, args["filter"].(*models.MatchingInvitationFilter)), true

	case "Query.matchingResult":
		if e.complexity.Query.MatchingResult == nil {
			break
		}

		args, err := ec.field_Query_matchingResult_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MatchingResult(childComplexity, args["id"].(int)), true

	case "Query.matchingResultByChatGroupId":
		if e.complexity.Query.MatchingResultByChatGroupID == nil {
			break
		}

		args, err := ec.field_Query_matchingResultByChatGroupId_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MatchingResultByChatGroupID(childComplexity, args["userId"].(*string), args["chatGroupId"].(string)), true

	case "Query.matchingResults":
		if e.complexity.Query.MatchingResults == nil {
			break
		}

		args, err := ec.field_Query_matchingResults_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MatchingResults(childComplexity, args["filter"].(*models.MatchingResultFilter), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.matchingResultsCount":
		if e.complexity.Query.MatchingResultsCount == nil {
			break
		}

		args, err := ec.field_Query_matchingResultsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MatchingResultsCount(childComplexity, args["filter"].(*models.MatchingResultFilter)), true

	case "Query.matchings":
		if e.complexity.Query.Matchings == nil {
			break
		}

		args, err := ec.field_Query_matchings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Matchings(childComplexity, args["filter"].(*models.MatchingFilter), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.matchingsCount":
		if e.complexity.Query.MatchingsCount == nil {
			break
		}

		args, err := ec.field_Query_matchingsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MatchingsCount(childComplexity, args["filter"].(*models.MatchingFilter)), true

	case "Query.motion":
		if e.complexity.Query.Motion == nil {
			break
		}

		args, err := ec.field_Query_motion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Motion(childComplexity, args["id"].(string)), true

	case "Query.motionSummary":
		if e.complexity.Query.MotionSummary == nil {
			break
		}

		return e.complexity.Query.MotionSummary(childComplexity), true

	case "Query.motions":
		if e.complexity.Query.Motions == nil {
			break
		}

		args, err := ec.field_Query_motions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Motions(childComplexity, args["filter"].(*models.MotionFilter), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.motionsCount":
		if e.complexity.Query.MotionsCount == nil {
			break
		}

		args, err := ec.field_Query_motionsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MotionsCount(childComplexity, args["filter"].(*models.MotionFilter)), true

	case "Query.outMotionOffers":
		if e.complexity.Query.OutMotionOffers == nil {
			break
		}

		args, err := ec.field_Query_outMotionOffers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.OutMotionOffers(childComplexity, args["motionId"].(string)), true

	case "Query.previewMatchingsOfTopic":
		if e.complexity.Query.PreviewMatchingsOfTopic == nil {
			break
		}

		args, err := ec.field_Query_previewMatchingsOfTopic_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PreviewMatchingsOfTopic(childComplexity, args["cityId"].(string), args["topicId"].(string), args["limit"].(*int)), true

	case "Query.recentMatching":
		if e.complexity.Query.RecentMatching == nil {
			break
		}

		args, err := ec.field_Query_recentMatching_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RecentMatching(childComplexity, args["id"].(string)), true

	case "Query.recentMatchings":
		if e.complexity.Query.RecentMatchings == nil {
			break
		}

		args, err := ec.field_Query_recentMatchings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RecentMatchings(childComplexity, args["filter"].(*models.RecentMatchingFilter), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.recentMatchingsCount":
		if e.complexity.Query.RecentMatchingsCount == nil {
			break
		}

		args, err := ec.field_Query_recentMatchingsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RecentMatchingsCount(childComplexity, args["filter"].(*models.RecentMatchingFilter)), true

	case "Query.topicDistribution":
		if e.complexity.Query.TopicDistribution == nil {
			break
		}

		return e.complexity.Query.TopicDistribution(childComplexity), true

	case "Query.unconfirmedInvitationCount":
		if e.complexity.Query.UnconfirmedInvitationCount == nil {
			break
		}

		args, err := ec.field_Query_unconfirmedInvitationCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UnconfirmedInvitationCount(childComplexity, args["userId"].(*string)), true

	case "Query.unconfirmedInvitations":
		if e.complexity.Query.UnconfirmedInvitations == nil {
			break
		}

		args, err := ec.field_Query_unconfirmedInvitations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UnconfirmedInvitations(childComplexity, args["userId"].(*string)), true

	case "Query.unconfirmedUserMatchings":
		if e.complexity.Query.UnconfirmedUserMatchings == nil {
			break
		}

		args, err := ec.field_Query_unconfirmedUserMatchings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UnconfirmedUserMatchings(childComplexity, args["userId"].(*string)), true

	case "Query.userDurationConstraint":
		if e.complexity.Query.UserDurationConstraint == nil {
			break
		}

		args, err := ec.field_Query_userDurationConstraint_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserDurationConstraint(childComplexity, args["userId"].(string)), true

	case "Query.userJoinTopic":
		if e.complexity.Query.UserJoinTopic == nil {
			break
		}

		args, err := ec.field_Query_userJoinTopic_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserJoinTopic(childComplexity, args["id"].(int)), true

	case "Query.userJoinTopics":
		if e.complexity.Query.UserJoinTopics == nil {
			break
		}

		args, err := ec.field_Query_userJoinTopics_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserJoinTopics(childComplexity, args["filter"].(*models.UserJoinTopicFilter), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.userJoinTopicsCount":
		if e.complexity.Query.UserJoinTopicsCount == nil {
			break
		}

		args, err := ec.field_Query_userJoinTopicsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserJoinTopicsCount(childComplexity, args["filter"].(*models.UserJoinTopicFilter)), true

	case "Query.userMatchingCalendar":
		if e.complexity.Query.UserMatchingCalendar == nil {
			break
		}

		args, err := ec.field_Query_userMatchingCalendar_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserMatchingCalendar(childComplexity, args["userId"].(*string), args["param"].(models.UserMatchingCalenderParam)), true

	case "Query.userMatchingQuota":
		if e.complexity.Query.UserMatchingQuota == nil {
			break
		}

		args, err := ec.field_Query_userMatchingQuota_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserMatchingQuota(childComplexity, args["userId"].(string)), true

	case "Query.userMatchings":
		if e.complexity.Query.UserMatchings == nil {
			break
		}

		args, err := ec.field_Query_userMatchings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserMatchings(childComplexity, args["userId"].(*string), args["filter"].(*models.UserMatchingFilter), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.userMatchingsCount":
		if e.complexity.Query.UserMatchingsCount == nil {
			break
		}

		args, err := ec.field_Query_userMatchingsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserMatchingsCount(childComplexity, args["userId"].(*string), args["filter"].(*models.UserMatchingFilter)), true

	case "Query.userMatchingsInTheDay":
		if e.complexity.Query.UserMatchingsInTheDay == nil {
			break
		}

		args, err := ec.field_Query_userMatchingsInTheDay_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserMatchingsInTheDay(childComplexity, args["userId"].(*string), args["param"].(models.UserMatchingInTheDayParam)), true

	case "Query.userMotions":
		if e.complexity.Query.UserMotions == nil {
			break
		}

		args, err := ec.field_Query_userMotions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserMotions(childComplexity, args["userId"].(*string), args["paginator"].(*graphqlutil.GraphQLPaginator)), true

	case "Query.userMotionsCount":
		if e.complexity.Query.UserMotionsCount == nil {
			break
		}

		args, err := ec.field_Query_userMotionsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserMotionsCount(childComplexity, args["userId"].(*string)), true

	case "Query.yesterdayMatchingCount":
		if e.complexity.Query.YesterdayMatchingCount == nil {
			break
		}

		return e.complexity.Query.YesterdayMatchingCount(childComplexity), true

	case "Query._service":
		if e.complexity.Query.__resolve__service == nil {
			break
		}

		return e.complexity.Query.__resolve__service(childComplexity), true

	case "Query._entities":
		if e.complexity.Query.__resolve_entities == nil {
			break
		}

		args, err := ec.field_Query__entities_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.__resolve_entities(childComplexity, args["representations"].([]map[string]interface{})), true

	case "RecentMatching.city":
		if e.complexity.RecentMatching.City == nil {
			break
		}

		return e.complexity.RecentMatching.City(childComplexity), true

	case "RecentMatching.cityId":
		if e.complexity.RecentMatching.CityID == nil {
			break
		}

		return e.complexity.RecentMatching.CityID(childComplexity), true

	case "RecentMatching.createdAt":
		if e.complexity.RecentMatching.CreatedAt == nil {
			break
		}

		return e.complexity.RecentMatching.CreatedAt(childComplexity), true

	case "RecentMatching.id":
		if e.complexity.RecentMatching.ID == nil {
			break
		}

		return e.complexity.RecentMatching.ID(childComplexity), true

	case "RecentMatching.matchingIds":
		if e.complexity.RecentMatching.MatchingIDs == nil {
			break
		}

		return e.complexity.RecentMatching.MatchingIDs(childComplexity), true

	case "RecentMatching.matchings":
		if e.complexity.RecentMatching.Matchings == nil {
			break
		}

		return e.complexity.RecentMatching.Matchings(childComplexity), true

	case "RecentMatching.topic":
		if e.complexity.RecentMatching.Topic == nil {
			break
		}

		return e.complexity.RecentMatching.Topic(childComplexity), true

	case "RecentMatching.topicId":
		if e.complexity.RecentMatching.TopicID == nil {
			break
		}

		return e.complexity.RecentMatching.TopicID(childComplexity), true

	case "RecentMatching.updatedAt":
		if e.complexity.RecentMatching.UpdatedAt == nil {
			break
		}

		return e.complexity.RecentMatching.UpdatedAt(childComplexity), true

	case "SimpleAvatarUser.avatar":
		if e.complexity.SimpleAvatarUser.Avatar == nil {
			break
		}

		return e.complexity.SimpleAvatarUser.Avatar(childComplexity), true

	case "SimpleAvatarUser.nickname":
		if e.complexity.SimpleAvatarUser.Nickname == nil {
			break
		}

		return e.complexity.SimpleAvatarUser.Nickname(childComplexity), true

	case "Summary.count":
		if e.complexity.Summary.Count == nil {
			break
		}

		return e.complexity.Summary.Count(childComplexity), true

	case "Topic.fuzzyMatchingNum":
		if e.complexity.Topic.FuzzyMatchingNum == nil {
			break
		}

		args, err := ec.field_Topic_fuzzyMatchingNum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Topic.FuzzyMatchingNum(childComplexity, args["cityId"].(*string)), true

	case "Topic.id":
		if e.complexity.Topic.ID == nil {
			break
		}

		return e.complexity.Topic.ID(childComplexity), true

	case "Topic.matchingNum":
		if e.complexity.Topic.MatchingNum == nil {
			break
		}

		args, err := ec.field_Topic_matchingNum_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Topic.MatchingNum(childComplexity, args["cityId"].(*string)), true

	case "Topic.recentUsers":
		if e.complexity.Topic.RecentUsers == nil {
			break
		}

		args, err := ec.field_Topic_recentUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Topic.RecentUsers(childComplexity, args["cityId"].(*string)), true

	case "TopicMetrics.heat":
		if e.complexity.TopicMetrics.Heat == nil {
			break
		}

		return e.complexity.TopicMetrics.Heat(childComplexity), true

	case "TopicMetrics.id":
		if e.complexity.TopicMetrics.ID == nil {
			break
		}

		return e.complexity.TopicMetrics.ID(childComplexity), true

	case "TopicMetrics.matched":
		if e.complexity.TopicMetrics.Matched == nil {
			break
		}

		return e.complexity.TopicMetrics.Matched(childComplexity), true

	case "TopicMetrics.matching":
		if e.complexity.TopicMetrics.Matching == nil {
			break
		}

		return e.complexity.TopicMetrics.Matching(childComplexity), true

	case "TopicMetrics.topic":
		if e.complexity.TopicMetrics.Topic == nil {
			break
		}

		return e.complexity.TopicMetrics.Topic(childComplexity), true

	case "TopicOptionConfig.topicId":
		if e.complexity.TopicOptionConfig.TopicID == nil {
			break
		}

		return e.complexity.TopicOptionConfig.TopicID(childComplexity), true

	case "TopicToMatching.matchingIds":
		if e.complexity.TopicToMatching.MatchingIds == nil {
			break
		}

		return e.complexity.TopicToMatching.MatchingIds(childComplexity), true

	case "TopicToMatching.topic":
		if e.complexity.TopicToMatching.Topic == nil {
			break
		}

		return e.complexity.TopicToMatching.Topic(childComplexity), true

	case "TopicToMatching.topicId":
		if e.complexity.TopicToMatching.TopicID == nil {
			break
		}

		return e.complexity.TopicToMatching.TopicID(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.matchingQuota":
		if e.complexity.User.MatchingQuota == nil {
			break
		}

		return e.complexity.User.MatchingQuota(childComplexity), true

	case "UserConfirmState.state":
		if e.complexity.UserConfirmState.State == nil {
			break
		}

		return e.complexity.UserConfirmState.State(childComplexity), true

	case "UserConfirmState.userId":
		if e.complexity.UserConfirmState.UserID == nil {
			break
		}

		return e.complexity.UserConfirmState.UserID(childComplexity), true

	case "UserJoinTopic.city":
		if e.complexity.UserJoinTopic.City == nil {
			break
		}

		return e.complexity.UserJoinTopic.City(childComplexity), true

	case "UserJoinTopic.cityId":
		if e.complexity.UserJoinTopic.CityID == nil {
			break
		}

		return e.complexity.UserJoinTopic.CityID(childComplexity), true

	case "UserJoinTopic.createdAt":
		if e.complexity.UserJoinTopic.CreatedAt == nil {
			break
		}

		return e.complexity.UserJoinTopic.CreatedAt(childComplexity), true

	case "UserJoinTopic.id":
		if e.complexity.UserJoinTopic.ID == nil {
			break
		}

		return e.complexity.UserJoinTopic.ID(childComplexity), true

	case "UserJoinTopic.latestMatchingId":
		if e.complexity.UserJoinTopic.LatestMatchingID == nil {
			break
		}

		return e.complexity.UserJoinTopic.LatestMatchingID(childComplexity), true

	case "UserJoinTopic.matching":
		if e.complexity.UserJoinTopic.Matching == nil {
			break
		}

		return e.complexity.UserJoinTopic.Matching(childComplexity), true

	case "UserJoinTopic.topic":
		if e.complexity.UserJoinTopic.Topic == nil {
			break
		}

		return e.complexity.UserJoinTopic.Topic(childComplexity), true

	case "UserJoinTopic.topicId":
		if e.complexity.UserJoinTopic.TopicID == nil {
			break
		}

		return e.complexity.UserJoinTopic.TopicID(childComplexity), true

	case "UserJoinTopic.updatedAt":
		if e.complexity.UserJoinTopic.UpdatedAt == nil {
			break
		}

		return e.complexity.UserJoinTopic.UpdatedAt(childComplexity), true

	case "UserJoinTopic.user":
		if e.complexity.UserJoinTopic.User == nil {
			break
		}

		return e.complexity.UserJoinTopic.User(childComplexity), true

	case "UserJoinTopic.userId":
		if e.complexity.UserJoinTopic.UserID == nil {
			break
		}

		return e.complexity.UserJoinTopic.UserID(childComplexity), true

	case "UserLikeMotion.createdAt":
		if e.complexity.UserLikeMotion.CreatedAt == nil {
			break
		}

		return e.complexity.UserLikeMotion.CreatedAt(childComplexity), true

	case "UserLikeMotion.motion":
		if e.complexity.UserLikeMotion.Motion == nil {
			break
		}

		return e.complexity.UserLikeMotion.Motion(childComplexity), true

	case "UserLikeMotion.toMotionId":
		if e.complexity.UserLikeMotion.ToMotionID == nil {
			break
		}

		return e.complexity.UserLikeMotion.ToMotionID(childComplexity), true

	case "UserLikeMotion.toUserId":
		if e.complexity.UserLikeMotion.ToUserID == nil {
			break
		}

		return e.complexity.UserLikeMotion.ToUserID(childComplexity), true

	case "UserLikeMotion.userId":
		if e.complexity.UserLikeMotion.UserID == nil {
			break
		}

		return e.complexity.UserLikeMotion.UserID(childComplexity), true

	case "UserThumbsUpMotion.createdAt":
		if e.complexity.UserThumbsUpMotion.CreatedAt == nil {
			break
		}

		return e.complexity.UserThumbsUpMotion.CreatedAt(childComplexity), true

	case "UserThumbsUpMotion.toMotionId":
		if e.complexity.UserThumbsUpMotion.ToMotionID == nil {
			break
		}

		return e.complexity.UserThumbsUpMotion.ToMotionID(childComplexity), true

	case "UserThumbsUpMotion.userId":
		if e.complexity.UserThumbsUpMotion.UserID == nil {
			break
		}

		return e.complexity.UserThumbsUpMotion.UserID(childComplexity), true

	case "_Service.sdl":
		if e.complexity._Service.SDL == nil {
			break
		}

		return e.complexity._Service.SDL(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCitiesTopicsFilter,
		ec.unmarshalInputCreateCityTopicParam,
		ec.unmarshalInputCreateMatchingInvitationParam,
		ec.unmarshalInputCreateMatchingParam,
		ec.unmarshalInputCreateMatchingParamV2,
		ec.unmarshalInputCreateMotionParam,
		ec.unmarshalInputCreateUserJoinTopicParam,
		ec.unmarshalInputDiscoverTopicCategoryMotionFilter,
		ec.unmarshalInputGraphQLPaginator,
		ec.unmarshalInputHotTopicsFilter,
		ec.unmarshalInputMatchingFilter,
		ec.unmarshalInputMatchingInvitationFilter,
		ec.unmarshalInputMatchingPropertyParam,
		ec.unmarshalInputMatchingResultFilter,
		ec.unmarshalInputMotionFilter,
		ec.unmarshalInputMotionPropertyParam,
		ec.unmarshalInputNotifyNewMotionOfferMessageParam,
		ec.unmarshalInputRecentMatchingFilter,
		ec.unmarshalInputReviewMatchingParam,
		ec.unmarshalInputReviewMotionParam,
		ec.unmarshalInputUpdateCityTopicParam,
		ec.unmarshalInputUpdateDurationConstraintParam,
		ec.unmarshalInputUpdateHotTopicMetricsParam,
		ec.unmarshalInputUpdateHotTopicParam,
		ec.unmarshalInputUpdateMatchingDurationConstraintParam,
		ec.unmarshalInputUpdateMatchingInvitationParam,
		ec.unmarshalInputUpdateMatchingParam,
		ec.unmarshalInputUpdateMatchingQuotaParam,
		ec.unmarshalInputUpdateMotionParam,
		ec.unmarshalInputUpdateRecentMatchingParam,
		ec.unmarshalInputUpdateUserJoinTopicParam,
		ec.unmarshalInputUserJoinTopicFilter,
		ec.unmarshalInputUserMatchingCalenderParam,
		ec.unmarshalInputUserMatchingFilter,
		ec.unmarshalInputUserMatchingInTheDayParam,
		ec.unmarshalInputUserUpdateMotionParam,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

//go:embed "schema.graphqls" "matching-discover.graphql" "matching-invitation.graphql" "matching.graphql" "motion-discover.graphql" "motion.graphql" "topic.graphql" "user-like-motion.graphql"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "schema.graphqls", Input: sourceData("schema.graphqls"), BuiltIn: false},
	{Name: "matching-discover.graphql", Input: sourceData("matching-discover.graphql"), BuiltIn: false},
	{Name: "matching-invitation.graphql", Input: sourceData("matching-invitation.graphql"), BuiltIn: false},
	{Name: "matching.graphql", Input: sourceData("matching.graphql"), BuiltIn: false},
	{Name: "motion-discover.graphql", Input: sourceData("motion-discover.graphql"), BuiltIn: false},
	{Name: "motion.graphql", Input: sourceData("motion.graphql"), BuiltIn: false},
	{Name: "topic.graphql", Input: sourceData("topic.graphql"), BuiltIn: false},
	{Name: "user-like-motion.graphql", Input: sourceData("user-like-motion.graphql"), BuiltIn: false},
	{Name: "../federation/directives.graphql", Input: `
	directive @composeDirective(name: String!) repeatable on SCHEMA
	directive @extends on OBJECT | INTERFACE
	directive @external on OBJECT | FIELD_DEFINITION
	directive @key(fields: FieldSet!, resolvable: Boolean = true) repeatable on OBJECT | INTERFACE
	directive @inaccessible on
	  | ARGUMENT_DEFINITION
	  | ENUM
	  | ENUM_VALUE
	  | FIELD_DEFINITION
	  | INPUT_FIELD_DEFINITION
	  | INPUT_OBJECT
	  | INTERFACE
	  | OBJECT
	  | SCALAR
	  | UNION
	directive @interfaceObject on OBJECT
	directive @link(import: [String!], url: String!) repeatable on SCHEMA
	directive @override(from: String!) on FIELD_DEFINITION
	directive @provides(fields: FieldSet!) on FIELD_DEFINITION
	directive @requires(fields: FieldSet!) on FIELD_DEFINITION
	directive @shareable repeatable on FIELD_DEFINITION | OBJECT
	directive @tag(name: String!) repeatable on
	  | ARGUMENT_DEFINITION
	  | ENUM
	  | ENUM_VALUE
	  | FIELD_DEFINITION
	  | INPUT_FIELD_DEFINITION
	  | INPUT_OBJECT
	  | INTERFACE
	  | OBJECT
	  | SCALAR
	  | UNION
	scalar _Any
	scalar FieldSet
`, BuiltIn: true},
	{Name: "../federation/entity.graphql", Input: `
# a union of all types that use the @key directive
union _Entity = Area | ChatGroup | LevelRights | Matching | MatchingQuota | Topic | TopicOptionConfig | User

# fake type to build resolver interfaces for users to implement
type Entity {
		findLevelRightsByLevel(level: Int!,): LevelRights!
	findMatchingByID(id: String!,): Matching!
	findMatchingQuotaByUserID(userID: String!,): MatchingQuota!
	findTopicByID(id: String!,): Topic!
	findUserByID(id: String!,): User!

}

type _Service {
  sdl: String
}

extend type Query {
  _entities(representations: [_Any!]!): [_Entity]!
  _service: _Service!
}
`, BuiltIn: true},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_composeDirective_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_DiscoverMotion_liked_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_DiscoverMotion_submitted_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_DiscoverMotion_thumbsUp_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Entity_findLevelRightsByLevel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["level"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["level"] = arg0
	return args, nil
}

func (ec *executionContext) field_Entity_findMatchingByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Entity_findMatchingQuotaByUserID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Entity_findTopicByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Entity_findUserByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_MotionOfferRecord_reviewed_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_acceptMotionOffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["myMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("myMotionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["myMotionId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["targetMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetMotionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["targetMotionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addMatchingToRecent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["matchingId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchingId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["matchingId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cancelMatchingInvitation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["invitationId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("invitationId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["invitationId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cancelMatching_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["matchingId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchingId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["matchingId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cancelMotionOffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["myMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("myMotionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["myMotionId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["targetMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetMotionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["targetMotionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_cancelThumbsUpMotion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["motionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("motionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["motionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_closeMotion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_confirmMatchingInvitation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["invitationId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("invitationId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["invitationId"] = arg1
	var arg2 bool
	if tmp, ok := rawArgs["confirm"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("confirm"))
		arg2, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["confirm"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_confirmMatchingResultV2_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["matchingId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchingId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["matchingId"] = arg1
	var arg2 bool
	if tmp, ok := rawArgs["confirm"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("confirm"))
		arg2, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["confirm"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_confirmMatchingResult_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["matchingId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchingId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["matchingId"] = arg1
	var arg2 bool
	if tmp, ok := rawArgs["reject"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("reject"))
		arg2, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reject"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_createCityTopics_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreateCityTopicParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg0, err = ec.unmarshalNCreateCityTopicParam2whalepkgmodelsCreateCityTopicParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createMatchingInvitation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 models.CreateMatchingInvitationParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNCreateMatchingInvitationParam2whalepkgmodelsCreateMatchingInvitationParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createMatchingV2_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 models.CreateMatchingParamV2
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNCreateMatchingParamV22whalepkgmodelsCreateMatchingParamV2(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createMatching_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 models.CreateMatchingParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNCreateMatchingParam2whalepkgmodelsCreateMatchingParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createMotionOffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["myMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("myMotionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["myMotionId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["targetMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetMotionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["targetMotionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createMotion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 models.CreateMotionParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNCreateMotionParam2whalepkgmodelsCreateMotionParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createUserJoinTopic_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreateUserJoinTopicParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg0, err = ec.unmarshalNCreateUserJoinTopicParam2whalepkgmodelsCreateUserJoinTopicParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_finishMatching_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["matchingId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchingId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["matchingId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_finishMotionOffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["fromMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fromMotionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["fromMotionId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["toMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toMotionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["toMotionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_getAvailableMotionOffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["targetMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetMotionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["targetMotionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_getMatchingScore_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id1"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id1"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id1"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["id2"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id2"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id2"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_likeMotion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["motionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("motionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["motionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_notifyNewMotionOffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.NotifyNewMotionOfferMessageParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg0, err = ec.unmarshalONotifyNewMotionOfferMessageParam2whalepkgmodelsNotifyNewMotionOfferMessageParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_rejectMotionOffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["myMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("myMotionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["myMotionId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["targetMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetMotionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["targetMotionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_reviewMatching_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["matchingId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchingId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["matchingId"] = arg0
	var arg1 models.ReviewMatchingParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNReviewMatchingParam2whalepkgmodelsReviewMatchingParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_reviewMotionOffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["fromMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fromMotionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["fromMotionId"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["toMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toMotionId"))
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["toMotionId"] = arg2
	var arg3 models.ReviewMotionParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg3, err = ec.unmarshalNReviewMotionParam2whalepkgmodelsReviewMotionParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg3
	return args, nil
}

func (ec *executionContext) field_Mutation_sendChatInOffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["myMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("myMotionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["myMotionId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["targetMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetMotionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["targetMotionId"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["sentence"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sentence"))
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sentence"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_sendMotionOfferAcceptMessage_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_thumbsUpMotion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["motionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("motionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["motionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_thumbsUpMotionsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_thumbsUpMotions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2githubcomletjoyclubmidatoolgraphqlutilGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_unlikeMotion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["motionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("motionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["motionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateCityTopics_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["cityId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["cityId"] = arg0
	var arg1 models.UpdateCityTopicParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUpdateCityTopicParam2whalepkgmodelsUpdateCityTopicParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateDurationConstraint_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 models.UpdateDurationConstraintParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUpdateDurationConstraintParam2whalepkgmodelsUpdateDurationConstraintParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateHotTopicsInArea_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["cityId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["cityId"] = arg0
	var arg1 models.UpdateHotTopicParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUpdateHotTopicParam2whalepkgmodelsUpdateHotTopicParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateMatchingDurationConstraint_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 models.UpdateMatchingDurationConstraintParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUpdateMatchingDurationConstraintParam2whalepkgmodelsUpdateMatchingDurationConstraintParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateMatchingInvitation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["invitationId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("invitationId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["invitationId"] = arg0
	var arg1 models.UpdateMatchingInvitationParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUpdateMatchingInvitationParam2whalepkgmodelsUpdateMatchingInvitationParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateMatchingQuota_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 models.UpdateMatchingQuotaParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUpdateMatchingQuotaParam2whalepkgmodelsUpdateMatchingQuotaParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateMatching_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["matchingId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchingId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["matchingId"] = arg0
	var arg1 models.UpdateMatchingParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUpdateMatchingParam2whalepkgmodelsUpdateMatchingParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateMotion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 models.UpdateMotionParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUpdateMotionParam2whalepkgmodelsUpdateMotionParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateRecentMatching_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 models.UpdateRecentMatchingParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUpdateRecentMatchingParam2whalepkgmodelsUpdateRecentMatchingParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateUserJoinTopic_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 models.UpdateUserJoinTopicParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUpdateUserJoinTopicParam2whalepkgmodelsUpdateUserJoinTopicParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_userUpdateMotion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["myMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("myMotionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["myMotionId"] = arg0
	var arg1 models.UserUpdateMotionParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUserUpdateMotionParam2whalepkgmodelsUserUpdateMotionParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query__entities_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []map[string]interface{}
	if tmp, ok := rawArgs["representations"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("representations"))
		arg0, err = ec.unmarshalN_Any2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["representations"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_activeMotions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_chatGroupByResultId_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["resultId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resultId"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resultId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_citiesTopicsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.CitiesTopicsFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOCitiesTopicsFilter2whalepkgmodelsCitiesTopicsFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_citiesTopics_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.CitiesTopicsFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOCitiesTopicsFilter2whalepkgmodelsCitiesTopicsFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2githubcomletjoyclubmidatoolgraphqlutilGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_cityTopics_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["cityId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["cityId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_discoverCategoryMotions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 *models.DiscoverTopicCategoryMotionFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg1, err = ec.unmarshalODiscoverTopicCategoryMotionFilter2whalepkgmodelsDiscoverTopicCategoryMotionFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["topicCategoryId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicCategoryId"))
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["topicCategoryId"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["nextToken"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nextToken"))
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["nextToken"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_discoverLatestCategoryMotions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.DiscoverTopicCategoryMotionFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalNDiscoverTopicCategoryMotionFilter2whalepkgmodelsDiscoverTopicCategoryMotionFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["topicCategoryId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicCategoryId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["topicCategoryId"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["lastId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastId"))
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["lastId"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_getDiscoverMotion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["motionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("motionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["motionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getMotionOffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["motionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("motionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["motionId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["toMotionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toMotionId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["toMotionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_hotTopicsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.HotTopicsFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOHotTopicsFilter2whalepkgmodelsHotTopicsFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_hotTopicsInArea_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["cityId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["cityId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_hotTopics_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.HotTopicsFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOHotTopicsFilter2whalepkgmodelsHotTopicsFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2githubcomletjoyclubmidatoolgraphqlutilGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_inMotionOffers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["motionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("motionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["motionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_invitation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_invitationsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_invitations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2githubcomletjoyclubmidatoolgraphqlutilGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_likedMotionsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_likedMotions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2githubcomletjoyclubmidatoolgraphqlutilGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_matchingDurationConstraints_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_matchingInvitationsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.MatchingInvitationFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOMatchingInvitationFilter2whalepkgmodelsMatchingInvitationFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_matchingInvitations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.MatchingInvitationFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOMatchingInvitationFilter2whalepkgmodelsMatchingInvitationFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2githubcomletjoyclubmidatoolgraphqlutilGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_matchingResultByChatGroupId_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["chatGroupId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chatGroupId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["chatGroupId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_matchingResult_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_matchingResultsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.MatchingResultFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOMatchingResultFilter2whalepkgmodelsMatchingResultFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_matchingResults_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.MatchingResultFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOMatchingResultFilter2whalepkgmodelsMatchingResultFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2githubcomletjoyclubmidatoolgraphqlutilGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_matching_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_matchingsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.MatchingFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOMatchingFilter2whalepkgmodelsMatchingFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_matchings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.MatchingFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOMatchingFilter2whalepkgmodelsMatchingFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2githubcomletjoyclubmidatoolgraphqlutilGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_motion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_motionsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.MotionFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOMotionFilter2whalepkgmodelsMotionFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_motions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.MotionFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOMotionFilter2whalepkgmodelsMotionFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2githubcomletjoyclubmidatoolgraphqlutilGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_outMotionOffers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["motionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("motionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["motionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_previewMatchingsOfTopic_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["cityId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["cityId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["topicId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicId"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["topicId"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_recentMatching_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_recentMatchingsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.RecentMatchingFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalORecentMatchingFilter2whalepkgmodelsRecentMatchingFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_recentMatchings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.RecentMatchingFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalORecentMatchingFilter2whalepkgmodelsRecentMatchingFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2githubcomletjoyclubmidatoolgraphqlutilGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_unconfirmedInvitationCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_unconfirmedInvitations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_unconfirmedUserMatchings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userDurationConstraint_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userJoinTopic_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userJoinTopicsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.UserJoinTopicFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOUserJoinTopicFilter2whalepkgmodelsUserJoinTopicFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userJoinTopics_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.UserJoinTopicFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOUserJoinTopicFilter2whalepkgmodelsUserJoinTopicFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2githubcomletjoyclubmidatoolgraphqlutilGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_userMatchingCalendar_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 models.UserMatchingCalenderParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUserMatchingCalenderParam2whalepkgmodelsUserMatchingCalenderParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_userMatchingQuota_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userMatchingsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 *models.UserMatchingFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg1, err = ec.unmarshalOUserMatchingFilter2whalepkgmodelsUserMatchingFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_userMatchingsInTheDay_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 models.UserMatchingInTheDayParam
	if tmp, ok := rawArgs["param"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("param"))
		arg1, err = ec.unmarshalNUserMatchingInTheDayParam2whalepkgmodelsUserMatchingInTheDayParam(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["param"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_userMatchings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 *models.UserMatchingFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg1, err = ec.unmarshalOUserMatchingFilter2whalepkgmodelsUserMatchingFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg1
	var arg2 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg2, err = ec.unmarshalOGraphQLPaginator2githubcomletjoyclubmidatoolgraphqlutilGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_userMotionsCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userMotions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 *graphqlutil.GraphQLPaginator
	if tmp, ok := rawArgs["paginator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paginator"))
		arg1, err = ec.unmarshalOGraphQLPaginator2githubcomletjoyclubmidatoolgraphqlutilGraphQLPaginator(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paginator"] = arg1
	return args, nil
}

func (ec *executionContext) field_Topic_fuzzyMatchingNum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["cityId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["cityId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Topic_matchingNum_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["cityId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["cityId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Topic_recentUsers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["cityId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["cityId"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Area_code(ctx context.Context, field graphql.CollectedField, obj *models.Area) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Area_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNAreaCode2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Area_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Area",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AreaCode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AvailableMotionOffer_motion(ctx context.Context, field graphql.CollectedField, obj *models.AvailableMotionOffer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AvailableMotionOffer_motion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Motion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Motion)
	fc.Result = res
	return ec.marshalOMotion2whalepkgmodelsMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AvailableMotionOffer_motion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AvailableMotionOffer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Motion_id(ctx, field)
			case "userId":
				return ec.fieldContext_Motion_userId(ctx, field)
			case "cityId":
				return ec.fieldContext_Motion_cityId(ctx, field)
			case "remark":
				return ec.fieldContext_Motion_remark(ctx, field)
			case "active":
				return ec.fieldContext_Motion_active(ctx, field)
			case "inOfferNum":
				return ec.fieldContext_Motion_inOfferNum(ctx, field)
			case "outOfferNum":
				return ec.fieldContext_Motion_outOfferNum(ctx, field)
			case "pendingInNum":
				return ec.fieldContext_Motion_pendingInNum(ctx, field)
			case "pendingOutNum":
				return ec.fieldContext_Motion_pendingOutNum(ctx, field)
			case "activeNum":
				return ec.fieldContext_Motion_activeNum(ctx, field)
			case "discoverable":
				return ec.fieldContext_Motion_discoverable(ctx, field)
			case "relatedMatchingId":
				return ec.fieldContext_Motion_relatedMatchingId(ctx, field)
			case "properties":
				return ec.fieldContext_Motion_properties(ctx, field)
			case "dayRange":
				return ec.fieldContext_Motion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Motion_preferredPeriods(ctx, field)
			case "gender":
				return ec.fieldContext_Motion_gender(ctx, field)
			case "createdAt":
				return ec.fieldContext_Motion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_Motion_liked(ctx, field)
			case "viewCount":
				return ec.fieldContext_Motion_viewCount(ctx, field)
			case "likeCount":
				return ec.fieldContext_Motion_likeCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_Motion_thumbsUpCount(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_Motion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_Motion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_Motion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_Motion_user(ctx, field)
			case "city":
				return ec.fieldContext_Motion_city(ctx, field)
			case "areas":
				return ec.fieldContext_Motion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Motion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AvailableMotionOffer_nextQuotaTime(ctx context.Context, field graphql.CollectedField, obj *models.AvailableMotionOffer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AvailableMotionOffer_nextQuotaTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextQuotaTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AvailableMotionOffer_nextQuotaTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AvailableMotionOffer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CalendarEvent_topicId(ctx context.Context, field graphql.CollectedField, obj *models.CalendarEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CalendarEvent_topicId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CalendarEvent_topicId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CalendarEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CalendarEvent_matchedAt(ctx context.Context, field graphql.CollectedField, obj *models.CalendarEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CalendarEvent_matchedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CalendarEvent_matchedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CalendarEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CalendarEvent_finishedAt(ctx context.Context, field graphql.CollectedField, obj *models.CalendarEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CalendarEvent_finishedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FinishedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CalendarEvent_finishedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CalendarEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CalendarEvent_chatGroupCreatedAt(ctx context.Context, field graphql.CollectedField, obj *models.CalendarEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CalendarEvent_chatGroupCreatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChatGroupCreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CalendarEvent_chatGroupCreatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CalendarEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatGroup_id(ctx context.Context, field graphql.CollectedField, obj *models.ChatGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatGroup_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatGroup_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CityToTopicMatching_cityId(ctx context.Context, field graphql.CollectedField, obj *models.CityToTopicMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CityToTopicMatching_cityId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CityToTopicMatching_cityId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CityToTopicMatching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CityToTopicMatching_topics(ctx context.Context, field graphql.CollectedField, obj *models.CityToTopicMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CityToTopicMatching_topics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Topics, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.TopicToMatching)
	fc.Result = res
	return ec.marshalNTopicToMatching2whalepkgmodelsTopicToMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CityToTopicMatching_topics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CityToTopicMatching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "topicId":
				return ec.fieldContext_TopicToMatching_topicId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_TopicToMatching_matchingIds(ctx, field)
			case "topic":
				return ec.fieldContext_TopicToMatching_topic(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TopicToMatching", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CityToTopicMatching_city(ctx context.Context, field graphql.CollectedField, obj *models.CityToTopicMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CityToTopicMatching_city(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CityToTopicMatching().City(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Area)
	fc.Result = res
	return ec.marshalNArea2whalepkgmodelsArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CityToTopicMatching_city(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CityToTopicMatching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CityTopics_cityId(ctx context.Context, field graphql.CollectedField, obj *models.CityTopics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CityTopics_cityId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CityTopics_cityId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CityTopics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CityTopics_topicIds(ctx context.Context, field graphql.CollectedField, obj *models.CityTopics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CityTopics_topicIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CityTopics_topicIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CityTopics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CityTopics_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.CityTopics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CityTopics_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CityTopics_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CityTopics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CityTopics_topics(ctx context.Context, field graphql.CollectedField, obj *models.CityTopics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CityTopics_topics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CityTopics().Topics(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Topic)
	fc.Result = res
	return ec.marshalNTopic2whalepkgmodelsTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CityTopics_topics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CityTopics",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Topic_id(ctx, field)
			case "recentUsers":
				return ec.fieldContext_Topic_recentUsers(ctx, field)
			case "matchingNum":
				return ec.fieldContext_Topic_matchingNum(ctx, field)
			case "fuzzyMatchingNum":
				return ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Topic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CityTopics_city(ctx context.Context, field graphql.CollectedField, obj *models.CityTopics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CityTopics_city(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CityTopics().City(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Area)
	fc.Result = res
	return ec.marshalNArea2whalepkgmodelsArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CityTopics_city(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CityTopics",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateMotionOfferResult_chatGroupId(ctx context.Context, field graphql.CollectedField, obj *models.CreateMotionOfferResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateMotionOfferResult_chatGroupId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChatGroupID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateMotionOfferResult_chatGroupId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateMotionOfferResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_id(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_userId(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_topicId(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_topicId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_topicId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_properties(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_properties(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Properties, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.MotionProperty)
	fc.Result = res
	return ec.marshalNMotionProperty2whalepkgmodelsMotionProperty(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_properties(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MotionProperty_id(ctx, field)
			case "values":
				return ec.fieldContext_MotionProperty_values(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MotionProperty", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_cityId(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_cityId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_cityId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_areaIds(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_areaIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AreaIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_areaIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_gender(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_gender(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DiscoverMotion().Gender(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Gender)
	fc.Result = res
	return ec.marshalNGender2whalepkgmodelsGender(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_gender(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Gender does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_dayRange(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_dayRange(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DayRange, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_dayRange(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_preferredPeriods(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_preferredPeriods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DiscoverMotion().PreferredPeriods(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.DatePeriod)
	fc.Result = res
	return ec.marshalNDatePeriod2whalepkgmodelsDatePeriod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_preferredPeriods(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DatePeriod does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_remark(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_remark(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Remark, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_remark(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_likeCount(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_likeCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LikeCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_likeCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_viewCount(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_viewCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ViewCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_viewCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_thumbsUpCount(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_thumbsUpCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ThumbsUpCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_thumbsUpCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_liked(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_liked(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DiscoverMotion().Liked(rctx, obj, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_liked(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DiscoverMotion_liked_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_submitted(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_submitted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DiscoverMotion().Submitted(rctx, obj, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_submitted(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DiscoverMotion_submitted_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_thumbsUp(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_thumbsUp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DiscoverMotion().ThumbsUp(rctx, obj, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_thumbsUp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DiscoverMotion_thumbsUp_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_topic(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_topic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DiscoverMotion().Topic(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Topic)
	fc.Result = res
	return ec.marshalNTopic2whalepkgmodelsTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_topic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Topic_id(ctx, field)
			case "recentUsers":
				return ec.fieldContext_Topic_recentUsers(ctx, field)
			case "matchingNum":
				return ec.fieldContext_Topic_matchingNum(ctx, field)
			case "fuzzyMatchingNum":
				return ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Topic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_topicOptionConfig(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_topicOptionConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DiscoverMotion().TopicOptionConfig(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.TopicOptionConfig)
	fc.Result = res
	return ec.marshalOTopicOptionConfig2whalepkgmodelsTopicOptionConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_topicOptionConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "topicId":
				return ec.fieldContext_TopicOptionConfig_topicId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TopicOptionConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_user(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DiscoverMotion().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2whalepkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "matchingQuota":
				return ec.fieldContext_User_matchingQuota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_city(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_city(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DiscoverMotion().City(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Area)
	fc.Result = res
	return ec.marshalNArea2whalepkgmodelsArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_city(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotion_areas(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotion_areas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DiscoverMotion().Areas(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Area)
	fc.Result = res
	return ec.marshalNArea2whalepkgmodelsArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotion_areas(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotionResult_motions(ctx context.Context, field graphql.CollectedField, obj *models.DiscoverMotionResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotionResult_motions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Motions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Motion)
	fc.Result = res
	return ec.marshalNDiscoverMotion2whalepkgmodelsMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotionResult_motions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotionResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscoverMotion_id(ctx, field)
			case "userId":
				return ec.fieldContext_DiscoverMotion_userId(ctx, field)
			case "topicId":
				return ec.fieldContext_DiscoverMotion_topicId(ctx, field)
			case "properties":
				return ec.fieldContext_DiscoverMotion_properties(ctx, field)
			case "cityId":
				return ec.fieldContext_DiscoverMotion_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_DiscoverMotion_areaIds(ctx, field)
			case "gender":
				return ec.fieldContext_DiscoverMotion_gender(ctx, field)
			case "dayRange":
				return ec.fieldContext_DiscoverMotion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_DiscoverMotion_preferredPeriods(ctx, field)
			case "remark":
				return ec.fieldContext_DiscoverMotion_remark(ctx, field)
			case "likeCount":
				return ec.fieldContext_DiscoverMotion_likeCount(ctx, field)
			case "viewCount":
				return ec.fieldContext_DiscoverMotion_viewCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_DiscoverMotion_thumbsUpCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_DiscoverMotion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_DiscoverMotion_liked(ctx, field)
			case "submitted":
				return ec.fieldContext_DiscoverMotion_submitted(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_DiscoverMotion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_DiscoverMotion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_DiscoverMotion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_DiscoverMotion_user(ctx, field)
			case "city":
				return ec.fieldContext_DiscoverMotion_city(ctx, field)
			case "areas":
				return ec.fieldContext_DiscoverMotion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscoverMotion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscoverMotionResult_nextToken(ctx context.Context, field graphql.CollectedField, obj *models.DiscoverMotionResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscoverMotionResult_nextToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscoverMotionResult_nextToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscoverMotionResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DurationConstraint_userId(ctx context.Context, field graphql.CollectedField, obj *models.DurationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DurationConstraint_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DurationConstraint_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DurationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DurationConstraint_startDate(ctx context.Context, field graphql.CollectedField, obj *models.DurationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DurationConstraint_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DurationConstraint_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DurationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DurationConstraint_stopDate(ctx context.Context, field graphql.CollectedField, obj *models.DurationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DurationConstraint_stopDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DurationConstraint_stopDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DurationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DurationConstraint_totalMotionQuota(ctx context.Context, field graphql.CollectedField, obj *models.DurationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DurationConstraint_totalMotionQuota(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalMotionQuota, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DurationConstraint_totalMotionQuota(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DurationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DurationConstraint_remainMotionQuota(ctx context.Context, field graphql.CollectedField, obj *models.DurationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DurationConstraint_remainMotionQuota(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RemainMotionQuota, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DurationConstraint_remainMotionQuota(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DurationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DurationConstraint_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.DurationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DurationConstraint_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DurationConstraint_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DurationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entity_findLevelRightsByLevel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_findLevelRightsByLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Entity().FindLevelRightsByLevel(rctx, fc.Args["level"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.LevelRights)
	fc.Result = res
	return ec.marshalNLevelRights2whalepkgmodelsLevelRights(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_findLevelRightsByLevel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "level":
				return ec.fieldContext_LevelRights_level(ctx, field)
			case "matchingQuota":
				return ec.fieldContext_LevelRights_matchingQuota(ctx, field)
			case "matchingDurationConstraint":
				return ec.fieldContext_LevelRights_matchingDurationConstraint(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LevelRights", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Entity_findLevelRightsByLevel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Entity_findMatchingByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_findMatchingByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Entity().FindMatchingByID(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Matching)
	fc.Result = res
	return ec.marshalNMatching2whalepkgmodelsMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_findMatchingByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Matching_id(ctx, field)
			case "topicId":
				return ec.fieldContext_Matching_topicId(ctx, field)
			case "userId":
				return ec.fieldContext_Matching_userId(ctx, field)
			case "areaIds":
				return ec.fieldContext_Matching_areaIds(ctx, field)
			case "cityId":
				return ec.fieldContext_Matching_cityId(ctx, field)
			case "gender":
				return ec.fieldContext_Matching_gender(ctx, field)
			case "state":
				return ec.fieldContext_Matching_state(ctx, field)
			case "rejectedUserIds":
				return ec.fieldContext_Matching_rejectedUserIds(ctx, field)
			case "inChatGroup":
				return ec.fieldContext_Matching_inChatGroup(ctx, field)
			case "remark":
				return ec.fieldContext_Matching_remark(ctx, field)
			case "dayRange":
				return ec.fieldContext_Matching_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Matching_preferredPeriods(ctx, field)
			case "properties":
				return ec.fieldContext_Matching_properties(ctx, field)
			case "startMatchingAt":
				return ec.fieldContext_Matching_startMatchingAt(ctx, field)
			case "deadline":
				return ec.fieldContext_Matching_deadline(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Matching_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Matching_createdAt(ctx, field)
			case "matchingResult":
				return ec.fieldContext_Matching_matchingResult(ctx, field)
			case "reviewed":
				return ec.fieldContext_Matching_reviewed(ctx, field)
			case "user":
				return ec.fieldContext_Matching_user(ctx, field)
			case "topic":
				return ec.fieldContext_Matching_topic(ctx, field)
			case "areas":
				return ec.fieldContext_Matching_areas(ctx, field)
			case "city":
				return ec.fieldContext_Matching_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Matching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Entity_findMatchingByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Entity_findMatchingQuotaByUserID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_findMatchingQuotaByUserID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Entity().FindMatchingQuotaByUserID(rctx, fc.Args["userID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.MatchingQuota)
	fc.Result = res
	return ec.marshalNMatchingQuota2whalepkgmodelsMatchingQuota(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_findMatchingQuotaByUserID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userId":
				return ec.fieldContext_MatchingQuota_userId(ctx, field)
			case "remain":
				return ec.fieldContext_MatchingQuota_remain(ctx, field)
			case "total":
				return ec.fieldContext_MatchingQuota_total(ctx, field)
			case "matchingNum":
				return ec.fieldContext_MatchingQuota_matchingNum(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingQuota_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingQuota_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingQuota", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Entity_findMatchingQuotaByUserID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Entity_findTopicByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_findTopicByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Entity().FindTopicByID(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Topic)
	fc.Result = res
	return ec.marshalNTopic2whalepkgmodelsTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_findTopicByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Topic_id(ctx, field)
			case "recentUsers":
				return ec.fieldContext_Topic_recentUsers(ctx, field)
			case "matchingNum":
				return ec.fieldContext_Topic_matchingNum(ctx, field)
			case "fuzzyMatchingNum":
				return ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Topic", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Entity_findTopicByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Entity_findUserByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_findUserByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Entity().FindUserByID(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2whalepkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_findUserByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "matchingQuota":
				return ec.fieldContext_User_matchingQuota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Entity_findUserByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _EvaluatorResult_score(ctx context.Context, field graphql.CollectedField, obj *matcher.EvaluatorResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EvaluatorResult_score(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Score, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EvaluatorResult_score(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EvaluatorResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EvaluatorResult_timeScore(ctx context.Context, field graphql.CollectedField, obj *matcher.EvaluatorResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EvaluatorResult_timeScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EvaluatorResult_timeScore(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EvaluatorResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EvaluatorResult_properties(ctx context.Context, field graphql.CollectedField, obj *matcher.EvaluatorResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EvaluatorResult_properties(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Properties, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EvaluatorResult_properties(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EvaluatorResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EvaluatorResult_failedReason(ctx context.Context, field graphql.CollectedField, obj *matcher.EvaluatorResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EvaluatorResult_failedReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EvaluatorResult().FailedReason(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EvaluatorResult_failedReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EvaluatorResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HotTopicsInArea_cityId(ctx context.Context, field graphql.CollectedField, obj *models.HotTopicsInArea) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HotTopicsInArea_cityId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HotTopicsInArea_cityId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HotTopicsInArea",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HotTopicsInArea_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.HotTopicsInArea) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HotTopicsInArea_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HotTopicsInArea_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HotTopicsInArea",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HotTopicsInArea_topicMetrics(ctx context.Context, field graphql.CollectedField, obj *models.HotTopicsInArea) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HotTopicsInArea_topicMetrics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicMetrics, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.TopicMetrics)
	fc.Result = res
	return ec.marshalNTopicMetrics2whalepkgmodelsTopicMetrics(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HotTopicsInArea_topicMetrics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HotTopicsInArea",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TopicMetrics_id(ctx, field)
			case "matched":
				return ec.fieldContext_TopicMetrics_matched(ctx, field)
			case "matching":
				return ec.fieldContext_TopicMetrics_matching(ctx, field)
			case "heat":
				return ec.fieldContext_TopicMetrics_heat(ctx, field)
			case "topic":
				return ec.fieldContext_TopicMetrics_topic(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TopicMetrics", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HotTopicsInArea_city(ctx context.Context, field graphql.CollectedField, obj *models.HotTopicsInArea) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HotTopicsInArea_city(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.HotTopicsInArea().City(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Area)
	fc.Result = res
	return ec.marshalNArea2whalepkgmodelsArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HotTopicsInArea_city(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HotTopicsInArea",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LevelRights_level(ctx context.Context, field graphql.CollectedField, obj *models.LevelRights) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LevelRights_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LevelRights_level(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LevelRights",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LevelRights_matchingQuota(ctx context.Context, field graphql.CollectedField, obj *models.LevelRights) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LevelRights_matchingQuota(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchingQuota, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LevelRights_matchingQuota(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LevelRights",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LevelRights_matchingDurationConstraint(ctx context.Context, field graphql.CollectedField, obj *models.LevelRights) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LevelRights_matchingDurationConstraint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchingDurationConstraint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LevelRights_matchingDurationConstraint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LevelRights",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_id(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_topicId(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_topicId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_topicId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_userId(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_areaIds(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_areaIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AreaIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_areaIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_cityId(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_cityId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_cityId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_gender(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_gender(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Matching().Gender(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Gender)
	fc.Result = res
	return ec.marshalNGender2whalepkgmodelsGender(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_gender(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Gender does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_state(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Matching().State(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.MatchingState)
	fc.Result = res
	return ec.marshalNMatchingState2whalepkgmodelsMatchingState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MatchingState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_rejectedUserIds(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_rejectedUserIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.RejectedUserIDs, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_rejectedUserIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_inChatGroup(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_inChatGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InChatGroup, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_inChatGroup(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_remark(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_remark(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Remark, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_remark(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_dayRange(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_dayRange(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DayRange, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_dayRange(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_preferredPeriods(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_preferredPeriods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Matching().PreferredPeriods(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.DatePeriod)
	fc.Result = res
	return ec.marshalNDatePeriod2whalepkgmodelsDatePeriod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_preferredPeriods(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DatePeriod does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_properties(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_properties(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Properties, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.MatchingProperty)
	fc.Result = res
	return ec.marshalNMatchingProperty2whalepkgmodelsMatchingProperty(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_properties(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingProperty_id(ctx, field)
			case "values":
				return ec.fieldContext_MatchingProperty_values(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingProperty", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_startMatchingAt(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_startMatchingAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.StartMatchingAt, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_startMatchingAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_deadline(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_deadline(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Deadline, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_deadline(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_matchingResult(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_matchingResult(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Matching().MatchingResult(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MatchingResult)
	fc.Result = res
	return ec.marshalOMatchingResult2whalepkgmodelsMatchingResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_matchingResult(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingResult_id(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingResult_matchingIds(ctx, field)
			case "motionIds":
				return ec.fieldContext_MatchingResult_motionIds(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingResult_topicId(ctx, field)
			case "userIds":
				return ec.fieldContext_MatchingResult_userIds(ctx, field)
			case "confirmStates":
				return ec.fieldContext_MatchingResult_confirmStates(ctx, field)
			case "userConfirmStates":
				return ec.fieldContext_MatchingResult_userConfirmStates(ctx, field)
			case "chatGroupId":
				return ec.fieldContext_MatchingResult_chatGroupId(ctx, field)
			case "chatGroupState":
				return ec.fieldContext_MatchingResult_chatGroupState(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingResult_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingResult_createdAt(ctx, field)
			case "matchingScore":
				return ec.fieldContext_MatchingResult_matchingScore(ctx, field)
			case "closed":
				return ec.fieldContext_MatchingResult_closed(ctx, field)
			case "finishedAt":
				return ec.fieldContext_MatchingResult_finishedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_MatchingResult_createdBy(ctx, field)
			case "users":
				return ec.fieldContext_MatchingResult_users(ctx, field)
			case "discoverMotion":
				return ec.fieldContext_MatchingResult_discoverMotion(ctx, field)
			case "matchingPreviews":
				return ec.fieldContext_MatchingResult_matchingPreviews(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingResult_topic(ctx, field)
			case "chatGroup":
				return ec.fieldContext_MatchingResult_chatGroup(ctx, field)
			case "matchingDegree":
				return ec.fieldContext_MatchingResult_matchingDegree(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_reviewed(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_reviewed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Matching().Reviewed(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_reviewed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_user(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Matching().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2whalepkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "matchingQuota":
				return ec.fieldContext_User_matchingQuota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_topic(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_topic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Matching().Topic(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Topic)
	fc.Result = res
	return ec.marshalNTopic2whalepkgmodelsTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_topic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Topic_id(ctx, field)
			case "recentUsers":
				return ec.fieldContext_Topic_recentUsers(ctx, field)
			case "matchingNum":
				return ec.fieldContext_Topic_matchingNum(ctx, field)
			case "fuzzyMatchingNum":
				return ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Topic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_areas(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_areas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Matching().Areas(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Area)
	fc.Result = res
	return ec.marshalNArea2whalepkgmodelsArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_areas(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Matching_city(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Matching_city(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Matching().City(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Area)
	fc.Result = res
	return ec.marshalNArea2whalepkgmodelsArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Matching_city(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Matching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingDurationConstraint_startDate(ctx context.Context, field graphql.CollectedField, obj *models.MatchingDurationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingDurationConstraint_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingDurationConstraint_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingDurationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingDurationConstraint_stopDate(ctx context.Context, field graphql.CollectedField, obj *models.MatchingDurationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingDurationConstraint_stopDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingDurationConstraint_stopDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingDurationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingDurationConstraint_total(ctx context.Context, field graphql.CollectedField, obj *models.MatchingDurationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingDurationConstraint_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingDurationConstraint_total(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingDurationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingDurationConstraint_remain(ctx context.Context, field graphql.CollectedField, obj *models.MatchingDurationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingDurationConstraint_remain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Remain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingDurationConstraint_remain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingDurationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingDurationConstraint_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.MatchingDurationConstraint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingDurationConstraint_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingDurationConstraint_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingDurationConstraint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_id(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_userId(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_inviteeId(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_inviteeId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InviteeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_inviteeId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_topicId(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_topicId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_topicId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_remark(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_remark(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Remark, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_remark(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_cityId(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_cityId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_cityId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_areaIds(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_areaIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AreaIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_areaIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_matchingResultId(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_matchingResultId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MatchingResultId, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_matchingResultId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_matchingIds(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_matchingIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchingIds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_matchingIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_confirmState(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_confirmState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingInvitation().ConfirmState(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.InvitationConfirmState)
	fc.Result = res
	return ec.marshalNInvitationConfirmState2whalepkgmodelsInvitationConfirmState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_confirmState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type InvitationConfirmState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_confirmedAt(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_confirmedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ConfirmedAt, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_confirmedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_invitee(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_invitee(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingInvitation().Invitee(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2whalepkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_invitee(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "matchingQuota":
				return ec.fieldContext_User_matchingQuota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_topic(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_topic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingInvitation().Topic(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Topic)
	fc.Result = res
	return ec.marshalNTopic2whalepkgmodelsTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_topic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Topic_id(ctx, field)
			case "recentUsers":
				return ec.fieldContext_Topic_recentUsers(ctx, field)
			case "matchingNum":
				return ec.fieldContext_Topic_matchingNum(ctx, field)
			case "fuzzyMatchingNum":
				return ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Topic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_areas(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_areas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingInvitation().Areas(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Area)
	fc.Result = res
	return ec.marshalNArea2whalepkgmodelsArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_areas(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_city(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_city(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingInvitation().City(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Area)
	fc.Result = res
	return ec.marshalNArea2whalepkgmodelsArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_city(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_user(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingInvitation().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2whalepkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "matchingQuota":
				return ec.fieldContext_User_matchingQuota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingInvitation_matchingResult(ctx context.Context, field graphql.CollectedField, obj *models.MatchingInvitation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingInvitation_matchingResult(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingInvitation().MatchingResult(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MatchingResult)
	fc.Result = res
	return ec.marshalOMatchingResult2whalepkgmodelsMatchingResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingInvitation_matchingResult(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingInvitation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingResult_id(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingResult_matchingIds(ctx, field)
			case "motionIds":
				return ec.fieldContext_MatchingResult_motionIds(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingResult_topicId(ctx, field)
			case "userIds":
				return ec.fieldContext_MatchingResult_userIds(ctx, field)
			case "confirmStates":
				return ec.fieldContext_MatchingResult_confirmStates(ctx, field)
			case "userConfirmStates":
				return ec.fieldContext_MatchingResult_userConfirmStates(ctx, field)
			case "chatGroupId":
				return ec.fieldContext_MatchingResult_chatGroupId(ctx, field)
			case "chatGroupState":
				return ec.fieldContext_MatchingResult_chatGroupState(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingResult_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingResult_createdAt(ctx, field)
			case "matchingScore":
				return ec.fieldContext_MatchingResult_matchingScore(ctx, field)
			case "closed":
				return ec.fieldContext_MatchingResult_closed(ctx, field)
			case "finishedAt":
				return ec.fieldContext_MatchingResult_finishedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_MatchingResult_createdBy(ctx, field)
			case "users":
				return ec.fieldContext_MatchingResult_users(ctx, field)
			case "discoverMotion":
				return ec.fieldContext_MatchingResult_discoverMotion(ctx, field)
			case "matchingPreviews":
				return ec.fieldContext_MatchingResult_matchingPreviews(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingResult_topic(ctx, field)
			case "chatGroup":
				return ec.fieldContext_MatchingResult_chatGroup(ctx, field)
			case "matchingDegree":
				return ec.fieldContext_MatchingResult_matchingDegree(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingOfTopic_userId(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingOfTopic_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingOfTopic_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingOfTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingOfTopic_gender(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingOfTopic_gender(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingOfTopic().Gender(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Gender)
	fc.Result = res
	return ec.marshalNGender2whalepkgmodelsGender(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingOfTopic_gender(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingOfTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Gender does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingOfTopic_remark(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingOfTopic_remark(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Remark, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingOfTopic_remark(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingOfTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingOfTopic_areaIds(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingOfTopic_areaIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AreaIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingOfTopic_areaIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingOfTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingOfTopic_cityId(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingOfTopic_cityId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingOfTopic_cityId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingOfTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingOfTopic_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingOfTopic_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingOfTopic_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingOfTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingOfTopic_user(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingOfTopic_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingOfTopic().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2whalepkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingOfTopic_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingOfTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "matchingQuota":
				return ec.fieldContext_User_matchingQuota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingOfTopic_city(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingOfTopic_city(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingOfTopic().City(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Area)
	fc.Result = res
	return ec.marshalNArea2whalepkgmodelsArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingOfTopic_city(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingOfTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingOfTopic_areas(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingOfTopic_areas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingOfTopic().Areas(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Area)
	fc.Result = res
	return ec.marshalNArea2whalepkgmodelsArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingOfTopic_areas(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingOfTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingPreview_userId(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingPreview_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingPreview_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingPreview",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingPreview_remark(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingPreview_remark(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Remark, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingPreview_remark(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingPreview",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingPreview_properties(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingPreview_properties(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Properties, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.MatchingProperty)
	fc.Result = res
	return ec.marshalNMatchingProperty2whalepkgmodelsMatchingProperty(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingPreview_properties(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingPreview",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingProperty_id(ctx, field)
			case "values":
				return ec.fieldContext_MatchingProperty_values(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingProperty", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingPreview_dayRange(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingPreview_dayRange(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DayRange, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingPreview_dayRange(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingPreview",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingPreview_preferredPeriods(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingPreview_preferredPeriods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingPreview().PreferredPeriods(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.DatePeriod)
	fc.Result = res
	return ec.marshalNDatePeriod2whalepkgmodelsDatePeriod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingPreview_preferredPeriods(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingPreview",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DatePeriod does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingPreview_topicOptionConfig(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingPreview_topicOptionConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingPreview().TopicOptionConfig(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.TopicOptionConfig)
	fc.Result = res
	return ec.marshalOTopicOptionConfig2whalepkgmodelsTopicOptionConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingPreview_topicOptionConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingPreview",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "topicId":
				return ec.fieldContext_TopicOptionConfig_topicId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TopicOptionConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingPreview_user(ctx context.Context, field graphql.CollectedField, obj *models.Matching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingPreview_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingPreview().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2whalepkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingPreview_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingPreview",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "matchingQuota":
				return ec.fieldContext_User_matchingQuota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingProperty_id(ctx context.Context, field graphql.CollectedField, obj *models.MatchingProperty) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingProperty_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingProperty_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingProperty",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingProperty_values(ctx context.Context, field graphql.CollectedField, obj *models.MatchingProperty) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingProperty_values(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Values, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingProperty_values(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingProperty",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingQuota_userId(ctx context.Context, field graphql.CollectedField, obj *models.MatchingQuota) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingQuota_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingQuota_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingQuota",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingQuota_remain(ctx context.Context, field graphql.CollectedField, obj *models.MatchingQuota) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingQuota_remain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Remain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingQuota_remain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingQuota",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingQuota_total(ctx context.Context, field graphql.CollectedField, obj *models.MatchingQuota) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingQuota_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingQuota_total(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingQuota",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingQuota_matchingNum(ctx context.Context, field graphql.CollectedField, obj *models.MatchingQuota) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingQuota_matchingNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchingNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingQuota_matchingNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingQuota",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingQuota_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.MatchingQuota) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingQuota_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingQuota_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingQuota",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingQuota_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.MatchingQuota) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingQuota_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingQuota_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingQuota",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_id(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_matchingIds(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_matchingIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchingIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_matchingIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_motionIds(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_motionIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MotionIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_motionIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_topicId(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_topicId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_topicId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_userIds(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_userIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_userIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_confirmStates(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_confirmStates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingResult().ConfirmStates(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.MatchingResultConfirmState)
	fc.Result = res
	return ec.marshalNMatchingResultConfirmState2whalepkgmodelsMatchingResultConfirmState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_confirmStates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MatchingResultConfirmState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_userConfirmStates(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_userConfirmStates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingResult().UserConfirmStates(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.UserConfirmState)
	fc.Result = res
	return ec.marshalNUserConfirmState2whalepkgmodelsUserConfirmState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_userConfirmStates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userId":
				return ec.fieldContext_UserConfirmState_userId(ctx, field)
			case "state":
				return ec.fieldContext_UserConfirmState_state(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserConfirmState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_chatGroupId(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_chatGroupId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChatGroupID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_chatGroupId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_chatGroupState(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_chatGroupState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingResult().ChatGroupState(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.ChatGroupState)
	fc.Result = res
	return ec.marshalNChatGroupState2whalepkgmodelsChatGroupState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_chatGroupState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChatGroupState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.UpdatedAt, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_matchingScore(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_matchingScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MatchingScore, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_matchingScore(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_closed(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_closed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Closed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_closed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_finishedAt(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_finishedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FinishedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_finishedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_createdBy(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.MatchingResult().CreatedBy(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(models.ResultCreatedBy); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be whale/pkg/models.ResultCreatedBy`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.ResultCreatedBy)
	fc.Result = res
	return ec.marshalNResultCreatedBy2whalepkgmodelsResultCreatedBy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ResultCreatedBy does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_users(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingResult().Users(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.User)
	fc.Result = res
	return ec.marshalNUser2whalepkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "matchingQuota":
				return ec.fieldContext_User_matchingQuota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_discoverMotion(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_discoverMotion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingResult().DiscoverMotion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Motion)
	fc.Result = res
	return ec.marshalNDiscoverMotion2whalepkgmodelsMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_discoverMotion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscoverMotion_id(ctx, field)
			case "userId":
				return ec.fieldContext_DiscoverMotion_userId(ctx, field)
			case "topicId":
				return ec.fieldContext_DiscoverMotion_topicId(ctx, field)
			case "properties":
				return ec.fieldContext_DiscoverMotion_properties(ctx, field)
			case "cityId":
				return ec.fieldContext_DiscoverMotion_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_DiscoverMotion_areaIds(ctx, field)
			case "gender":
				return ec.fieldContext_DiscoverMotion_gender(ctx, field)
			case "dayRange":
				return ec.fieldContext_DiscoverMotion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_DiscoverMotion_preferredPeriods(ctx, field)
			case "remark":
				return ec.fieldContext_DiscoverMotion_remark(ctx, field)
			case "likeCount":
				return ec.fieldContext_DiscoverMotion_likeCount(ctx, field)
			case "viewCount":
				return ec.fieldContext_DiscoverMotion_viewCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_DiscoverMotion_thumbsUpCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_DiscoverMotion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_DiscoverMotion_liked(ctx, field)
			case "submitted":
				return ec.fieldContext_DiscoverMotion_submitted(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_DiscoverMotion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_DiscoverMotion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_DiscoverMotion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_DiscoverMotion_user(ctx, field)
			case "city":
				return ec.fieldContext_DiscoverMotion_city(ctx, field)
			case "areas":
				return ec.fieldContext_DiscoverMotion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscoverMotion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_matchingPreviews(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_matchingPreviews(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingResult().MatchingPreviews(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Matching)
	fc.Result = res
	return ec.marshalNMatchingPreview2whalepkgmodelsMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_matchingPreviews(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userId":
				return ec.fieldContext_MatchingPreview_userId(ctx, field)
			case "remark":
				return ec.fieldContext_MatchingPreview_remark(ctx, field)
			case "properties":
				return ec.fieldContext_MatchingPreview_properties(ctx, field)
			case "dayRange":
				return ec.fieldContext_MatchingPreview_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_MatchingPreview_preferredPeriods(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_MatchingPreview_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_MatchingPreview_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingPreview", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_topic(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_topic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingResult().Topic(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Topic)
	fc.Result = res
	return ec.marshalNTopic2whalepkgmodelsTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_topic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Topic_id(ctx, field)
			case "recentUsers":
				return ec.fieldContext_Topic_recentUsers(ctx, field)
			case "matchingNum":
				return ec.fieldContext_Topic_matchingNum(ctx, field)
			case "fuzzyMatchingNum":
				return ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Topic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_chatGroup(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_chatGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingResult().ChatGroup(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ChatGroup)
	fc.Result = res
	return ec.marshalOChatGroup2whalepkgmodelsChatGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_chatGroup(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ChatGroup_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChatGroup", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResult_matchingDegree(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResult_matchingDegree(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MatchingResult().MatchingDegree(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResult_matchingDegree(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResultConfirmAction_id(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResultConfirmAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResultConfirmAction_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResultConfirmAction_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResultConfirmAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResultConfirmAction_matchingResultId(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResultConfirmAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResultConfirmAction_matchingResultId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchingResultID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResultConfirmAction_matchingResultId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResultConfirmAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResultConfirmAction_userId(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResultConfirmAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResultConfirmAction_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResultConfirmAction_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResultConfirmAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResultConfirmAction_confirmed(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResultConfirmAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResultConfirmAction_confirmed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Confirmed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResultConfirmAction_confirmed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResultConfirmAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchingResultConfirmAction_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.MatchingResultConfirmAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchingResultConfirmAction_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchingResultConfirmAction_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchingResultConfirmAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_id(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_userId(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_cityId(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_cityId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_cityId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_remark(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_remark(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Remark, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_remark(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_active(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_active(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Active, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_active(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_inOfferNum(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_inOfferNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InOfferNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_inOfferNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_outOfferNum(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_outOfferNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OutOfferNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_outOfferNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_pendingInNum(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_pendingInNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PendingInNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_pendingInNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_pendingOutNum(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_pendingOutNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PendingOutNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_pendingOutNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_activeNum(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_activeNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActiveNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_activeNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_discoverable(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_discoverable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Discoverable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_discoverable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_relatedMatchingId(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_relatedMatchingId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RelatedMatchingID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_relatedMatchingId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_properties(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_properties(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Properties, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.MotionProperty)
	fc.Result = res
	return ec.marshalNMotionProperty2whalepkgmodelsMotionProperty(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_properties(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MotionProperty_id(ctx, field)
			case "values":
				return ec.fieldContext_MotionProperty_values(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MotionProperty", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_dayRange(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_dayRange(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DayRange, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_dayRange(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_preferredPeriods(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_preferredPeriods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Motion().PreferredPeriods(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.DatePeriod)
	fc.Result = res
	return ec.marshalNDatePeriod2whalepkgmodelsDatePeriod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_preferredPeriods(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DatePeriod does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_gender(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_gender(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Motion().Gender(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Gender)
	fc.Result = res
	return ec.marshalNGender2whalepkgmodelsGender(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_gender(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Gender does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_liked(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_liked(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Motion().Liked(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_liked(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_viewCount(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_viewCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ViewCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_viewCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_likeCount(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_likeCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LikeCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_likeCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_thumbsUpCount(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_thumbsUpCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ThumbsUpCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_thumbsUpCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_thumbsUp(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_thumbsUp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Motion().ThumbsUp(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_thumbsUp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_topic(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_topic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Motion().Topic(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Topic)
	fc.Result = res
	return ec.marshalNTopic2whalepkgmodelsTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_topic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Topic_id(ctx, field)
			case "recentUsers":
				return ec.fieldContext_Topic_recentUsers(ctx, field)
			case "matchingNum":
				return ec.fieldContext_Topic_matchingNum(ctx, field)
			case "fuzzyMatchingNum":
				return ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Topic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_topicOptionConfig(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_topicOptionConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Motion().TopicOptionConfig(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.TopicOptionConfig)
	fc.Result = res
	return ec.marshalOTopicOptionConfig2whalepkgmodelsTopicOptionConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_topicOptionConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "topicId":
				return ec.fieldContext_TopicOptionConfig_topicId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TopicOptionConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_user(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Motion().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2whalepkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "matchingQuota":
				return ec.fieldContext_User_matchingQuota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_city(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_city(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Motion().City(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Area)
	fc.Result = res
	return ec.marshalNArea2whalepkgmodelsArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_city(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Motion_areas(ctx context.Context, field graphql.CollectedField, obj *models.Motion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Motion_areas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Motion().Areas(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Area)
	fc.Result = res
	return ec.marshalNArea2whalepkgmodelsArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Motion_areas(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Motion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionOfferRecord_id(ctx context.Context, field graphql.CollectedField, obj *models.MotionOfferRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionOfferRecord_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionOfferRecord_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionOfferRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionOfferRecord_toMotionId(ctx context.Context, field graphql.CollectedField, obj *models.MotionOfferRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionOfferRecord_toMotionId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToMotionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionOfferRecord_toMotionId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionOfferRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionOfferRecord_motionId(ctx context.Context, field graphql.CollectedField, obj *models.MotionOfferRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionOfferRecord_motionId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MotionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionOfferRecord_motionId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionOfferRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionOfferRecord_state(ctx context.Context, field graphql.CollectedField, obj *models.MotionOfferRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionOfferRecord_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MotionOfferRecord().State(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.MotionOfferState)
	fc.Result = res
	return ec.marshalNMotionOfferState2whalepkgmodelsMotionOfferState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionOfferRecord_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionOfferRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MotionOfferState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionOfferRecord_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.MotionOfferRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionOfferRecord_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CreatedAt, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AdminOnly == nil {
				return nil, errors.New("directive adminOnly is not implemented")
			}
			return ec.directives.AdminOnly(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionOfferRecord_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionOfferRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionOfferRecord_reactAt(ctx context.Context, field graphql.CollectedField, obj *models.MotionOfferRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionOfferRecord_reactAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReactAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionOfferRecord_reactAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionOfferRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionOfferRecord_remark(ctx context.Context, field graphql.CollectedField, obj *models.MotionOfferRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionOfferRecord_remark(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Remark, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionOfferRecord_remark(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionOfferRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionOfferRecord_chatChance(ctx context.Context, field graphql.CollectedField, obj *models.MotionOfferRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionOfferRecord_chatChance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChatChance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionOfferRecord_chatChance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionOfferRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionOfferRecord_reviewed(ctx context.Context, field graphql.CollectedField, obj *models.MotionOfferRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionOfferRecord_reviewed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MotionOfferRecord().Reviewed(rctx, obj, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionOfferRecord_reviewed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionOfferRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_MotionOfferRecord_reviewed_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _MotionOfferRecord_toMotion(ctx context.Context, field graphql.CollectedField, obj *models.MotionOfferRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionOfferRecord_toMotion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MotionOfferRecord().ToMotion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Motion)
	fc.Result = res
	return ec.marshalNDiscoverMotion2whalepkgmodelsMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionOfferRecord_toMotion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionOfferRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscoverMotion_id(ctx, field)
			case "userId":
				return ec.fieldContext_DiscoverMotion_userId(ctx, field)
			case "topicId":
				return ec.fieldContext_DiscoverMotion_topicId(ctx, field)
			case "properties":
				return ec.fieldContext_DiscoverMotion_properties(ctx, field)
			case "cityId":
				return ec.fieldContext_DiscoverMotion_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_DiscoverMotion_areaIds(ctx, field)
			case "gender":
				return ec.fieldContext_DiscoverMotion_gender(ctx, field)
			case "dayRange":
				return ec.fieldContext_DiscoverMotion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_DiscoverMotion_preferredPeriods(ctx, field)
			case "remark":
				return ec.fieldContext_DiscoverMotion_remark(ctx, field)
			case "likeCount":
				return ec.fieldContext_DiscoverMotion_likeCount(ctx, field)
			case "viewCount":
				return ec.fieldContext_DiscoverMotion_viewCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_DiscoverMotion_thumbsUpCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_DiscoverMotion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_DiscoverMotion_liked(ctx, field)
			case "submitted":
				return ec.fieldContext_DiscoverMotion_submitted(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_DiscoverMotion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_DiscoverMotion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_DiscoverMotion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_DiscoverMotion_user(ctx, field)
			case "city":
				return ec.fieldContext_DiscoverMotion_city(ctx, field)
			case "areas":
				return ec.fieldContext_DiscoverMotion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscoverMotion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionOfferRecord_motion(ctx context.Context, field graphql.CollectedField, obj *models.MotionOfferRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionOfferRecord_motion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MotionOfferRecord().Motion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Motion)
	fc.Result = res
	return ec.marshalNDiscoverMotion2whalepkgmodelsMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionOfferRecord_motion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionOfferRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscoverMotion_id(ctx, field)
			case "userId":
				return ec.fieldContext_DiscoverMotion_userId(ctx, field)
			case "topicId":
				return ec.fieldContext_DiscoverMotion_topicId(ctx, field)
			case "properties":
				return ec.fieldContext_DiscoverMotion_properties(ctx, field)
			case "cityId":
				return ec.fieldContext_DiscoverMotion_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_DiscoverMotion_areaIds(ctx, field)
			case "gender":
				return ec.fieldContext_DiscoverMotion_gender(ctx, field)
			case "dayRange":
				return ec.fieldContext_DiscoverMotion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_DiscoverMotion_preferredPeriods(ctx, field)
			case "remark":
				return ec.fieldContext_DiscoverMotion_remark(ctx, field)
			case "likeCount":
				return ec.fieldContext_DiscoverMotion_likeCount(ctx, field)
			case "viewCount":
				return ec.fieldContext_DiscoverMotion_viewCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_DiscoverMotion_thumbsUpCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_DiscoverMotion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_DiscoverMotion_liked(ctx, field)
			case "submitted":
				return ec.fieldContext_DiscoverMotion_submitted(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_DiscoverMotion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_DiscoverMotion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_DiscoverMotion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_DiscoverMotion_user(ctx, field)
			case "city":
				return ec.fieldContext_DiscoverMotion_city(ctx, field)
			case "areas":
				return ec.fieldContext_DiscoverMotion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscoverMotion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionProperty_id(ctx context.Context, field graphql.CollectedField, obj *models.MotionProperty) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionProperty_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionProperty_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionProperty",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MotionProperty_values(ctx context.Context, field graphql.CollectedField, obj *models.MotionProperty) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MotionProperty_values(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Values, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MotionProperty_values(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MotionProperty",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_refreshTopicMetrics(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_refreshTopicMetrics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RefreshTopicMetrics(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_refreshTopicMetrics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateDurationConstraint(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateDurationConstraint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateDurationConstraint(rctx, fc.Args["userId"].(string), fc.Args["param"].(models.UpdateDurationConstraintParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateDurationConstraint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateDurationConstraint_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMatchingInvitation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMatchingInvitation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateMatchingInvitation(rctx, fc.Args["userId"].(*string), fc.Args["param"].(models.CreateMatchingInvitationParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.MatchingInvitation)
	fc.Result = res
	return ec.marshalNMatchingInvitation2whalepkgmodelsMatchingInvitation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMatchingInvitation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingInvitation_id(ctx, field)
			case "userId":
				return ec.fieldContext_MatchingInvitation_userId(ctx, field)
			case "inviteeId":
				return ec.fieldContext_MatchingInvitation_inviteeId(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingInvitation_topicId(ctx, field)
			case "remark":
				return ec.fieldContext_MatchingInvitation_remark(ctx, field)
			case "cityId":
				return ec.fieldContext_MatchingInvitation_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_MatchingInvitation_areaIds(ctx, field)
			case "matchingResultId":
				return ec.fieldContext_MatchingInvitation_matchingResultId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingInvitation_matchingIds(ctx, field)
			case "confirmState":
				return ec.fieldContext_MatchingInvitation_confirmState(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_MatchingInvitation_confirmedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingInvitation_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingInvitation_updatedAt(ctx, field)
			case "invitee":
				return ec.fieldContext_MatchingInvitation_invitee(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingInvitation_topic(ctx, field)
			case "areas":
				return ec.fieldContext_MatchingInvitation_areas(ctx, field)
			case "city":
				return ec.fieldContext_MatchingInvitation_city(ctx, field)
			case "user":
				return ec.fieldContext_MatchingInvitation_user(ctx, field)
			case "matchingResult":
				return ec.fieldContext_MatchingInvitation_matchingResult(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingInvitation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMatchingInvitation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelMatchingInvitation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cancelMatchingInvitation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CancelMatchingInvitation(rctx, fc.Args["invitationId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cancelMatchingInvitation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelMatchingInvitation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_confirmMatchingInvitation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_confirmMatchingInvitation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ConfirmMatchingInvitation(rctx, fc.Args["userId"].(*string), fc.Args["invitationId"].(string), fc.Args["confirm"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_confirmMatchingInvitation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_confirmMatchingInvitation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateMatchingInvitation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateMatchingInvitation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateMatchingInvitation(rctx, fc.Args["invitationId"].(string), fc.Args["param"].(models.UpdateMatchingInvitationParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.MatchingInvitation)
	fc.Result = res
	return ec.marshalNMatchingInvitation2whalepkgmodelsMatchingInvitation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateMatchingInvitation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingInvitation_id(ctx, field)
			case "userId":
				return ec.fieldContext_MatchingInvitation_userId(ctx, field)
			case "inviteeId":
				return ec.fieldContext_MatchingInvitation_inviteeId(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingInvitation_topicId(ctx, field)
			case "remark":
				return ec.fieldContext_MatchingInvitation_remark(ctx, field)
			case "cityId":
				return ec.fieldContext_MatchingInvitation_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_MatchingInvitation_areaIds(ctx, field)
			case "matchingResultId":
				return ec.fieldContext_MatchingInvitation_matchingResultId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingInvitation_matchingIds(ctx, field)
			case "confirmState":
				return ec.fieldContext_MatchingInvitation_confirmState(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_MatchingInvitation_confirmedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingInvitation_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingInvitation_updatedAt(ctx, field)
			case "invitee":
				return ec.fieldContext_MatchingInvitation_invitee(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingInvitation_topic(ctx, field)
			case "areas":
				return ec.fieldContext_MatchingInvitation_areas(ctx, field)
			case "city":
				return ec.fieldContext_MatchingInvitation_city(ctx, field)
			case "user":
				return ec.fieldContext_MatchingInvitation_user(ctx, field)
			case "matchingResult":
				return ec.fieldContext_MatchingInvitation_matchingResult(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingInvitation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateMatchingInvitation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMatching(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMatching(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateMatching(rctx, fc.Args["userId"].(*string), fc.Args["param"].(models.CreateMatchingParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Matching)
	fc.Result = res
	return ec.marshalNMatching2whalepkgmodelsMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMatching(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Matching_id(ctx, field)
			case "topicId":
				return ec.fieldContext_Matching_topicId(ctx, field)
			case "userId":
				return ec.fieldContext_Matching_userId(ctx, field)
			case "areaIds":
				return ec.fieldContext_Matching_areaIds(ctx, field)
			case "cityId":
				return ec.fieldContext_Matching_cityId(ctx, field)
			case "gender":
				return ec.fieldContext_Matching_gender(ctx, field)
			case "state":
				return ec.fieldContext_Matching_state(ctx, field)
			case "rejectedUserIds":
				return ec.fieldContext_Matching_rejectedUserIds(ctx, field)
			case "inChatGroup":
				return ec.fieldContext_Matching_inChatGroup(ctx, field)
			case "remark":
				return ec.fieldContext_Matching_remark(ctx, field)
			case "dayRange":
				return ec.fieldContext_Matching_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Matching_preferredPeriods(ctx, field)
			case "properties":
				return ec.fieldContext_Matching_properties(ctx, field)
			case "startMatchingAt":
				return ec.fieldContext_Matching_startMatchingAt(ctx, field)
			case "deadline":
				return ec.fieldContext_Matching_deadline(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Matching_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Matching_createdAt(ctx, field)
			case "matchingResult":
				return ec.fieldContext_Matching_matchingResult(ctx, field)
			case "reviewed":
				return ec.fieldContext_Matching_reviewed(ctx, field)
			case "user":
				return ec.fieldContext_Matching_user(ctx, field)
			case "topic":
				return ec.fieldContext_Matching_topic(ctx, field)
			case "areas":
				return ec.fieldContext_Matching_areas(ctx, field)
			case "city":
				return ec.fieldContext_Matching_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Matching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMatching_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMatchingV2(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMatchingV2(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateMatchingV2(rctx, fc.Args["userId"].(*string), fc.Args["param"].(models.CreateMatchingParamV2))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Matching)
	fc.Result = res
	return ec.marshalNMatching2whalepkgmodelsMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMatchingV2(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Matching_id(ctx, field)
			case "topicId":
				return ec.fieldContext_Matching_topicId(ctx, field)
			case "userId":
				return ec.fieldContext_Matching_userId(ctx, field)
			case "areaIds":
				return ec.fieldContext_Matching_areaIds(ctx, field)
			case "cityId":
				return ec.fieldContext_Matching_cityId(ctx, field)
			case "gender":
				return ec.fieldContext_Matching_gender(ctx, field)
			case "state":
				return ec.fieldContext_Matching_state(ctx, field)
			case "rejectedUserIds":
				return ec.fieldContext_Matching_rejectedUserIds(ctx, field)
			case "inChatGroup":
				return ec.fieldContext_Matching_inChatGroup(ctx, field)
			case "remark":
				return ec.fieldContext_Matching_remark(ctx, field)
			case "dayRange":
				return ec.fieldContext_Matching_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Matching_preferredPeriods(ctx, field)
			case "properties":
				return ec.fieldContext_Matching_properties(ctx, field)
			case "startMatchingAt":
				return ec.fieldContext_Matching_startMatchingAt(ctx, field)
			case "deadline":
				return ec.fieldContext_Matching_deadline(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Matching_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Matching_createdAt(ctx, field)
			case "matchingResult":
				return ec.fieldContext_Matching_matchingResult(ctx, field)
			case "reviewed":
				return ec.fieldContext_Matching_reviewed(ctx, field)
			case "user":
				return ec.fieldContext_Matching_user(ctx, field)
			case "topic":
				return ec.fieldContext_Matching_topic(ctx, field)
			case "areas":
				return ec.fieldContext_Matching_areas(ctx, field)
			case "city":
				return ec.fieldContext_Matching_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Matching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMatchingV2_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateMatching(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateMatching(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateMatching(rctx, fc.Args["matchingId"].(string), fc.Args["param"].(models.UpdateMatchingParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Matching)
	fc.Result = res
	return ec.marshalNMatching2whalepkgmodelsMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateMatching(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Matching_id(ctx, field)
			case "topicId":
				return ec.fieldContext_Matching_topicId(ctx, field)
			case "userId":
				return ec.fieldContext_Matching_userId(ctx, field)
			case "areaIds":
				return ec.fieldContext_Matching_areaIds(ctx, field)
			case "cityId":
				return ec.fieldContext_Matching_cityId(ctx, field)
			case "gender":
				return ec.fieldContext_Matching_gender(ctx, field)
			case "state":
				return ec.fieldContext_Matching_state(ctx, field)
			case "rejectedUserIds":
				return ec.fieldContext_Matching_rejectedUserIds(ctx, field)
			case "inChatGroup":
				return ec.fieldContext_Matching_inChatGroup(ctx, field)
			case "remark":
				return ec.fieldContext_Matching_remark(ctx, field)
			case "dayRange":
				return ec.fieldContext_Matching_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Matching_preferredPeriods(ctx, field)
			case "properties":
				return ec.fieldContext_Matching_properties(ctx, field)
			case "startMatchingAt":
				return ec.fieldContext_Matching_startMatchingAt(ctx, field)
			case "deadline":
				return ec.fieldContext_Matching_deadline(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Matching_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Matching_createdAt(ctx, field)
			case "matchingResult":
				return ec.fieldContext_Matching_matchingResult(ctx, field)
			case "reviewed":
				return ec.fieldContext_Matching_reviewed(ctx, field)
			case "user":
				return ec.fieldContext_Matching_user(ctx, field)
			case "topic":
				return ec.fieldContext_Matching_topic(ctx, field)
			case "areas":
				return ec.fieldContext_Matching_areas(ctx, field)
			case "city":
				return ec.fieldContext_Matching_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Matching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateMatching_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateMatchingQuota(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateMatchingQuota(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateMatchingQuota(rctx, fc.Args["userId"].(string), fc.Args["param"].(models.UpdateMatchingQuotaParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateMatchingQuota(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateMatchingQuota_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateMatchingDurationConstraint(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateMatchingDurationConstraint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateMatchingDurationConstraint(rctx, fc.Args["userId"].(string), fc.Args["param"].(models.UpdateMatchingDurationConstraintParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateMatchingDurationConstraint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateMatchingDurationConstraint_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_confirmMatchingResult(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_confirmMatchingResult(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ConfirmMatchingResult(rctx, fc.Args["userId"].(*string), fc.Args["matchingId"].(string), fc.Args["reject"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_confirmMatchingResult(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_confirmMatchingResult_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_confirmMatchingResultV2(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_confirmMatchingResultV2(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ConfirmMatchingResultV2(rctx, fc.Args["userId"].(*string), fc.Args["matchingId"].(string), fc.Args["confirm"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_confirmMatchingResultV2(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_confirmMatchingResultV2_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelMatching(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cancelMatching(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CancelMatching(rctx, fc.Args["matchingId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cancelMatching(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelMatching_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_startMatching(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_startMatching(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().StartMatching(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_startMatching(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_finishMatching(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_finishMatching(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().FinishMatching(rctx, fc.Args["matchingId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_finishMatching(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_finishMatching_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_reviewMatching(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_reviewMatching(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ReviewMatching(rctx, fc.Args["matchingId"].(string), fc.Args["param"].(models.ReviewMatchingParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_reviewMatching(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_reviewMatching_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateRecentMatching(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateRecentMatching(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateRecentMatching(rctx, fc.Args["id"].(string), fc.Args["param"].(models.UpdateRecentMatchingParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.RecentMatching)
	fc.Result = res
	return ec.marshalNRecentMatching2whalepkgmodelsRecentMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateRecentMatching(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RecentMatching_id(ctx, field)
			case "cityId":
				return ec.fieldContext_RecentMatching_cityId(ctx, field)
			case "topicId":
				return ec.fieldContext_RecentMatching_topicId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_RecentMatching_matchingIds(ctx, field)
			case "createdAt":
				return ec.fieldContext_RecentMatching_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_RecentMatching_updatedAt(ctx, field)
			case "topic":
				return ec.fieldContext_RecentMatching_topic(ctx, field)
			case "city":
				return ec.fieldContext_RecentMatching_city(ctx, field)
			case "matchings":
				return ec.fieldContext_RecentMatching_matchings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RecentMatching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateRecentMatching_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addMatchingToRecent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addMatchingToRecent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddMatchingToRecent(rctx, fc.Args["matchingId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.RecentMatching)
	fc.Result = res
	return ec.marshalNRecentMatching2whalepkgmodelsRecentMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addMatchingToRecent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RecentMatching_id(ctx, field)
			case "cityId":
				return ec.fieldContext_RecentMatching_cityId(ctx, field)
			case "topicId":
				return ec.fieldContext_RecentMatching_topicId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_RecentMatching_matchingIds(ctx, field)
			case "createdAt":
				return ec.fieldContext_RecentMatching_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_RecentMatching_updatedAt(ctx, field)
			case "topic":
				return ec.fieldContext_RecentMatching_topic(ctx, field)
			case "city":
				return ec.fieldContext_RecentMatching_city(ctx, field)
			case "matchings":
				return ec.fieldContext_RecentMatching_matchings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RecentMatching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addMatchingToRecent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_getMatchingScore(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_getMatchingScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().GetMatchingScore(rctx, fc.Args["id1"].(string), fc.Args["id2"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*matcher.EvaluatorResult)
	fc.Result = res
	return ec.marshalNEvaluatorResult2whalepkgmatcherEvaluatorResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_getMatchingScore(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "score":
				return ec.fieldContext_EvaluatorResult_score(ctx, field)
			case "timeScore":
				return ec.fieldContext_EvaluatorResult_timeScore(ctx, field)
			case "properties":
				return ec.fieldContext_EvaluatorResult_properties(ctx, field)
			case "failedReason":
				return ec.fieldContext_EvaluatorResult_failedReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EvaluatorResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_getMatchingScore_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_getAvailableMotionOffer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_getAvailableMotionOffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().GetAvailableMotionOffer(rctx, fc.Args["userId"].(*string), fc.Args["targetMotionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.AvailableMotionOffer)
	fc.Result = res
	return ec.marshalNAvailableMotionOffer2whalepkgmodelsAvailableMotionOffer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_getAvailableMotionOffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "motion":
				return ec.fieldContext_AvailableMotionOffer_motion(ctx, field)
			case "nextQuotaTime":
				return ec.fieldContext_AvailableMotionOffer_nextQuotaTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AvailableMotionOffer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_getAvailableMotionOffer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMotionOffer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMotionOffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateMotionOffer(rctx, fc.Args["myMotionId"].(string), fc.Args["targetMotionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.CreateMotionOfferResult)
	fc.Result = res
	return ec.marshalNCreateMotionOfferResult2whalepkgmodelsCreateMotionOfferResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMotionOffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "chatGroupId":
				return ec.fieldContext_CreateMotionOfferResult_chatGroupId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateMotionOfferResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMotionOffer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelMotionOffer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cancelMotionOffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CancelMotionOffer(rctx, fc.Args["myMotionId"].(string), fc.Args["targetMotionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cancelMotionOffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelMotionOffer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_acceptMotionOffer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_acceptMotionOffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AcceptMotionOffer(rctx, fc.Args["myMotionId"].(string), fc.Args["targetMotionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_acceptMotionOffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_acceptMotionOffer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_rejectMotionOffer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_rejectMotionOffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RejectMotionOffer(rctx, fc.Args["myMotionId"].(string), fc.Args["targetMotionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_rejectMotionOffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_rejectMotionOffer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_sendChatInOffer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_sendChatInOffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SendChatInOffer(rctx, fc.Args["myMotionId"].(string), fc.Args["targetMotionId"].(string), fc.Args["sentence"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_sendChatInOffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_sendChatInOffer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_finishMotionOffer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_finishMotionOffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().FinishMotionOffer(rctx, fc.Args["fromMotionId"].(string), fc.Args["toMotionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_finishMotionOffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_finishMotionOffer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_notifyNewMotionOffer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_notifyNewMotionOffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().NotifyNewMotionOffer(rctx, fc.Args["param"].(*models.NotifyNewMotionOfferMessageParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_notifyNewMotionOffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_notifyNewMotionOffer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_sendMotionOfferAcceptMessage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_sendMotionOfferAcceptMessage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SendMotionOfferAcceptMessage(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_sendMotionOfferAcceptMessage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_sendMotionOfferAcceptMessage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMotion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMotion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateMotion(rctx, fc.Args["userId"].(*string), fc.Args["param"].(models.CreateMotionParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Motion)
	fc.Result = res
	return ec.marshalNMotion2whalepkgmodelsMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMotion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Motion_id(ctx, field)
			case "userId":
				return ec.fieldContext_Motion_userId(ctx, field)
			case "cityId":
				return ec.fieldContext_Motion_cityId(ctx, field)
			case "remark":
				return ec.fieldContext_Motion_remark(ctx, field)
			case "active":
				return ec.fieldContext_Motion_active(ctx, field)
			case "inOfferNum":
				return ec.fieldContext_Motion_inOfferNum(ctx, field)
			case "outOfferNum":
				return ec.fieldContext_Motion_outOfferNum(ctx, field)
			case "pendingInNum":
				return ec.fieldContext_Motion_pendingInNum(ctx, field)
			case "pendingOutNum":
				return ec.fieldContext_Motion_pendingOutNum(ctx, field)
			case "activeNum":
				return ec.fieldContext_Motion_activeNum(ctx, field)
			case "discoverable":
				return ec.fieldContext_Motion_discoverable(ctx, field)
			case "relatedMatchingId":
				return ec.fieldContext_Motion_relatedMatchingId(ctx, field)
			case "properties":
				return ec.fieldContext_Motion_properties(ctx, field)
			case "dayRange":
				return ec.fieldContext_Motion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Motion_preferredPeriods(ctx, field)
			case "gender":
				return ec.fieldContext_Motion_gender(ctx, field)
			case "createdAt":
				return ec.fieldContext_Motion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_Motion_liked(ctx, field)
			case "viewCount":
				return ec.fieldContext_Motion_viewCount(ctx, field)
			case "likeCount":
				return ec.fieldContext_Motion_likeCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_Motion_thumbsUpCount(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_Motion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_Motion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_Motion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_Motion_user(ctx, field)
			case "city":
				return ec.fieldContext_Motion_city(ctx, field)
			case "areas":
				return ec.fieldContext_Motion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Motion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMotion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateMotion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateMotion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateMotion(rctx, fc.Args["id"].(string), fc.Args["param"].(models.UpdateMotionParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Motion)
	fc.Result = res
	return ec.marshalNMotion2whalepkgmodelsMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateMotion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Motion_id(ctx, field)
			case "userId":
				return ec.fieldContext_Motion_userId(ctx, field)
			case "cityId":
				return ec.fieldContext_Motion_cityId(ctx, field)
			case "remark":
				return ec.fieldContext_Motion_remark(ctx, field)
			case "active":
				return ec.fieldContext_Motion_active(ctx, field)
			case "inOfferNum":
				return ec.fieldContext_Motion_inOfferNum(ctx, field)
			case "outOfferNum":
				return ec.fieldContext_Motion_outOfferNum(ctx, field)
			case "pendingInNum":
				return ec.fieldContext_Motion_pendingInNum(ctx, field)
			case "pendingOutNum":
				return ec.fieldContext_Motion_pendingOutNum(ctx, field)
			case "activeNum":
				return ec.fieldContext_Motion_activeNum(ctx, field)
			case "discoverable":
				return ec.fieldContext_Motion_discoverable(ctx, field)
			case "relatedMatchingId":
				return ec.fieldContext_Motion_relatedMatchingId(ctx, field)
			case "properties":
				return ec.fieldContext_Motion_properties(ctx, field)
			case "dayRange":
				return ec.fieldContext_Motion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Motion_preferredPeriods(ctx, field)
			case "gender":
				return ec.fieldContext_Motion_gender(ctx, field)
			case "createdAt":
				return ec.fieldContext_Motion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_Motion_liked(ctx, field)
			case "viewCount":
				return ec.fieldContext_Motion_viewCount(ctx, field)
			case "likeCount":
				return ec.fieldContext_Motion_likeCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_Motion_thumbsUpCount(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_Motion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_Motion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_Motion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_Motion_user(ctx, field)
			case "city":
				return ec.fieldContext_Motion_city(ctx, field)
			case "areas":
				return ec.fieldContext_Motion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Motion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateMotion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_userUpdateMotion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_userUpdateMotion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UserUpdateMotion(rctx, fc.Args["myMotionId"].(string), fc.Args["param"].(models.UserUpdateMotionParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Motion)
	fc.Result = res
	return ec.marshalNMotion2whalepkgmodelsMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_userUpdateMotion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Motion_id(ctx, field)
			case "userId":
				return ec.fieldContext_Motion_userId(ctx, field)
			case "cityId":
				return ec.fieldContext_Motion_cityId(ctx, field)
			case "remark":
				return ec.fieldContext_Motion_remark(ctx, field)
			case "active":
				return ec.fieldContext_Motion_active(ctx, field)
			case "inOfferNum":
				return ec.fieldContext_Motion_inOfferNum(ctx, field)
			case "outOfferNum":
				return ec.fieldContext_Motion_outOfferNum(ctx, field)
			case "pendingInNum":
				return ec.fieldContext_Motion_pendingInNum(ctx, field)
			case "pendingOutNum":
				return ec.fieldContext_Motion_pendingOutNum(ctx, field)
			case "activeNum":
				return ec.fieldContext_Motion_activeNum(ctx, field)
			case "discoverable":
				return ec.fieldContext_Motion_discoverable(ctx, field)
			case "relatedMatchingId":
				return ec.fieldContext_Motion_relatedMatchingId(ctx, field)
			case "properties":
				return ec.fieldContext_Motion_properties(ctx, field)
			case "dayRange":
				return ec.fieldContext_Motion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Motion_preferredPeriods(ctx, field)
			case "gender":
				return ec.fieldContext_Motion_gender(ctx, field)
			case "createdAt":
				return ec.fieldContext_Motion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_Motion_liked(ctx, field)
			case "viewCount":
				return ec.fieldContext_Motion_viewCount(ctx, field)
			case "likeCount":
				return ec.fieldContext_Motion_likeCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_Motion_thumbsUpCount(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_Motion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_Motion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_Motion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_Motion_user(ctx, field)
			case "city":
				return ec.fieldContext_Motion_city(ctx, field)
			case "areas":
				return ec.fieldContext_Motion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Motion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_userUpdateMotion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_closeMotion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_closeMotion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CloseMotion(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_closeMotion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_closeMotion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_reviewMotionOffer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_reviewMotionOffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ReviewMotionOffer(rctx, fc.Args["userId"].(*string), fc.Args["fromMotionId"].(string), fc.Args["toMotionId"].(string), fc.Args["param"].(models.ReviewMotionParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_reviewMotionOffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_reviewMotionOffer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createCityTopics(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createCityTopics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateCityTopics(rctx, fc.Args["param"].(models.CreateCityTopicParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.CityTopics)
	fc.Result = res
	return ec.marshalNCityTopics2whalepkgmodelsCityTopics(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createCityTopics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cityId":
				return ec.fieldContext_CityTopics_cityId(ctx, field)
			case "topicIds":
				return ec.fieldContext_CityTopics_topicIds(ctx, field)
			case "updatedAt":
				return ec.fieldContext_CityTopics_updatedAt(ctx, field)
			case "topics":
				return ec.fieldContext_CityTopics_topics(ctx, field)
			case "city":
				return ec.fieldContext_CityTopics_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CityTopics", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createCityTopics_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateCityTopics(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateCityTopics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateCityTopics(rctx, fc.Args["cityId"].(string), fc.Args["param"].(models.UpdateCityTopicParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.CityTopics)
	fc.Result = res
	return ec.marshalNCityTopics2whalepkgmodelsCityTopics(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateCityTopics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cityId":
				return ec.fieldContext_CityTopics_cityId(ctx, field)
			case "topicIds":
				return ec.fieldContext_CityTopics_topicIds(ctx, field)
			case "updatedAt":
				return ec.fieldContext_CityTopics_updatedAt(ctx, field)
			case "topics":
				return ec.fieldContext_CityTopics_topics(ctx, field)
			case "city":
				return ec.fieldContext_CityTopics_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CityTopics", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateCityTopics_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateHotTopicsInArea(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateHotTopicsInArea(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateHotTopicsInArea(rctx, fc.Args["cityId"].(string), fc.Args["param"].(models.UpdateHotTopicParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.HotTopicsInArea)
	fc.Result = res
	return ec.marshalNHotTopicsInArea2whalepkgmodelsHotTopicsInArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateHotTopicsInArea(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cityId":
				return ec.fieldContext_HotTopicsInArea_cityId(ctx, field)
			case "updatedAt":
				return ec.fieldContext_HotTopicsInArea_updatedAt(ctx, field)
			case "topicMetrics":
				return ec.fieldContext_HotTopicsInArea_topicMetrics(ctx, field)
			case "city":
				return ec.fieldContext_HotTopicsInArea_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HotTopicsInArea", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateHotTopicsInArea_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateUserJoinTopic(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateUserJoinTopic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateUserJoinTopic(rctx, fc.Args["id"].(int), fc.Args["param"].(models.UpdateUserJoinTopicParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.UserJoinTopic)
	fc.Result = res
	return ec.marshalNUserJoinTopic2whalepkgmodelsUserJoinTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateUserJoinTopic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserJoinTopic_id(ctx, field)
			case "topicId":
				return ec.fieldContext_UserJoinTopic_topicId(ctx, field)
			case "cityId":
				return ec.fieldContext_UserJoinTopic_cityId(ctx, field)
			case "userId":
				return ec.fieldContext_UserJoinTopic_userId(ctx, field)
			case "latestMatchingId":
				return ec.fieldContext_UserJoinTopic_latestMatchingId(ctx, field)
			case "createdAt":
				return ec.fieldContext_UserJoinTopic_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_UserJoinTopic_updatedAt(ctx, field)
			case "topic":
				return ec.fieldContext_UserJoinTopic_topic(ctx, field)
			case "city":
				return ec.fieldContext_UserJoinTopic_city(ctx, field)
			case "user":
				return ec.fieldContext_UserJoinTopic_user(ctx, field)
			case "matching":
				return ec.fieldContext_UserJoinTopic_matching(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserJoinTopic", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUserJoinTopic_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createUserJoinTopic(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createUserJoinTopic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateUserJoinTopic(rctx, fc.Args["param"].(models.CreateUserJoinTopicParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.UserJoinTopic)
	fc.Result = res
	return ec.marshalNUserJoinTopic2whalepkgmodelsUserJoinTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createUserJoinTopic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserJoinTopic_id(ctx, field)
			case "topicId":
				return ec.fieldContext_UserJoinTopic_topicId(ctx, field)
			case "cityId":
				return ec.fieldContext_UserJoinTopic_cityId(ctx, field)
			case "userId":
				return ec.fieldContext_UserJoinTopic_userId(ctx, field)
			case "latestMatchingId":
				return ec.fieldContext_UserJoinTopic_latestMatchingId(ctx, field)
			case "createdAt":
				return ec.fieldContext_UserJoinTopic_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_UserJoinTopic_updatedAt(ctx, field)
			case "topic":
				return ec.fieldContext_UserJoinTopic_topic(ctx, field)
			case "city":
				return ec.fieldContext_UserJoinTopic_city(ctx, field)
			case "user":
				return ec.fieldContext_UserJoinTopic_user(ctx, field)
			case "matching":
				return ec.fieldContext_UserJoinTopic_matching(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserJoinTopic", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createUserJoinTopic_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_likeMotion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_likeMotion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().LikeMotion(rctx, fc.Args["userId"].(*string), fc.Args["motionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_likeMotion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_likeMotion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unlikeMotion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unlikeMotion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UnlikeMotion(rctx, fc.Args["userId"].(*string), fc.Args["motionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unlikeMotion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unlikeMotion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_thumbsUpMotion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_thumbsUpMotion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ThumbsUpMotion(rctx, fc.Args["userId"].(*string), fc.Args["motionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_thumbsUpMotion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_thumbsUpMotion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelThumbsUpMotion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cancelThumbsUpMotion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CancelThumbsUpMotion(rctx, fc.Args["userId"].(*string), fc.Args["motionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cancelThumbsUpMotion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelThumbsUpMotion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_thumbsUpMotions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_thumbsUpMotions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ThumbsUpMotions(rctx, fc.Args["userId"].(*string), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.UserThumbsUpMotion)
	fc.Result = res
	return ec.marshalNUserThumbsUpMotion2whalepkgmodelsUserThumbsUpMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_thumbsUpMotions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userId":
				return ec.fieldContext_UserThumbsUpMotion_userId(ctx, field)
			case "toMotionId":
				return ec.fieldContext_UserThumbsUpMotion_toMotionId(ctx, field)
			case "createdAt":
				return ec.fieldContext_UserThumbsUpMotion_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserThumbsUpMotion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_thumbsUpMotions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_thumbsUpMotionsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_thumbsUpMotionsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ThumbsUpMotionsCount(rctx, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2whalepkgmodelsSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_thumbsUpMotionsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_thumbsUpMotionsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_chatGroupByResultId(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_chatGroupByResultId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ChatGroupByResultID(rctx, fc.Args["resultId"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.ChatGroup)
	fc.Result = res
	return ec.marshalNChatGroup2whalepkgmodelsChatGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_chatGroupByResultId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ChatGroup_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChatGroup", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_chatGroupByResultId_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userDurationConstraint(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userDurationConstraint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserDurationConstraint(rctx, fc.Args["userId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.DurationConstraint)
	fc.Result = res
	return ec.marshalNDurationConstraint2whalepkgmodelsDurationConstraint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userDurationConstraint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userId":
				return ec.fieldContext_DurationConstraint_userId(ctx, field)
			case "startDate":
				return ec.fieldContext_DurationConstraint_startDate(ctx, field)
			case "stopDate":
				return ec.fieldContext_DurationConstraint_stopDate(ctx, field)
			case "totalMotionQuota":
				return ec.fieldContext_DurationConstraint_totalMotionQuota(ctx, field)
			case "remainMotionQuota":
				return ec.fieldContext_DurationConstraint_remainMotionQuota(ctx, field)
			case "updatedAt":
				return ec.fieldContext_DurationConstraint_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DurationConstraint", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userDurationConstraint_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_yesterdayMatchingCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_yesterdayMatchingCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().YesterdayMatchingCount(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_yesterdayMatchingCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_motionSummary(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_motionSummary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MotionSummary(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_motionSummary(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_matchingInvitations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_matchingInvitations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MatchingInvitations(rctx, fc.Args["filter"].(*models.MatchingInvitationFilter), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.MatchingInvitation)
	fc.Result = res
	return ec.marshalNMatchingInvitation2whalepkgmodelsMatchingInvitation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_matchingInvitations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingInvitation_id(ctx, field)
			case "userId":
				return ec.fieldContext_MatchingInvitation_userId(ctx, field)
			case "inviteeId":
				return ec.fieldContext_MatchingInvitation_inviteeId(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingInvitation_topicId(ctx, field)
			case "remark":
				return ec.fieldContext_MatchingInvitation_remark(ctx, field)
			case "cityId":
				return ec.fieldContext_MatchingInvitation_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_MatchingInvitation_areaIds(ctx, field)
			case "matchingResultId":
				return ec.fieldContext_MatchingInvitation_matchingResultId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingInvitation_matchingIds(ctx, field)
			case "confirmState":
				return ec.fieldContext_MatchingInvitation_confirmState(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_MatchingInvitation_confirmedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingInvitation_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingInvitation_updatedAt(ctx, field)
			case "invitee":
				return ec.fieldContext_MatchingInvitation_invitee(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingInvitation_topic(ctx, field)
			case "areas":
				return ec.fieldContext_MatchingInvitation_areas(ctx, field)
			case "city":
				return ec.fieldContext_MatchingInvitation_city(ctx, field)
			case "user":
				return ec.fieldContext_MatchingInvitation_user(ctx, field)
			case "matchingResult":
				return ec.fieldContext_MatchingInvitation_matchingResult(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingInvitation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_matchingInvitations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_matchingInvitationsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_matchingInvitationsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MatchingInvitationsCount(rctx, fc.Args["filter"].(*models.MatchingInvitationFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2whalepkgmodelsSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_matchingInvitationsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_matchingInvitationsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_invitations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_invitations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Invitations(rctx, fc.Args["userId"].(*string), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.MatchingInvitation)
	fc.Result = res
	return ec.marshalNMatchingInvitation2whalepkgmodelsMatchingInvitation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_invitations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingInvitation_id(ctx, field)
			case "userId":
				return ec.fieldContext_MatchingInvitation_userId(ctx, field)
			case "inviteeId":
				return ec.fieldContext_MatchingInvitation_inviteeId(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingInvitation_topicId(ctx, field)
			case "remark":
				return ec.fieldContext_MatchingInvitation_remark(ctx, field)
			case "cityId":
				return ec.fieldContext_MatchingInvitation_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_MatchingInvitation_areaIds(ctx, field)
			case "matchingResultId":
				return ec.fieldContext_MatchingInvitation_matchingResultId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingInvitation_matchingIds(ctx, field)
			case "confirmState":
				return ec.fieldContext_MatchingInvitation_confirmState(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_MatchingInvitation_confirmedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingInvitation_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingInvitation_updatedAt(ctx, field)
			case "invitee":
				return ec.fieldContext_MatchingInvitation_invitee(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingInvitation_topic(ctx, field)
			case "areas":
				return ec.fieldContext_MatchingInvitation_areas(ctx, field)
			case "city":
				return ec.fieldContext_MatchingInvitation_city(ctx, field)
			case "user":
				return ec.fieldContext_MatchingInvitation_user(ctx, field)
			case "matchingResult":
				return ec.fieldContext_MatchingInvitation_matchingResult(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingInvitation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_invitations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_invitation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_invitation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Invitation(rctx, fc.Args["userId"].(*string), fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.MatchingInvitation)
	fc.Result = res
	return ec.marshalNMatchingInvitation2whalepkgmodelsMatchingInvitation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_invitation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingInvitation_id(ctx, field)
			case "userId":
				return ec.fieldContext_MatchingInvitation_userId(ctx, field)
			case "inviteeId":
				return ec.fieldContext_MatchingInvitation_inviteeId(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingInvitation_topicId(ctx, field)
			case "remark":
				return ec.fieldContext_MatchingInvitation_remark(ctx, field)
			case "cityId":
				return ec.fieldContext_MatchingInvitation_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_MatchingInvitation_areaIds(ctx, field)
			case "matchingResultId":
				return ec.fieldContext_MatchingInvitation_matchingResultId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingInvitation_matchingIds(ctx, field)
			case "confirmState":
				return ec.fieldContext_MatchingInvitation_confirmState(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_MatchingInvitation_confirmedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingInvitation_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingInvitation_updatedAt(ctx, field)
			case "invitee":
				return ec.fieldContext_MatchingInvitation_invitee(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingInvitation_topic(ctx, field)
			case "areas":
				return ec.fieldContext_MatchingInvitation_areas(ctx, field)
			case "city":
				return ec.fieldContext_MatchingInvitation_city(ctx, field)
			case "user":
				return ec.fieldContext_MatchingInvitation_user(ctx, field)
			case "matchingResult":
				return ec.fieldContext_MatchingInvitation_matchingResult(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingInvitation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_invitation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_invitationsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_invitationsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().InvitationsCount(rctx, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2whalepkgmodelsSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_invitationsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_invitationsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_matching(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_matching(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Matching(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Matching)
	fc.Result = res
	return ec.marshalNMatching2whalepkgmodelsMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_matching(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Matching_id(ctx, field)
			case "topicId":
				return ec.fieldContext_Matching_topicId(ctx, field)
			case "userId":
				return ec.fieldContext_Matching_userId(ctx, field)
			case "areaIds":
				return ec.fieldContext_Matching_areaIds(ctx, field)
			case "cityId":
				return ec.fieldContext_Matching_cityId(ctx, field)
			case "gender":
				return ec.fieldContext_Matching_gender(ctx, field)
			case "state":
				return ec.fieldContext_Matching_state(ctx, field)
			case "rejectedUserIds":
				return ec.fieldContext_Matching_rejectedUserIds(ctx, field)
			case "inChatGroup":
				return ec.fieldContext_Matching_inChatGroup(ctx, field)
			case "remark":
				return ec.fieldContext_Matching_remark(ctx, field)
			case "dayRange":
				return ec.fieldContext_Matching_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Matching_preferredPeriods(ctx, field)
			case "properties":
				return ec.fieldContext_Matching_properties(ctx, field)
			case "startMatchingAt":
				return ec.fieldContext_Matching_startMatchingAt(ctx, field)
			case "deadline":
				return ec.fieldContext_Matching_deadline(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Matching_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Matching_createdAt(ctx, field)
			case "matchingResult":
				return ec.fieldContext_Matching_matchingResult(ctx, field)
			case "reviewed":
				return ec.fieldContext_Matching_reviewed(ctx, field)
			case "user":
				return ec.fieldContext_Matching_user(ctx, field)
			case "topic":
				return ec.fieldContext_Matching_topic(ctx, field)
			case "areas":
				return ec.fieldContext_Matching_areas(ctx, field)
			case "city":
				return ec.fieldContext_Matching_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Matching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_matching_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userMatchingQuota(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userMatchingQuota(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserMatchingQuota(rctx, fc.Args["userId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.MatchingQuota)
	fc.Result = res
	return ec.marshalNMatchingQuota2whalepkgmodelsMatchingQuota(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userMatchingQuota(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userId":
				return ec.fieldContext_MatchingQuota_userId(ctx, field)
			case "remain":
				return ec.fieldContext_MatchingQuota_remain(ctx, field)
			case "total":
				return ec.fieldContext_MatchingQuota_total(ctx, field)
			case "matchingNum":
				return ec.fieldContext_MatchingQuota_matchingNum(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingQuota_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingQuota_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingQuota", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userMatchingQuota_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userMatchingCalendar(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userMatchingCalendar(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserMatchingCalendar(rctx, fc.Args["userId"].(*string), fc.Args["param"].(models.UserMatchingCalenderParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.CalendarEvent)
	fc.Result = res
	return ec.marshalNCalendarEvent2whalepkgmodelsCalendarEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userMatchingCalendar(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "topicId":
				return ec.fieldContext_CalendarEvent_topicId(ctx, field)
			case "matchedAt":
				return ec.fieldContext_CalendarEvent_matchedAt(ctx, field)
			case "finishedAt":
				return ec.fieldContext_CalendarEvent_finishedAt(ctx, field)
			case "chatGroupCreatedAt":
				return ec.fieldContext_CalendarEvent_chatGroupCreatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CalendarEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userMatchingCalendar_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userMatchingsInTheDay(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userMatchingsInTheDay(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserMatchingsInTheDay(rctx, fc.Args["userId"].(*string), fc.Args["param"].(models.UserMatchingInTheDayParam))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.MatchingResult)
	fc.Result = res
	return ec.marshalNMatchingResult2whalepkgmodelsMatchingResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userMatchingsInTheDay(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingResult_id(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingResult_matchingIds(ctx, field)
			case "motionIds":
				return ec.fieldContext_MatchingResult_motionIds(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingResult_topicId(ctx, field)
			case "userIds":
				return ec.fieldContext_MatchingResult_userIds(ctx, field)
			case "confirmStates":
				return ec.fieldContext_MatchingResult_confirmStates(ctx, field)
			case "userConfirmStates":
				return ec.fieldContext_MatchingResult_userConfirmStates(ctx, field)
			case "chatGroupId":
				return ec.fieldContext_MatchingResult_chatGroupId(ctx, field)
			case "chatGroupState":
				return ec.fieldContext_MatchingResult_chatGroupState(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingResult_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingResult_createdAt(ctx, field)
			case "matchingScore":
				return ec.fieldContext_MatchingResult_matchingScore(ctx, field)
			case "closed":
				return ec.fieldContext_MatchingResult_closed(ctx, field)
			case "finishedAt":
				return ec.fieldContext_MatchingResult_finishedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_MatchingResult_createdBy(ctx, field)
			case "users":
				return ec.fieldContext_MatchingResult_users(ctx, field)
			case "discoverMotion":
				return ec.fieldContext_MatchingResult_discoverMotion(ctx, field)
			case "matchingPreviews":
				return ec.fieldContext_MatchingResult_matchingPreviews(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingResult_topic(ctx, field)
			case "chatGroup":
				return ec.fieldContext_MatchingResult_chatGroup(ctx, field)
			case "matchingDegree":
				return ec.fieldContext_MatchingResult_matchingDegree(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userMatchingsInTheDay_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_matchingResultByChatGroupId(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_matchingResultByChatGroupId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MatchingResultByChatGroupID(rctx, fc.Args["userId"].(*string), fc.Args["chatGroupId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.MatchingResult)
	fc.Result = res
	return ec.marshalNMatchingResult2whalepkgmodelsMatchingResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_matchingResultByChatGroupId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingResult_id(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingResult_matchingIds(ctx, field)
			case "motionIds":
				return ec.fieldContext_MatchingResult_motionIds(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingResult_topicId(ctx, field)
			case "userIds":
				return ec.fieldContext_MatchingResult_userIds(ctx, field)
			case "confirmStates":
				return ec.fieldContext_MatchingResult_confirmStates(ctx, field)
			case "userConfirmStates":
				return ec.fieldContext_MatchingResult_userConfirmStates(ctx, field)
			case "chatGroupId":
				return ec.fieldContext_MatchingResult_chatGroupId(ctx, field)
			case "chatGroupState":
				return ec.fieldContext_MatchingResult_chatGroupState(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingResult_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingResult_createdAt(ctx, field)
			case "matchingScore":
				return ec.fieldContext_MatchingResult_matchingScore(ctx, field)
			case "closed":
				return ec.fieldContext_MatchingResult_closed(ctx, field)
			case "finishedAt":
				return ec.fieldContext_MatchingResult_finishedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_MatchingResult_createdBy(ctx, field)
			case "users":
				return ec.fieldContext_MatchingResult_users(ctx, field)
			case "discoverMotion":
				return ec.fieldContext_MatchingResult_discoverMotion(ctx, field)
			case "matchingPreviews":
				return ec.fieldContext_MatchingResult_matchingPreviews(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingResult_topic(ctx, field)
			case "chatGroup":
				return ec.fieldContext_MatchingResult_chatGroup(ctx, field)
			case "matchingDegree":
				return ec.fieldContext_MatchingResult_matchingDegree(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_matchingResultByChatGroupId_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_matchings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_matchings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Matchings(rctx, fc.Args["filter"].(*models.MatchingFilter), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Matching)
	fc.Result = res
	return ec.marshalNMatching2whalepkgmodelsMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_matchings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Matching_id(ctx, field)
			case "topicId":
				return ec.fieldContext_Matching_topicId(ctx, field)
			case "userId":
				return ec.fieldContext_Matching_userId(ctx, field)
			case "areaIds":
				return ec.fieldContext_Matching_areaIds(ctx, field)
			case "cityId":
				return ec.fieldContext_Matching_cityId(ctx, field)
			case "gender":
				return ec.fieldContext_Matching_gender(ctx, field)
			case "state":
				return ec.fieldContext_Matching_state(ctx, field)
			case "rejectedUserIds":
				return ec.fieldContext_Matching_rejectedUserIds(ctx, field)
			case "inChatGroup":
				return ec.fieldContext_Matching_inChatGroup(ctx, field)
			case "remark":
				return ec.fieldContext_Matching_remark(ctx, field)
			case "dayRange":
				return ec.fieldContext_Matching_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Matching_preferredPeriods(ctx, field)
			case "properties":
				return ec.fieldContext_Matching_properties(ctx, field)
			case "startMatchingAt":
				return ec.fieldContext_Matching_startMatchingAt(ctx, field)
			case "deadline":
				return ec.fieldContext_Matching_deadline(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Matching_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Matching_createdAt(ctx, field)
			case "matchingResult":
				return ec.fieldContext_Matching_matchingResult(ctx, field)
			case "reviewed":
				return ec.fieldContext_Matching_reviewed(ctx, field)
			case "user":
				return ec.fieldContext_Matching_user(ctx, field)
			case "topic":
				return ec.fieldContext_Matching_topic(ctx, field)
			case "areas":
				return ec.fieldContext_Matching_areas(ctx, field)
			case "city":
				return ec.fieldContext_Matching_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Matching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_matchings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_matchingsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_matchingsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MatchingsCount(rctx, fc.Args["filter"].(*models.MatchingFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2whalepkgmodelsSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_matchingsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_matchingsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_matchingResult(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_matchingResult(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MatchingResult(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.MatchingResult)
	fc.Result = res
	return ec.marshalNMatchingResult2whalepkgmodelsMatchingResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_matchingResult(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingResult_id(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingResult_matchingIds(ctx, field)
			case "motionIds":
				return ec.fieldContext_MatchingResult_motionIds(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingResult_topicId(ctx, field)
			case "userIds":
				return ec.fieldContext_MatchingResult_userIds(ctx, field)
			case "confirmStates":
				return ec.fieldContext_MatchingResult_confirmStates(ctx, field)
			case "userConfirmStates":
				return ec.fieldContext_MatchingResult_userConfirmStates(ctx, field)
			case "chatGroupId":
				return ec.fieldContext_MatchingResult_chatGroupId(ctx, field)
			case "chatGroupState":
				return ec.fieldContext_MatchingResult_chatGroupState(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingResult_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingResult_createdAt(ctx, field)
			case "matchingScore":
				return ec.fieldContext_MatchingResult_matchingScore(ctx, field)
			case "closed":
				return ec.fieldContext_MatchingResult_closed(ctx, field)
			case "finishedAt":
				return ec.fieldContext_MatchingResult_finishedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_MatchingResult_createdBy(ctx, field)
			case "users":
				return ec.fieldContext_MatchingResult_users(ctx, field)
			case "discoverMotion":
				return ec.fieldContext_MatchingResult_discoverMotion(ctx, field)
			case "matchingPreviews":
				return ec.fieldContext_MatchingResult_matchingPreviews(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingResult_topic(ctx, field)
			case "chatGroup":
				return ec.fieldContext_MatchingResult_chatGroup(ctx, field)
			case "matchingDegree":
				return ec.fieldContext_MatchingResult_matchingDegree(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_matchingResult_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_matchingResults(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_matchingResults(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MatchingResults(rctx, fc.Args["filter"].(*models.MatchingResultFilter), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.MatchingResult)
	fc.Result = res
	return ec.marshalNMatchingResult2whalepkgmodelsMatchingResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_matchingResults(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingResult_id(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingResult_matchingIds(ctx, field)
			case "motionIds":
				return ec.fieldContext_MatchingResult_motionIds(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingResult_topicId(ctx, field)
			case "userIds":
				return ec.fieldContext_MatchingResult_userIds(ctx, field)
			case "confirmStates":
				return ec.fieldContext_MatchingResult_confirmStates(ctx, field)
			case "userConfirmStates":
				return ec.fieldContext_MatchingResult_userConfirmStates(ctx, field)
			case "chatGroupId":
				return ec.fieldContext_MatchingResult_chatGroupId(ctx, field)
			case "chatGroupState":
				return ec.fieldContext_MatchingResult_chatGroupState(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingResult_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingResult_createdAt(ctx, field)
			case "matchingScore":
				return ec.fieldContext_MatchingResult_matchingScore(ctx, field)
			case "closed":
				return ec.fieldContext_MatchingResult_closed(ctx, field)
			case "finishedAt":
				return ec.fieldContext_MatchingResult_finishedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_MatchingResult_createdBy(ctx, field)
			case "users":
				return ec.fieldContext_MatchingResult_users(ctx, field)
			case "discoverMotion":
				return ec.fieldContext_MatchingResult_discoverMotion(ctx, field)
			case "matchingPreviews":
				return ec.fieldContext_MatchingResult_matchingPreviews(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingResult_topic(ctx, field)
			case "chatGroup":
				return ec.fieldContext_MatchingResult_chatGroup(ctx, field)
			case "matchingDegree":
				return ec.fieldContext_MatchingResult_matchingDegree(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_matchingResults_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_matchingResultsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_matchingResultsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MatchingResultsCount(rctx, fc.Args["filter"].(*models.MatchingResultFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2whalepkgmodelsSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_matchingResultsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_matchingResultsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userMatchings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userMatchings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserMatchings(rctx, fc.Args["userId"].(*string), fc.Args["filter"].(*models.UserMatchingFilter), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Matching)
	fc.Result = res
	return ec.marshalNMatching2whalepkgmodelsMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userMatchings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Matching_id(ctx, field)
			case "topicId":
				return ec.fieldContext_Matching_topicId(ctx, field)
			case "userId":
				return ec.fieldContext_Matching_userId(ctx, field)
			case "areaIds":
				return ec.fieldContext_Matching_areaIds(ctx, field)
			case "cityId":
				return ec.fieldContext_Matching_cityId(ctx, field)
			case "gender":
				return ec.fieldContext_Matching_gender(ctx, field)
			case "state":
				return ec.fieldContext_Matching_state(ctx, field)
			case "rejectedUserIds":
				return ec.fieldContext_Matching_rejectedUserIds(ctx, field)
			case "inChatGroup":
				return ec.fieldContext_Matching_inChatGroup(ctx, field)
			case "remark":
				return ec.fieldContext_Matching_remark(ctx, field)
			case "dayRange":
				return ec.fieldContext_Matching_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Matching_preferredPeriods(ctx, field)
			case "properties":
				return ec.fieldContext_Matching_properties(ctx, field)
			case "startMatchingAt":
				return ec.fieldContext_Matching_startMatchingAt(ctx, field)
			case "deadline":
				return ec.fieldContext_Matching_deadline(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Matching_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Matching_createdAt(ctx, field)
			case "matchingResult":
				return ec.fieldContext_Matching_matchingResult(ctx, field)
			case "reviewed":
				return ec.fieldContext_Matching_reviewed(ctx, field)
			case "user":
				return ec.fieldContext_Matching_user(ctx, field)
			case "topic":
				return ec.fieldContext_Matching_topic(ctx, field)
			case "areas":
				return ec.fieldContext_Matching_areas(ctx, field)
			case "city":
				return ec.fieldContext_Matching_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Matching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userMatchings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_unconfirmedUserMatchings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_unconfirmedUserMatchings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UnconfirmedUserMatchings(rctx, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Matching)
	fc.Result = res
	return ec.marshalNMatching2whalepkgmodelsMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_unconfirmedUserMatchings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Matching_id(ctx, field)
			case "topicId":
				return ec.fieldContext_Matching_topicId(ctx, field)
			case "userId":
				return ec.fieldContext_Matching_userId(ctx, field)
			case "areaIds":
				return ec.fieldContext_Matching_areaIds(ctx, field)
			case "cityId":
				return ec.fieldContext_Matching_cityId(ctx, field)
			case "gender":
				return ec.fieldContext_Matching_gender(ctx, field)
			case "state":
				return ec.fieldContext_Matching_state(ctx, field)
			case "rejectedUserIds":
				return ec.fieldContext_Matching_rejectedUserIds(ctx, field)
			case "inChatGroup":
				return ec.fieldContext_Matching_inChatGroup(ctx, field)
			case "remark":
				return ec.fieldContext_Matching_remark(ctx, field)
			case "dayRange":
				return ec.fieldContext_Matching_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Matching_preferredPeriods(ctx, field)
			case "properties":
				return ec.fieldContext_Matching_properties(ctx, field)
			case "startMatchingAt":
				return ec.fieldContext_Matching_startMatchingAt(ctx, field)
			case "deadline":
				return ec.fieldContext_Matching_deadline(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Matching_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Matching_createdAt(ctx, field)
			case "matchingResult":
				return ec.fieldContext_Matching_matchingResult(ctx, field)
			case "reviewed":
				return ec.fieldContext_Matching_reviewed(ctx, field)
			case "user":
				return ec.fieldContext_Matching_user(ctx, field)
			case "topic":
				return ec.fieldContext_Matching_topic(ctx, field)
			case "areas":
				return ec.fieldContext_Matching_areas(ctx, field)
			case "city":
				return ec.fieldContext_Matching_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Matching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_unconfirmedUserMatchings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userMatchingsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userMatchingsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserMatchingsCount(rctx, fc.Args["userId"].(*string), fc.Args["filter"].(*models.UserMatchingFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2whalepkgmodelsSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userMatchingsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userMatchingsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_previewMatchingsOfTopic(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_previewMatchingsOfTopic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PreviewMatchingsOfTopic(rctx, fc.Args["cityId"].(string), fc.Args["topicId"].(string), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Matching)
	fc.Result = res
	return ec.marshalNMatchingOfTopic2whalepkgmodelsMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_previewMatchingsOfTopic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userId":
				return ec.fieldContext_MatchingOfTopic_userId(ctx, field)
			case "gender":
				return ec.fieldContext_MatchingOfTopic_gender(ctx, field)
			case "remark":
				return ec.fieldContext_MatchingOfTopic_remark(ctx, field)
			case "areaIds":
				return ec.fieldContext_MatchingOfTopic_areaIds(ctx, field)
			case "cityId":
				return ec.fieldContext_MatchingOfTopic_cityId(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingOfTopic_createdAt(ctx, field)
			case "user":
				return ec.fieldContext_MatchingOfTopic_user(ctx, field)
			case "city":
				return ec.fieldContext_MatchingOfTopic_city(ctx, field)
			case "areas":
				return ec.fieldContext_MatchingOfTopic_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingOfTopic", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_previewMatchingsOfTopic_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_unconfirmedInvitations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_unconfirmedInvitations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UnconfirmedInvitations(rctx, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.MatchingInvitation)
	fc.Result = res
	return ec.marshalOMatchingInvitation2whalepkgmodelsMatchingInvitation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_unconfirmedInvitations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MatchingInvitation_id(ctx, field)
			case "userId":
				return ec.fieldContext_MatchingInvitation_userId(ctx, field)
			case "inviteeId":
				return ec.fieldContext_MatchingInvitation_inviteeId(ctx, field)
			case "topicId":
				return ec.fieldContext_MatchingInvitation_topicId(ctx, field)
			case "remark":
				return ec.fieldContext_MatchingInvitation_remark(ctx, field)
			case "cityId":
				return ec.fieldContext_MatchingInvitation_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_MatchingInvitation_areaIds(ctx, field)
			case "matchingResultId":
				return ec.fieldContext_MatchingInvitation_matchingResultId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_MatchingInvitation_matchingIds(ctx, field)
			case "confirmState":
				return ec.fieldContext_MatchingInvitation_confirmState(ctx, field)
			case "confirmedAt":
				return ec.fieldContext_MatchingInvitation_confirmedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingInvitation_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingInvitation_updatedAt(ctx, field)
			case "invitee":
				return ec.fieldContext_MatchingInvitation_invitee(ctx, field)
			case "topic":
				return ec.fieldContext_MatchingInvitation_topic(ctx, field)
			case "areas":
				return ec.fieldContext_MatchingInvitation_areas(ctx, field)
			case "city":
				return ec.fieldContext_MatchingInvitation_city(ctx, field)
			case "user":
				return ec.fieldContext_MatchingInvitation_user(ctx, field)
			case "matchingResult":
				return ec.fieldContext_MatchingInvitation_matchingResult(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingInvitation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_unconfirmedInvitations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_unconfirmedInvitationCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_unconfirmedInvitationCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UnconfirmedInvitationCount(rctx, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2whalepkgmodelsSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_unconfirmedInvitationCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_unconfirmedInvitationCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_recentMatchings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_recentMatchings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RecentMatchings(rctx, fc.Args["filter"].(*models.RecentMatchingFilter), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.RecentMatching)
	fc.Result = res
	return ec.marshalNRecentMatching2whalepkgmodelsRecentMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_recentMatchings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RecentMatching_id(ctx, field)
			case "cityId":
				return ec.fieldContext_RecentMatching_cityId(ctx, field)
			case "topicId":
				return ec.fieldContext_RecentMatching_topicId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_RecentMatching_matchingIds(ctx, field)
			case "createdAt":
				return ec.fieldContext_RecentMatching_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_RecentMatching_updatedAt(ctx, field)
			case "topic":
				return ec.fieldContext_RecentMatching_topic(ctx, field)
			case "city":
				return ec.fieldContext_RecentMatching_city(ctx, field)
			case "matchings":
				return ec.fieldContext_RecentMatching_matchings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RecentMatching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_recentMatchings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_recentMatchingsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_recentMatchingsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RecentMatchingsCount(rctx, fc.Args["filter"].(*models.RecentMatchingFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2whalepkgmodelsSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_recentMatchingsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_recentMatchingsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_recentMatching(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_recentMatching(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RecentMatching(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.RecentMatching)
	fc.Result = res
	return ec.marshalNRecentMatching2whalepkgmodelsRecentMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_recentMatching(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RecentMatching_id(ctx, field)
			case "cityId":
				return ec.fieldContext_RecentMatching_cityId(ctx, field)
			case "topicId":
				return ec.fieldContext_RecentMatching_topicId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_RecentMatching_matchingIds(ctx, field)
			case "createdAt":
				return ec.fieldContext_RecentMatching_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_RecentMatching_updatedAt(ctx, field)
			case "topic":
				return ec.fieldContext_RecentMatching_topic(ctx, field)
			case "city":
				return ec.fieldContext_RecentMatching_city(ctx, field)
			case "matchings":
				return ec.fieldContext_RecentMatching_matchings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RecentMatching", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_recentMatching_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_topicDistribution(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_topicDistribution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TopicDistribution(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.TopicToMatching)
	fc.Result = res
	return ec.marshalNTopicToMatching2whalepkgmodelsTopicToMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_topicDistribution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "topicId":
				return ec.fieldContext_TopicToMatching_topicId(ctx, field)
			case "matchingIds":
				return ec.fieldContext_TopicToMatching_matchingIds(ctx, field)
			case "topic":
				return ec.fieldContext_TopicToMatching_topic(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TopicToMatching", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_cityDistribution(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cityDistribution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CityDistribution(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.CityToTopicMatching)
	fc.Result = res
	return ec.marshalNCityToTopicMatching2whalepkgmodelsCityToTopicMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cityDistribution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cityId":
				return ec.fieldContext_CityToTopicMatching_cityId(ctx, field)
			case "topics":
				return ec.fieldContext_CityToTopicMatching_topics(ctx, field)
			case "city":
				return ec.fieldContext_CityToTopicMatching_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CityToTopicMatching", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_matchingDurationConstraints(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_matchingDurationConstraints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MatchingDurationConstraints(rctx, fc.Args["userId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.MatchingDurationConstraint)
	fc.Result = res
	return ec.marshalNMatchingDurationConstraint2whalepkgmodelsMatchingDurationConstraint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_matchingDurationConstraints(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startDate":
				return ec.fieldContext_MatchingDurationConstraint_startDate(ctx, field)
			case "stopDate":
				return ec.fieldContext_MatchingDurationConstraint_stopDate(ctx, field)
			case "total":
				return ec.fieldContext_MatchingDurationConstraint_total(ctx, field)
			case "remain":
				return ec.fieldContext_MatchingDurationConstraint_remain(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingDurationConstraint_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingDurationConstraint", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_matchingDurationConstraints_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_discoverCategoryMotions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_discoverCategoryMotions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DiscoverCategoryMotions(rctx, fc.Args["userId"].(*string), fc.Args["filter"].(*models.DiscoverTopicCategoryMotionFilter), fc.Args["topicCategoryId"].(string), fc.Args["nextToken"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.DiscoverMotionResult)
	fc.Result = res
	return ec.marshalNDiscoverMotionResult2whalepkgmodelsDiscoverMotionResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_discoverCategoryMotions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "motions":
				return ec.fieldContext_DiscoverMotionResult_motions(ctx, field)
			case "nextToken":
				return ec.fieldContext_DiscoverMotionResult_nextToken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscoverMotionResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_discoverCategoryMotions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_discoverLatestCategoryMotions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_discoverLatestCategoryMotions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DiscoverLatestCategoryMotions(rctx, fc.Args["filter"].(models.DiscoverTopicCategoryMotionFilter), fc.Args["topicCategoryId"].(string), fc.Args["lastId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Motion)
	fc.Result = res
	return ec.marshalNDiscoverMotion2whalepkgmodelsMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_discoverLatestCategoryMotions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscoverMotion_id(ctx, field)
			case "userId":
				return ec.fieldContext_DiscoverMotion_userId(ctx, field)
			case "topicId":
				return ec.fieldContext_DiscoverMotion_topicId(ctx, field)
			case "properties":
				return ec.fieldContext_DiscoverMotion_properties(ctx, field)
			case "cityId":
				return ec.fieldContext_DiscoverMotion_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_DiscoverMotion_areaIds(ctx, field)
			case "gender":
				return ec.fieldContext_DiscoverMotion_gender(ctx, field)
			case "dayRange":
				return ec.fieldContext_DiscoverMotion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_DiscoverMotion_preferredPeriods(ctx, field)
			case "remark":
				return ec.fieldContext_DiscoverMotion_remark(ctx, field)
			case "likeCount":
				return ec.fieldContext_DiscoverMotion_likeCount(ctx, field)
			case "viewCount":
				return ec.fieldContext_DiscoverMotion_viewCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_DiscoverMotion_thumbsUpCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_DiscoverMotion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_DiscoverMotion_liked(ctx, field)
			case "submitted":
				return ec.fieldContext_DiscoverMotion_submitted(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_DiscoverMotion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_DiscoverMotion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_DiscoverMotion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_DiscoverMotion_user(ctx, field)
			case "city":
				return ec.fieldContext_DiscoverMotion_city(ctx, field)
			case "areas":
				return ec.fieldContext_DiscoverMotion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscoverMotion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_discoverLatestCategoryMotions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getDiscoverMotion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getDiscoverMotion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetDiscoverMotion(rctx, fc.Args["motionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Motion)
	fc.Result = res
	return ec.marshalNDiscoverMotion2whalepkgmodelsMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getDiscoverMotion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscoverMotion_id(ctx, field)
			case "userId":
				return ec.fieldContext_DiscoverMotion_userId(ctx, field)
			case "topicId":
				return ec.fieldContext_DiscoverMotion_topicId(ctx, field)
			case "properties":
				return ec.fieldContext_DiscoverMotion_properties(ctx, field)
			case "cityId":
				return ec.fieldContext_DiscoverMotion_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_DiscoverMotion_areaIds(ctx, field)
			case "gender":
				return ec.fieldContext_DiscoverMotion_gender(ctx, field)
			case "dayRange":
				return ec.fieldContext_DiscoverMotion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_DiscoverMotion_preferredPeriods(ctx, field)
			case "remark":
				return ec.fieldContext_DiscoverMotion_remark(ctx, field)
			case "likeCount":
				return ec.fieldContext_DiscoverMotion_likeCount(ctx, field)
			case "viewCount":
				return ec.fieldContext_DiscoverMotion_viewCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_DiscoverMotion_thumbsUpCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_DiscoverMotion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_DiscoverMotion_liked(ctx, field)
			case "submitted":
				return ec.fieldContext_DiscoverMotion_submitted(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_DiscoverMotion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_DiscoverMotion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_DiscoverMotion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_DiscoverMotion_user(ctx, field)
			case "city":
				return ec.fieldContext_DiscoverMotion_city(ctx, field)
			case "areas":
				return ec.fieldContext_DiscoverMotion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscoverMotion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getDiscoverMotion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_outMotionOffers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_outMotionOffers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().OutMotionOffers(rctx, fc.Args["motionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.MotionOfferRecord)
	fc.Result = res
	return ec.marshalNMotionOfferRecord2whalepkgmodelsMotionOfferRecord(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_outMotionOffers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MotionOfferRecord_id(ctx, field)
			case "toMotionId":
				return ec.fieldContext_MotionOfferRecord_toMotionId(ctx, field)
			case "motionId":
				return ec.fieldContext_MotionOfferRecord_motionId(ctx, field)
			case "state":
				return ec.fieldContext_MotionOfferRecord_state(ctx, field)
			case "createdAt":
				return ec.fieldContext_MotionOfferRecord_createdAt(ctx, field)
			case "reactAt":
				return ec.fieldContext_MotionOfferRecord_reactAt(ctx, field)
			case "remark":
				return ec.fieldContext_MotionOfferRecord_remark(ctx, field)
			case "chatChance":
				return ec.fieldContext_MotionOfferRecord_chatChance(ctx, field)
			case "reviewed":
				return ec.fieldContext_MotionOfferRecord_reviewed(ctx, field)
			case "toMotion":
				return ec.fieldContext_MotionOfferRecord_toMotion(ctx, field)
			case "motion":
				return ec.fieldContext_MotionOfferRecord_motion(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MotionOfferRecord", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_outMotionOffers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_inMotionOffers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_inMotionOffers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().InMotionOffers(rctx, fc.Args["motionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.MotionOfferRecord)
	fc.Result = res
	return ec.marshalNMotionOfferRecord2whalepkgmodelsMotionOfferRecord(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_inMotionOffers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MotionOfferRecord_id(ctx, field)
			case "toMotionId":
				return ec.fieldContext_MotionOfferRecord_toMotionId(ctx, field)
			case "motionId":
				return ec.fieldContext_MotionOfferRecord_motionId(ctx, field)
			case "state":
				return ec.fieldContext_MotionOfferRecord_state(ctx, field)
			case "createdAt":
				return ec.fieldContext_MotionOfferRecord_createdAt(ctx, field)
			case "reactAt":
				return ec.fieldContext_MotionOfferRecord_reactAt(ctx, field)
			case "remark":
				return ec.fieldContext_MotionOfferRecord_remark(ctx, field)
			case "chatChance":
				return ec.fieldContext_MotionOfferRecord_chatChance(ctx, field)
			case "reviewed":
				return ec.fieldContext_MotionOfferRecord_reviewed(ctx, field)
			case "toMotion":
				return ec.fieldContext_MotionOfferRecord_toMotion(ctx, field)
			case "motion":
				return ec.fieldContext_MotionOfferRecord_motion(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MotionOfferRecord", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_inMotionOffers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMotionOffer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMotionOffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMotionOffer(rctx, fc.Args["motionId"].(string), fc.Args["toMotionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.MotionOfferRecord)
	fc.Result = res
	return ec.marshalNMotionOfferRecord2whalepkgmodelsMotionOfferRecord(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMotionOffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MotionOfferRecord_id(ctx, field)
			case "toMotionId":
				return ec.fieldContext_MotionOfferRecord_toMotionId(ctx, field)
			case "motionId":
				return ec.fieldContext_MotionOfferRecord_motionId(ctx, field)
			case "state":
				return ec.fieldContext_MotionOfferRecord_state(ctx, field)
			case "createdAt":
				return ec.fieldContext_MotionOfferRecord_createdAt(ctx, field)
			case "reactAt":
				return ec.fieldContext_MotionOfferRecord_reactAt(ctx, field)
			case "remark":
				return ec.fieldContext_MotionOfferRecord_remark(ctx, field)
			case "chatChance":
				return ec.fieldContext_MotionOfferRecord_chatChance(ctx, field)
			case "reviewed":
				return ec.fieldContext_MotionOfferRecord_reviewed(ctx, field)
			case "toMotion":
				return ec.fieldContext_MotionOfferRecord_toMotion(ctx, field)
			case "motion":
				return ec.fieldContext_MotionOfferRecord_motion(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MotionOfferRecord", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMotionOffer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_motion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_motion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Motion(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Motion)
	fc.Result = res
	return ec.marshalNMotion2whalepkgmodelsMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_motion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Motion_id(ctx, field)
			case "userId":
				return ec.fieldContext_Motion_userId(ctx, field)
			case "cityId":
				return ec.fieldContext_Motion_cityId(ctx, field)
			case "remark":
				return ec.fieldContext_Motion_remark(ctx, field)
			case "active":
				return ec.fieldContext_Motion_active(ctx, field)
			case "inOfferNum":
				return ec.fieldContext_Motion_inOfferNum(ctx, field)
			case "outOfferNum":
				return ec.fieldContext_Motion_outOfferNum(ctx, field)
			case "pendingInNum":
				return ec.fieldContext_Motion_pendingInNum(ctx, field)
			case "pendingOutNum":
				return ec.fieldContext_Motion_pendingOutNum(ctx, field)
			case "activeNum":
				return ec.fieldContext_Motion_activeNum(ctx, field)
			case "discoverable":
				return ec.fieldContext_Motion_discoverable(ctx, field)
			case "relatedMatchingId":
				return ec.fieldContext_Motion_relatedMatchingId(ctx, field)
			case "properties":
				return ec.fieldContext_Motion_properties(ctx, field)
			case "dayRange":
				return ec.fieldContext_Motion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Motion_preferredPeriods(ctx, field)
			case "gender":
				return ec.fieldContext_Motion_gender(ctx, field)
			case "createdAt":
				return ec.fieldContext_Motion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_Motion_liked(ctx, field)
			case "viewCount":
				return ec.fieldContext_Motion_viewCount(ctx, field)
			case "likeCount":
				return ec.fieldContext_Motion_likeCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_Motion_thumbsUpCount(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_Motion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_Motion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_Motion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_Motion_user(ctx, field)
			case "city":
				return ec.fieldContext_Motion_city(ctx, field)
			case "areas":
				return ec.fieldContext_Motion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Motion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_motion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userMotions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userMotions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserMotions(rctx, fc.Args["userId"].(*string), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Motion)
	fc.Result = res
	return ec.marshalNMotion2whalepkgmodelsMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userMotions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Motion_id(ctx, field)
			case "userId":
				return ec.fieldContext_Motion_userId(ctx, field)
			case "cityId":
				return ec.fieldContext_Motion_cityId(ctx, field)
			case "remark":
				return ec.fieldContext_Motion_remark(ctx, field)
			case "active":
				return ec.fieldContext_Motion_active(ctx, field)
			case "inOfferNum":
				return ec.fieldContext_Motion_inOfferNum(ctx, field)
			case "outOfferNum":
				return ec.fieldContext_Motion_outOfferNum(ctx, field)
			case "pendingInNum":
				return ec.fieldContext_Motion_pendingInNum(ctx, field)
			case "pendingOutNum":
				return ec.fieldContext_Motion_pendingOutNum(ctx, field)
			case "activeNum":
				return ec.fieldContext_Motion_activeNum(ctx, field)
			case "discoverable":
				return ec.fieldContext_Motion_discoverable(ctx, field)
			case "relatedMatchingId":
				return ec.fieldContext_Motion_relatedMatchingId(ctx, field)
			case "properties":
				return ec.fieldContext_Motion_properties(ctx, field)
			case "dayRange":
				return ec.fieldContext_Motion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Motion_preferredPeriods(ctx, field)
			case "gender":
				return ec.fieldContext_Motion_gender(ctx, field)
			case "createdAt":
				return ec.fieldContext_Motion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_Motion_liked(ctx, field)
			case "viewCount":
				return ec.fieldContext_Motion_viewCount(ctx, field)
			case "likeCount":
				return ec.fieldContext_Motion_likeCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_Motion_thumbsUpCount(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_Motion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_Motion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_Motion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_Motion_user(ctx, field)
			case "city":
				return ec.fieldContext_Motion_city(ctx, field)
			case "areas":
				return ec.fieldContext_Motion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Motion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userMotions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userMotionsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userMotionsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserMotionsCount(rctx, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2whalepkgmodelsSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userMotionsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userMotionsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_activeMotions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_activeMotions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ActiveMotions(rctx, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Motion)
	fc.Result = res
	return ec.marshalNMotion2whalepkgmodelsMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_activeMotions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Motion_id(ctx, field)
			case "userId":
				return ec.fieldContext_Motion_userId(ctx, field)
			case "cityId":
				return ec.fieldContext_Motion_cityId(ctx, field)
			case "remark":
				return ec.fieldContext_Motion_remark(ctx, field)
			case "active":
				return ec.fieldContext_Motion_active(ctx, field)
			case "inOfferNum":
				return ec.fieldContext_Motion_inOfferNum(ctx, field)
			case "outOfferNum":
				return ec.fieldContext_Motion_outOfferNum(ctx, field)
			case "pendingInNum":
				return ec.fieldContext_Motion_pendingInNum(ctx, field)
			case "pendingOutNum":
				return ec.fieldContext_Motion_pendingOutNum(ctx, field)
			case "activeNum":
				return ec.fieldContext_Motion_activeNum(ctx, field)
			case "discoverable":
				return ec.fieldContext_Motion_discoverable(ctx, field)
			case "relatedMatchingId":
				return ec.fieldContext_Motion_relatedMatchingId(ctx, field)
			case "properties":
				return ec.fieldContext_Motion_properties(ctx, field)
			case "dayRange":
				return ec.fieldContext_Motion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Motion_preferredPeriods(ctx, field)
			case "gender":
				return ec.fieldContext_Motion_gender(ctx, field)
			case "createdAt":
				return ec.fieldContext_Motion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_Motion_liked(ctx, field)
			case "viewCount":
				return ec.fieldContext_Motion_viewCount(ctx, field)
			case "likeCount":
				return ec.fieldContext_Motion_likeCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_Motion_thumbsUpCount(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_Motion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_Motion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_Motion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_Motion_user(ctx, field)
			case "city":
				return ec.fieldContext_Motion_city(ctx, field)
			case "areas":
				return ec.fieldContext_Motion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Motion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_activeMotions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_motions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_motions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Motions(rctx, fc.Args["filter"].(*models.MotionFilter), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Motion)
	fc.Result = res
	return ec.marshalNMotion2whalepkgmodelsMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_motions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Motion_id(ctx, field)
			case "userId":
				return ec.fieldContext_Motion_userId(ctx, field)
			case "cityId":
				return ec.fieldContext_Motion_cityId(ctx, field)
			case "remark":
				return ec.fieldContext_Motion_remark(ctx, field)
			case "active":
				return ec.fieldContext_Motion_active(ctx, field)
			case "inOfferNum":
				return ec.fieldContext_Motion_inOfferNum(ctx, field)
			case "outOfferNum":
				return ec.fieldContext_Motion_outOfferNum(ctx, field)
			case "pendingInNum":
				return ec.fieldContext_Motion_pendingInNum(ctx, field)
			case "pendingOutNum":
				return ec.fieldContext_Motion_pendingOutNum(ctx, field)
			case "activeNum":
				return ec.fieldContext_Motion_activeNum(ctx, field)
			case "discoverable":
				return ec.fieldContext_Motion_discoverable(ctx, field)
			case "relatedMatchingId":
				return ec.fieldContext_Motion_relatedMatchingId(ctx, field)
			case "properties":
				return ec.fieldContext_Motion_properties(ctx, field)
			case "dayRange":
				return ec.fieldContext_Motion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Motion_preferredPeriods(ctx, field)
			case "gender":
				return ec.fieldContext_Motion_gender(ctx, field)
			case "createdAt":
				return ec.fieldContext_Motion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_Motion_liked(ctx, field)
			case "viewCount":
				return ec.fieldContext_Motion_viewCount(ctx, field)
			case "likeCount":
				return ec.fieldContext_Motion_likeCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_Motion_thumbsUpCount(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_Motion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_Motion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_Motion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_Motion_user(ctx, field)
			case "city":
				return ec.fieldContext_Motion_city(ctx, field)
			case "areas":
				return ec.fieldContext_Motion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Motion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_motions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_motionsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_motionsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MotionsCount(rctx, fc.Args["filter"].(*models.MotionFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2whalepkgmodelsSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_motionsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_motionsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_cityTopics(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cityTopics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CityTopics(rctx, fc.Args["cityId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.CityTopics)
	fc.Result = res
	return ec.marshalNCityTopics2whalepkgmodelsCityTopics(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cityTopics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cityId":
				return ec.fieldContext_CityTopics_cityId(ctx, field)
			case "topicIds":
				return ec.fieldContext_CityTopics_topicIds(ctx, field)
			case "updatedAt":
				return ec.fieldContext_CityTopics_updatedAt(ctx, field)
			case "topics":
				return ec.fieldContext_CityTopics_topics(ctx, field)
			case "city":
				return ec.fieldContext_CityTopics_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CityTopics", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cityTopics_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_citiesTopics(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_citiesTopics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CitiesTopics(rctx, fc.Args["filter"].(*models.CitiesTopicsFilter), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.CityTopics)
	fc.Result = res
	return ec.marshalNCityTopics2whalepkgmodelsCityTopics(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_citiesTopics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cityId":
				return ec.fieldContext_CityTopics_cityId(ctx, field)
			case "topicIds":
				return ec.fieldContext_CityTopics_topicIds(ctx, field)
			case "updatedAt":
				return ec.fieldContext_CityTopics_updatedAt(ctx, field)
			case "topics":
				return ec.fieldContext_CityTopics_topics(ctx, field)
			case "city":
				return ec.fieldContext_CityTopics_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CityTopics", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_citiesTopics_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_citiesTopicsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_citiesTopicsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CitiesTopicsCount(rctx, fc.Args["filter"].(*models.CitiesTopicsFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2whalepkgmodelsSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_citiesTopicsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_citiesTopicsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_hotTopicsInArea(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_hotTopicsInArea(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().HotTopicsInArea(rctx, fc.Args["cityId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.HotTopicsInArea)
	fc.Result = res
	return ec.marshalNHotTopicsInArea2whalepkgmodelsHotTopicsInArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_hotTopicsInArea(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cityId":
				return ec.fieldContext_HotTopicsInArea_cityId(ctx, field)
			case "updatedAt":
				return ec.fieldContext_HotTopicsInArea_updatedAt(ctx, field)
			case "topicMetrics":
				return ec.fieldContext_HotTopicsInArea_topicMetrics(ctx, field)
			case "city":
				return ec.fieldContext_HotTopicsInArea_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HotTopicsInArea", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_hotTopicsInArea_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_hotTopics(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_hotTopics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().HotTopics(rctx, fc.Args["filter"].(*models.HotTopicsFilter), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.HotTopicsInArea)
	fc.Result = res
	return ec.marshalNHotTopicsInArea2whalepkgmodelsHotTopicsInArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_hotTopics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cityId":
				return ec.fieldContext_HotTopicsInArea_cityId(ctx, field)
			case "updatedAt":
				return ec.fieldContext_HotTopicsInArea_updatedAt(ctx, field)
			case "topicMetrics":
				return ec.fieldContext_HotTopicsInArea_topicMetrics(ctx, field)
			case "city":
				return ec.fieldContext_HotTopicsInArea_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HotTopicsInArea", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_hotTopics_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_hotTopicsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_hotTopicsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().HotTopicsCount(rctx, fc.Args["filter"].(*models.HotTopicsFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2whalepkgmodelsSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_hotTopicsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_hotTopicsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userJoinTopics(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userJoinTopics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserJoinTopics(rctx, fc.Args["filter"].(*models.UserJoinTopicFilter), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.UserJoinTopic)
	fc.Result = res
	return ec.marshalNUserJoinTopic2whalepkgmodelsUserJoinTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userJoinTopics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserJoinTopic_id(ctx, field)
			case "topicId":
				return ec.fieldContext_UserJoinTopic_topicId(ctx, field)
			case "cityId":
				return ec.fieldContext_UserJoinTopic_cityId(ctx, field)
			case "userId":
				return ec.fieldContext_UserJoinTopic_userId(ctx, field)
			case "latestMatchingId":
				return ec.fieldContext_UserJoinTopic_latestMatchingId(ctx, field)
			case "createdAt":
				return ec.fieldContext_UserJoinTopic_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_UserJoinTopic_updatedAt(ctx, field)
			case "topic":
				return ec.fieldContext_UserJoinTopic_topic(ctx, field)
			case "city":
				return ec.fieldContext_UserJoinTopic_city(ctx, field)
			case "user":
				return ec.fieldContext_UserJoinTopic_user(ctx, field)
			case "matching":
				return ec.fieldContext_UserJoinTopic_matching(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserJoinTopic", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userJoinTopics_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userJoinTopicsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userJoinTopicsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserJoinTopicsCount(rctx, fc.Args["filter"].(*models.UserJoinTopicFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2whalepkgmodelsSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userJoinTopicsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userJoinTopicsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userJoinTopic(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userJoinTopic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserJoinTopic(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.UserJoinTopic)
	fc.Result = res
	return ec.marshalNUserJoinTopic2whalepkgmodelsUserJoinTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userJoinTopic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserJoinTopic_id(ctx, field)
			case "topicId":
				return ec.fieldContext_UserJoinTopic_topicId(ctx, field)
			case "cityId":
				return ec.fieldContext_UserJoinTopic_cityId(ctx, field)
			case "userId":
				return ec.fieldContext_UserJoinTopic_userId(ctx, field)
			case "latestMatchingId":
				return ec.fieldContext_UserJoinTopic_latestMatchingId(ctx, field)
			case "createdAt":
				return ec.fieldContext_UserJoinTopic_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_UserJoinTopic_updatedAt(ctx, field)
			case "topic":
				return ec.fieldContext_UserJoinTopic_topic(ctx, field)
			case "city":
				return ec.fieldContext_UserJoinTopic_city(ctx, field)
			case "user":
				return ec.fieldContext_UserJoinTopic_user(ctx, field)
			case "matching":
				return ec.fieldContext_UserJoinTopic_matching(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserJoinTopic", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userJoinTopic_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_likedMotions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_likedMotions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().LikedMotions(rctx, fc.Args["userId"].(*string), fc.Args["paginator"].(*graphqlutil.GraphQLPaginator))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.UserLikeMotion)
	fc.Result = res
	return ec.marshalNUserLikeMotion2whalepkgmodelsUserLikeMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_likedMotions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "toMotionId":
				return ec.fieldContext_UserLikeMotion_toMotionId(ctx, field)
			case "toUserId":
				return ec.fieldContext_UserLikeMotion_toUserId(ctx, field)
			case "userId":
				return ec.fieldContext_UserLikeMotion_userId(ctx, field)
			case "createdAt":
				return ec.fieldContext_UserLikeMotion_createdAt(ctx, field)
			case "motion":
				return ec.fieldContext_UserLikeMotion_motion(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserLikeMotion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_likedMotions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_likedMotionsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_likedMotionsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().LikedMotionsCount(rctx, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Summary)
	fc.Result = res
	return ec.marshalNSummary2whalepkgmodelsSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_likedMotionsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_Summary_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Summary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_likedMotionsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query__entities(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query__entities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.__resolve_entities(ctx, fc.Args["representations"].([]map[string]interface{})), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]fedruntime.Entity)
	fc.Result = res
	return ec.marshalN_Entity2githubcom99designsgqlgenpluginfederationfedruntimeEntity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query__entities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type _Entity does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query__entities_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query__service(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query__service(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.__resolve__service(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(fedruntime.Service)
	fc.Result = res
	return ec.marshalN_Service2githubcom99designsgqlgenpluginfederationfedruntimeService(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query__service(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sdl":
				return ec.fieldContext__Service_sdl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type _Service", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecentMatching_id(ctx context.Context, field graphql.CollectedField, obj *models.RecentMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecentMatching_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecentMatching_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecentMatching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecentMatching_cityId(ctx context.Context, field graphql.CollectedField, obj *models.RecentMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecentMatching_cityId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecentMatching_cityId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecentMatching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecentMatching_topicId(ctx context.Context, field graphql.CollectedField, obj *models.RecentMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecentMatching_topicId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecentMatching_topicId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecentMatching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecentMatching_matchingIds(ctx context.Context, field graphql.CollectedField, obj *models.RecentMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecentMatching_matchingIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchingIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecentMatching_matchingIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecentMatching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecentMatching_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.RecentMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecentMatching_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecentMatching_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecentMatching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecentMatching_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.RecentMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecentMatching_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecentMatching_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecentMatching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecentMatching_topic(ctx context.Context, field graphql.CollectedField, obj *models.RecentMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecentMatching_topic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RecentMatching().Topic(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Topic)
	fc.Result = res
	return ec.marshalNTopic2whalepkgmodelsTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecentMatching_topic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecentMatching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Topic_id(ctx, field)
			case "recentUsers":
				return ec.fieldContext_Topic_recentUsers(ctx, field)
			case "matchingNum":
				return ec.fieldContext_Topic_matchingNum(ctx, field)
			case "fuzzyMatchingNum":
				return ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Topic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecentMatching_city(ctx context.Context, field graphql.CollectedField, obj *models.RecentMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecentMatching_city(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RecentMatching().City(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Area)
	fc.Result = res
	return ec.marshalNArea2whalepkgmodelsArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecentMatching_city(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecentMatching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecentMatching_matchings(ctx context.Context, field graphql.CollectedField, obj *models.RecentMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecentMatching_matchings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RecentMatching().Matchings(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Matching)
	fc.Result = res
	return ec.marshalNMatching2whalepkgmodelsMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecentMatching_matchings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecentMatching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Matching_id(ctx, field)
			case "topicId":
				return ec.fieldContext_Matching_topicId(ctx, field)
			case "userId":
				return ec.fieldContext_Matching_userId(ctx, field)
			case "areaIds":
				return ec.fieldContext_Matching_areaIds(ctx, field)
			case "cityId":
				return ec.fieldContext_Matching_cityId(ctx, field)
			case "gender":
				return ec.fieldContext_Matching_gender(ctx, field)
			case "state":
				return ec.fieldContext_Matching_state(ctx, field)
			case "rejectedUserIds":
				return ec.fieldContext_Matching_rejectedUserIds(ctx, field)
			case "inChatGroup":
				return ec.fieldContext_Matching_inChatGroup(ctx, field)
			case "remark":
				return ec.fieldContext_Matching_remark(ctx, field)
			case "dayRange":
				return ec.fieldContext_Matching_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Matching_preferredPeriods(ctx, field)
			case "properties":
				return ec.fieldContext_Matching_properties(ctx, field)
			case "startMatchingAt":
				return ec.fieldContext_Matching_startMatchingAt(ctx, field)
			case "deadline":
				return ec.fieldContext_Matching_deadline(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Matching_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Matching_createdAt(ctx, field)
			case "matchingResult":
				return ec.fieldContext_Matching_matchingResult(ctx, field)
			case "reviewed":
				return ec.fieldContext_Matching_reviewed(ctx, field)
			case "user":
				return ec.fieldContext_Matching_user(ctx, field)
			case "topic":
				return ec.fieldContext_Matching_topic(ctx, field)
			case "areas":
				return ec.fieldContext_Matching_areas(ctx, field)
			case "city":
				return ec.fieldContext_Matching_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Matching", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SimpleAvatarUser_avatar(ctx context.Context, field graphql.CollectedField, obj *models.SimpleAvatarUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SimpleAvatarUser_avatar(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avatar, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SimpleAvatarUser_avatar(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SimpleAvatarUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SimpleAvatarUser_nickname(ctx context.Context, field graphql.CollectedField, obj *models.SimpleAvatarUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SimpleAvatarUser_nickname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nickname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SimpleAvatarUser_nickname(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SimpleAvatarUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Summary_count(ctx context.Context, field graphql.CollectedField, obj *models.Summary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Summary_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Summary_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Summary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Topic_id(ctx context.Context, field graphql.CollectedField, obj *models.Topic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Topic_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Topic_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Topic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Topic_recentUsers(ctx context.Context, field graphql.CollectedField, obj *models.Topic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Topic_recentUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Topic().RecentUsers(rctx, obj, fc.Args["cityId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.SimpleAvatarUser)
	fc.Result = res
	return ec.marshalNSimpleAvatarUser2whalepkgmodelsSimpleAvatarUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Topic_recentUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Topic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "avatar":
				return ec.fieldContext_SimpleAvatarUser_avatar(ctx, field)
			case "nickname":
				return ec.fieldContext_SimpleAvatarUser_nickname(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SimpleAvatarUser", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Topic_recentUsers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Topic_matchingNum(ctx context.Context, field graphql.CollectedField, obj *models.Topic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Topic_matchingNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Topic().MatchingNum(rctx, obj, fc.Args["cityId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Topic_matchingNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Topic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Topic_matchingNum_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Topic_fuzzyMatchingNum(ctx context.Context, field graphql.CollectedField, obj *models.Topic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Topic().FuzzyMatchingNum(rctx, obj, fc.Args["cityId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Topic_fuzzyMatchingNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Topic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Topic_fuzzyMatchingNum_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TopicMetrics_id(ctx context.Context, field graphql.CollectedField, obj *models.TopicMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopicMetrics_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopicMetrics_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopicMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopicMetrics_matched(ctx context.Context, field graphql.CollectedField, obj *models.TopicMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopicMetrics_matched(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Matched, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopicMetrics_matched(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopicMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopicMetrics_matching(ctx context.Context, field graphql.CollectedField, obj *models.TopicMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopicMetrics_matching(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Matching, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopicMetrics_matching(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopicMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopicMetrics_heat(ctx context.Context, field graphql.CollectedField, obj *models.TopicMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopicMetrics_heat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Heat, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopicMetrics_heat(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopicMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopicMetrics_topic(ctx context.Context, field graphql.CollectedField, obj *models.TopicMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopicMetrics_topic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TopicMetrics().Topic(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Topic)
	fc.Result = res
	return ec.marshalNTopic2whalepkgmodelsTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopicMetrics_topic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopicMetrics",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Topic_id(ctx, field)
			case "recentUsers":
				return ec.fieldContext_Topic_recentUsers(ctx, field)
			case "matchingNum":
				return ec.fieldContext_Topic_matchingNum(ctx, field)
			case "fuzzyMatchingNum":
				return ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Topic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopicOptionConfig_topicId(ctx context.Context, field graphql.CollectedField, obj *models.TopicOptionConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopicOptionConfig_topicId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopicOptionConfig_topicId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopicOptionConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopicToMatching_topicId(ctx context.Context, field graphql.CollectedField, obj *models.TopicToMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopicToMatching_topicId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopicToMatching_topicId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopicToMatching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopicToMatching_matchingIds(ctx context.Context, field graphql.CollectedField, obj *models.TopicToMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopicToMatching_matchingIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchingIds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopicToMatching_matchingIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopicToMatching",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopicToMatching_topic(ctx context.Context, field graphql.CollectedField, obj *models.TopicToMatching) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopicToMatching_topic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TopicToMatching().Topic(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Topic)
	fc.Result = res
	return ec.marshalNTopic2whalepkgmodelsTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopicToMatching_topic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopicToMatching",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Topic_id(ctx, field)
			case "recentUsers":
				return ec.fieldContext_Topic_recentUsers(ctx, field)
			case "matchingNum":
				return ec.fieldContext_Topic_matchingNum(ctx, field)
			case "fuzzyMatchingNum":
				return ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Topic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_matchingQuota(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_matchingQuota(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().MatchingQuota(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.MatchingQuota)
	fc.Result = res
	return ec.marshalNMatchingQuota2whalepkgmodelsMatchingQuota(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_matchingQuota(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userId":
				return ec.fieldContext_MatchingQuota_userId(ctx, field)
			case "remain":
				return ec.fieldContext_MatchingQuota_remain(ctx, field)
			case "total":
				return ec.fieldContext_MatchingQuota_total(ctx, field)
			case "matchingNum":
				return ec.fieldContext_MatchingQuota_matchingNum(ctx, field)
			case "createdAt":
				return ec.fieldContext_MatchingQuota_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MatchingQuota_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MatchingQuota", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConfirmState_userId(ctx context.Context, field graphql.CollectedField, obj *models.UserConfirmState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConfirmState_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConfirmState_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConfirmState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConfirmState_state(ctx context.Context, field graphql.CollectedField, obj *models.UserConfirmState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConfirmState_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.MatchingResultConfirmState)
	fc.Result = res
	return ec.marshalNMatchingResultConfirmState2whalepkgmodelsMatchingResultConfirmState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConfirmState_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConfirmState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MatchingResultConfirmState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserJoinTopic_id(ctx context.Context, field graphql.CollectedField, obj *models.UserJoinTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserJoinTopic_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserJoinTopic_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserJoinTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserJoinTopic_topicId(ctx context.Context, field graphql.CollectedField, obj *models.UserJoinTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserJoinTopic_topicId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopicID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserJoinTopic_topicId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserJoinTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserJoinTopic_cityId(ctx context.Context, field graphql.CollectedField, obj *models.UserJoinTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserJoinTopic_cityId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserJoinTopic_cityId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserJoinTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserJoinTopic_userId(ctx context.Context, field graphql.CollectedField, obj *models.UserJoinTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserJoinTopic_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserJoinTopic_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserJoinTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserJoinTopic_latestMatchingId(ctx context.Context, field graphql.CollectedField, obj *models.UserJoinTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserJoinTopic_latestMatchingId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestMatchingID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserJoinTopic_latestMatchingId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserJoinTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserJoinTopic_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.UserJoinTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserJoinTopic_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserJoinTopic_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserJoinTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserJoinTopic_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.UserJoinTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserJoinTopic_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserJoinTopic_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserJoinTopic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserJoinTopic_topic(ctx context.Context, field graphql.CollectedField, obj *models.UserJoinTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserJoinTopic_topic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserJoinTopic().Topic(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Topic)
	fc.Result = res
	return ec.marshalNTopic2whalepkgmodelsTopic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserJoinTopic_topic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserJoinTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Topic_id(ctx, field)
			case "recentUsers":
				return ec.fieldContext_Topic_recentUsers(ctx, field)
			case "matchingNum":
				return ec.fieldContext_Topic_matchingNum(ctx, field)
			case "fuzzyMatchingNum":
				return ec.fieldContext_Topic_fuzzyMatchingNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Topic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserJoinTopic_city(ctx context.Context, field graphql.CollectedField, obj *models.UserJoinTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserJoinTopic_city(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserJoinTopic().City(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Area)
	fc.Result = res
	return ec.marshalNArea2whalepkgmodelsArea(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserJoinTopic_city(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserJoinTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Area_code(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Area", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserJoinTopic_user(ctx context.Context, field graphql.CollectedField, obj *models.UserJoinTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserJoinTopic_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserJoinTopic().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2whalepkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserJoinTopic_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserJoinTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "matchingQuota":
				return ec.fieldContext_User_matchingQuota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserJoinTopic_matching(ctx context.Context, field graphql.CollectedField, obj *models.UserJoinTopic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserJoinTopic_matching(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserJoinTopic().Matching(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Matching)
	fc.Result = res
	return ec.marshalNMatching2whalepkgmodelsMatching(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserJoinTopic_matching(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserJoinTopic",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Matching_id(ctx, field)
			case "topicId":
				return ec.fieldContext_Matching_topicId(ctx, field)
			case "userId":
				return ec.fieldContext_Matching_userId(ctx, field)
			case "areaIds":
				return ec.fieldContext_Matching_areaIds(ctx, field)
			case "cityId":
				return ec.fieldContext_Matching_cityId(ctx, field)
			case "gender":
				return ec.fieldContext_Matching_gender(ctx, field)
			case "state":
				return ec.fieldContext_Matching_state(ctx, field)
			case "rejectedUserIds":
				return ec.fieldContext_Matching_rejectedUserIds(ctx, field)
			case "inChatGroup":
				return ec.fieldContext_Matching_inChatGroup(ctx, field)
			case "remark":
				return ec.fieldContext_Matching_remark(ctx, field)
			case "dayRange":
				return ec.fieldContext_Matching_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_Matching_preferredPeriods(ctx, field)
			case "properties":
				return ec.fieldContext_Matching_properties(ctx, field)
			case "startMatchingAt":
				return ec.fieldContext_Matching_startMatchingAt(ctx, field)
			case "deadline":
				return ec.fieldContext_Matching_deadline(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Matching_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Matching_createdAt(ctx, field)
			case "matchingResult":
				return ec.fieldContext_Matching_matchingResult(ctx, field)
			case "reviewed":
				return ec.fieldContext_Matching_reviewed(ctx, field)
			case "user":
				return ec.fieldContext_Matching_user(ctx, field)
			case "topic":
				return ec.fieldContext_Matching_topic(ctx, field)
			case "areas":
				return ec.fieldContext_Matching_areas(ctx, field)
			case "city":
				return ec.fieldContext_Matching_city(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Matching", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserLikeMotion_toMotionId(ctx context.Context, field graphql.CollectedField, obj *models.UserLikeMotion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserLikeMotion_toMotionId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToMotionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserLikeMotion_toMotionId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserLikeMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserLikeMotion_toUserId(ctx context.Context, field graphql.CollectedField, obj *models.UserLikeMotion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserLikeMotion_toUserId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToUserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserLikeMotion_toUserId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserLikeMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserLikeMotion_userId(ctx context.Context, field graphql.CollectedField, obj *models.UserLikeMotion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserLikeMotion_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserLikeMotion_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserLikeMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserLikeMotion_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.UserLikeMotion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserLikeMotion_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserLikeMotion_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserLikeMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserLikeMotion_motion(ctx context.Context, field graphql.CollectedField, obj *models.UserLikeMotion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserLikeMotion_motion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserLikeMotion().Motion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Motion)
	fc.Result = res
	return ec.marshalNDiscoverMotion2whalepkgmodelsMotion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserLikeMotion_motion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserLikeMotion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscoverMotion_id(ctx, field)
			case "userId":
				return ec.fieldContext_DiscoverMotion_userId(ctx, field)
			case "topicId":
				return ec.fieldContext_DiscoverMotion_topicId(ctx, field)
			case "properties":
				return ec.fieldContext_DiscoverMotion_properties(ctx, field)
			case "cityId":
				return ec.fieldContext_DiscoverMotion_cityId(ctx, field)
			case "areaIds":
				return ec.fieldContext_DiscoverMotion_areaIds(ctx, field)
			case "gender":
				return ec.fieldContext_DiscoverMotion_gender(ctx, field)
			case "dayRange":
				return ec.fieldContext_DiscoverMotion_dayRange(ctx, field)
			case "preferredPeriods":
				return ec.fieldContext_DiscoverMotion_preferredPeriods(ctx, field)
			case "remark":
				return ec.fieldContext_DiscoverMotion_remark(ctx, field)
			case "likeCount":
				return ec.fieldContext_DiscoverMotion_likeCount(ctx, field)
			case "viewCount":
				return ec.fieldContext_DiscoverMotion_viewCount(ctx, field)
			case "thumbsUpCount":
				return ec.fieldContext_DiscoverMotion_thumbsUpCount(ctx, field)
			case "createdAt":
				return ec.fieldContext_DiscoverMotion_createdAt(ctx, field)
			case "liked":
				return ec.fieldContext_DiscoverMotion_liked(ctx, field)
			case "submitted":
				return ec.fieldContext_DiscoverMotion_submitted(ctx, field)
			case "thumbsUp":
				return ec.fieldContext_DiscoverMotion_thumbsUp(ctx, field)
			case "topic":
				return ec.fieldContext_DiscoverMotion_topic(ctx, field)
			case "topicOptionConfig":
				return ec.fieldContext_DiscoverMotion_topicOptionConfig(ctx, field)
			case "user":
				return ec.fieldContext_DiscoverMotion_user(ctx, field)
			case "city":
				return ec.fieldContext_DiscoverMotion_city(ctx, field)
			case "areas":
				return ec.fieldContext_DiscoverMotion_areas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscoverMotion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserThumbsUpMotion_userId(ctx context.Context, field graphql.CollectedField, obj *models.UserThumbsUpMotion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserThumbsUpMotion_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserThumbsUpMotion_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserThumbsUpMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserThumbsUpMotion_toMotionId(ctx context.Context, field graphql.CollectedField, obj *models.UserThumbsUpMotion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserThumbsUpMotion_toMotionId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToMotionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserThumbsUpMotion_toMotionId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserThumbsUpMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserThumbsUpMotion_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.UserThumbsUpMotion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserThumbsUpMotion_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserThumbsUpMotion_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserThumbsUpMotion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) __Service_sdl(ctx context.Context, field graphql.CollectedField, obj *fedruntime.Service) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext__Service_sdl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SDL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext__Service_sdl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "_Service",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputCitiesTopicsFilter(ctx context.Context, obj interface{}) (models.CitiesTopicsFilter, error) {
	var it models.CitiesTopicsFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cityId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateCityTopicParam(ctx context.Context, obj interface{}) (models.CreateCityTopicParam, error) {
	var it models.CreateCityTopicParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"topicIds", "cityId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "topicIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicIds"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicIds = data
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateMatchingInvitationParam(ctx context.Context, obj interface{}) (models.CreateMatchingInvitationParam, error) {
	var it models.CreateMatchingInvitationParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"inviteeId", "remark", "topicId", "cityId", "areaIds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "inviteeId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("inviteeId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InviteeID = data
		case "remark":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remark"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Remark = data
		case "topicId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicID = data
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "areaIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("areaIds"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AreaIds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateMatchingParam(ctx context.Context, obj interface{}) (models.CreateMatchingParam, error) {
	var it models.CreateMatchingParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"topicId", "areaIds", "cityId", "gender", "remark", "deadline"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "topicId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicID = data
		case "areaIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("areaIds"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AreaIds = data
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "gender":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gender"))
			data, err := ec.unmarshalNGender2whalepkgmodelsGender(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gender = data
		case "remark":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remark"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Remark = data
		case "deadline":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deadline"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Deadline = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateMatchingParamV2(ctx context.Context, obj interface{}) (models.CreateMatchingParamV2, error) {
	var it models.CreateMatchingParamV2
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"topicId", "areaIds", "cityId", "gender", "dayRange", "preferredPeriods", "properties", "remark", "deadline"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "topicId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicID = data
		case "areaIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("areaIds"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AreaIds = data
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "gender":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gender"))
			data, err := ec.unmarshalNGender2whalepkgmodelsGender(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gender = data
		case "dayRange":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dayRange"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DayRange = data
		case "preferredPeriods":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("preferredPeriods"))
			data, err := ec.unmarshalNDatePeriod2whalepkgmodelsDatePeriod(ctx, v)
			if err != nil {
				return it, err
			}
			it.PreferredPeriods = data
		case "properties":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("properties"))
			data, err := ec.unmarshalNMatchingPropertyParam2whalepkgmodelsMatchingPropertyParam(ctx, v)
			if err != nil {
				return it, err
			}
			it.Properties = data
		case "remark":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remark"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Remark = data
		case "deadline":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deadline"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Deadline = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateMotionParam(ctx context.Context, obj interface{}) (models.CreateMotionParam, error) {
	var it models.CreateMotionParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"topicId", "areaIds", "cityId", "gender", "dayRange", "preferredPeriods", "properties", "remark", "quick", "deadline"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "topicId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicID = data
		case "areaIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("areaIds"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AreaIds = data
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "gender":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gender"))
			data, err := ec.unmarshalNGender2whalepkgmodelsGender(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gender = data
		case "dayRange":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dayRange"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DayRange = data
		case "preferredPeriods":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("preferredPeriods"))
			data, err := ec.unmarshalNDatePeriod2whalepkgmodelsDatePeriod(ctx, v)
			if err != nil {
				return it, err
			}
			it.PreferredPeriods = data
		case "properties":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("properties"))
			data, err := ec.unmarshalNMotionPropertyParam2whalepkgmodelsMotionPropertyParam(ctx, v)
			if err != nil {
				return it, err
			}
			it.Properties = data
		case "remark":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remark"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Remark = data
		case "quick":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quick"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Quick = data
		case "deadline":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deadline"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Deadline = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateUserJoinTopicParam(ctx context.Context, obj interface{}) (models.CreateUserJoinTopicParam, error) {
	var it models.CreateUserJoinTopicParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"matchingId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "matchingId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchingId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MatchingID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDiscoverTopicCategoryMotionFilter(ctx context.Context, obj interface{}) (models.DiscoverTopicCategoryMotionFilter, error) {
	var it models.DiscoverTopicCategoryMotionFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cityId", "gender", "topicIds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "gender":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gender"))
			data, err := ec.unmarshalOGender2whalepkgmodelsGender(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gender = data
		case "topicIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicIds"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicIds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGraphQLPaginator(ctx context.Context, obj interface{}) (graphqlutil.GraphQLPaginator, error) {
	var it graphqlutil.GraphQLPaginator
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"size", "page"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "size":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("size"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Size = data
		case "page":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHotTopicsFilter(ctx context.Context, obj interface{}) (models.HotTopicsFilter, error) {
	var it models.HotTopicsFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cityId", "topicId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "topicId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMatchingFilter(ctx context.Context, obj interface{}) (models.MatchingFilter, error) {
	var it models.MatchingFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"before", "after", "topicId", "state", "cityId", "userId", "keyword"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "before":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Before = data
		case "after":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.After = data
		case "topicId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicID = data
		case "state":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("state"))
			data, err := ec.unmarshalOMatchingState2whalepkgmodelsMatchingState(ctx, v)
			if err != nil {
				return it, err
			}
			it.State = data
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "keyword":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMatchingInvitationFilter(ctx context.Context, obj interface{}) (models.MatchingInvitationFilter, error) {
	var it models.MatchingInvitationFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "before", "after"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "before":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Before = data
		case "after":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.After = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMatchingPropertyParam(ctx context.Context, obj interface{}) (models.MatchingPropertyParam, error) {
	var it models.MatchingPropertyParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "values"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "values":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("values"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Values = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMatchingResultFilter(ctx context.Context, obj interface{}) (models.MatchingResultFilter, error) {
	var it models.MatchingResultFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "before", "after"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "before":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Before = data
		case "after":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.After = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMotionFilter(ctx context.Context, obj interface{}) (models.MotionFilter, error) {
	var it models.MotionFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "userId", "cityId", "gender"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "gender":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gender"))
			data, err := ec.unmarshalOGender2whalepkgmodelsGender(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gender = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMotionPropertyParam(ctx context.Context, obj interface{}) (models.MotionPropertyParam, error) {
	var it models.MotionPropertyParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "values"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "values":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("values"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Values = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNotifyNewMotionOfferMessageParam(ctx context.Context, obj interface{}) (models.NotifyNewMotionOfferMessageParam, error) {
	var it models.NotifyNewMotionOfferMessageParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"begin", "end"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "begin":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("begin"))
			data, err := ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Begin = data
		case "end":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
			data, err := ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.End = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRecentMatchingFilter(ctx context.Context, obj interface{}) (models.RecentMatchingFilter, error) {
	var it models.RecentMatchingFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cityId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputReviewMatchingParam(ctx context.Context, obj interface{}) (models.ReviewMatchingParam, error) {
	var it models.ReviewMatchingParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"toUserId", "score", "comment"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "toUserId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toUserId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToUserID = data
		case "score":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("score"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Score = data
		case "comment":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Comment = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputReviewMotionParam(ctx context.Context, obj interface{}) (models.ReviewMotionParam, error) {
	var it models.ReviewMotionParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"score", "comment"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "score":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("score"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Score = data
		case "comment":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Comment = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateCityTopicParam(ctx context.Context, obj interface{}) (models.UpdateCityTopicParam, error) {
	var it models.UpdateCityTopicParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"topicIds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "topicIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicIds"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicIds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateDurationConstraintParam(ctx context.Context, obj interface{}) (models.UpdateDurationConstraintParam, error) {
	var it models.UpdateDurationConstraintParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"startDate", "stopDate", "totalMotionQuota", "remainMotionQuota"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "startDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDate"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartDate = data
		case "stopDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stopDate"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.StopDate = data
		case "totalMotionQuota":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalMotionQuota"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalMotionQuota = data
		case "remainMotionQuota":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remainMotionQuota"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemainMotionQuota = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateHotTopicMetricsParam(ctx context.Context, obj interface{}) (models.UpdateHotTopicMetricsParam, error) {
	var it models.UpdateHotTopicMetricsParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"topicId", "heat", "matched", "matching"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "topicId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicID = data
		case "heat":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("heat"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Heat = data
		case "matched":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matched"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Matched = data
		case "matching":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matching"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Matching = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateHotTopicParam(ctx context.Context, obj interface{}) (models.UpdateHotTopicParam, error) {
	var it models.UpdateHotTopicParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"topicMetrics"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "topicMetrics":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicMetrics"))
			data, err := ec.unmarshalNUpdateHotTopicMetricsParam2whalepkgmodelsUpdateHotTopicMetricsParam(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicMetrics = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateMatchingDurationConstraintParam(ctx context.Context, obj interface{}) (models.UpdateMatchingDurationConstraintParam, error) {
	var it models.UpdateMatchingDurationConstraintParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"total", "remain", "startDate", "stopDate"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "total":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("total"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Total = data
		case "remain":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remain"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Remain = data
		case "startDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDate"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartDate = data
		case "stopDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stopDate"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.StopDate = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateMatchingInvitationParam(ctx context.Context, obj interface{}) (models.UpdateMatchingInvitationParam, error) {
	var it models.UpdateMatchingInvitationParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"createdAt", "topicId", "inviteeId", "cityId", "remark"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "topicId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicID = data
		case "inviteeId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("inviteeId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InviteeID = data
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "remark":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remark"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Remark = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateMatchingParam(ctx context.Context, obj interface{}) (models.UpdateMatchingParam, error) {
	var it models.UpdateMatchingParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"topicId", "areaIds", "cityId", "gender", "remark", "startMatchingAt", "createdAt", "deadline"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "topicId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicID = data
		case "areaIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("areaIds"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AreaIds = data
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "gender":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gender"))
			data, err := ec.unmarshalOGender2whalepkgmodelsGender(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gender = data
		case "remark":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remark"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Remark = data
		case "startMatchingAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startMatchingAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartMatchingAt = data
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "deadline":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deadline"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Deadline = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateMatchingQuotaParam(ctx context.Context, obj interface{}) (models.UpdateMatchingQuotaParam, error) {
	var it models.UpdateMatchingQuotaParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"total", "remain"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "total":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("total"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Total = data
		case "remain":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remain"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Remain = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateMotionParam(ctx context.Context, obj interface{}) (models.UpdateMotionParam, error) {
	var it models.UpdateMotionParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"areaIds", "cityId", "gender", "dayRange", "preferredPeriods", "properties", "remark", "quick", "deadline"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "areaIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("areaIds"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AreaIds = data
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "gender":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gender"))
			data, err := ec.unmarshalOGender2whalepkgmodelsGender(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gender = data
		case "dayRange":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dayRange"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DayRange = data
		case "preferredPeriods":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("preferredPeriods"))
			data, err := ec.unmarshalODatePeriod2whalepkgmodelsDatePeriod(ctx, v)
			if err != nil {
				return it, err
			}
			it.PreferredPeriods = data
		case "properties":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("properties"))
			data, err := ec.unmarshalOMotionPropertyParam2whalepkgmodelsMotionPropertyParam(ctx, v)
			if err != nil {
				return it, err
			}
			it.Properties = data
		case "remark":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remark"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Remark = data
		case "quick":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quick"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Quick = data
		case "deadline":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deadline"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Deadline = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateRecentMatchingParam(ctx context.Context, obj interface{}) (models.UpdateRecentMatchingParam, error) {
	var it models.UpdateRecentMatchingParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"matchingIds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "matchingIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchingIds"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MatchingIds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUserJoinTopicParam(ctx context.Context, obj interface{}) (models.UpdateUserJoinTopicParam, error) {
	var it models.UpdateUserJoinTopicParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"matchingId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "matchingId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchingId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MatchingID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserJoinTopicFilter(ctx context.Context, obj interface{}) (models.UserJoinTopicFilter, error) {
	var it models.UserJoinTopicFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cityId", "topicId", "userId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cityId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityID = data
		case "topicId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopicID = data
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserMatchingCalenderParam(ctx context.Context, obj interface{}) (models.UserMatchingCalenderParam, error) {
	var it models.UserMatchingCalenderParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"before", "after", "otherUserId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "before":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			data, err := ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Before = data
		case "after":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			data, err := ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.After = data
		case "otherUserId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("otherUserId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OtherUserID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserMatchingFilter(ctx context.Context, obj interface{}) (models.UserMatchingFilter, error) {
	var it models.UserMatchingFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"state", "states"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "state":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("state"))
			data, err := ec.unmarshalOMatchingState2whalepkgmodelsMatchingState(ctx, v)
			if err != nil {
				return it, err
			}
			it.State = data
		case "states":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("states"))
			data, err := ec.unmarshalOMatchingState2whalepkgmodelsMatchingState(ctx, v)
			if err != nil {
				return it, err
			}
			it.States = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserMatchingInTheDayParam(ctx context.Context, obj interface{}) (models.UserMatchingInTheDayParam, error) {
	var it models.UserMatchingInTheDayParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"dayStr", "otherUserId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "dayStr":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dayStr"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DayStr = data
		case "otherUserId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("otherUserId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OtherUserID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserUpdateMotionParam(ctx context.Context, obj interface{}) (models.UserUpdateMotionParam, error) {
	var it models.UserUpdateMotionParam
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"areaIds", "gender", "dayRange", "preferredPeriods", "properties", "remark"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "areaIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("areaIds"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AreaIds = data
		case "gender":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gender"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gender = data
		case "dayRange":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dayRange"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DayRange = data
		case "preferredPeriods":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("preferredPeriods"))
			data, err := ec.unmarshalODatePeriod2whalepkgmodelsDatePeriod(ctx, v)
			if err != nil {
				return it, err
			}
			it.PreferredPeriods = data
		case "properties":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("properties"))
			data, err := ec.unmarshalOMotionPropertyParam2whalepkgmodelsMotionPropertyParam(ctx, v)
			if err != nil {
				return it, err
			}
			it.Properties = data
		case "remark":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remark"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Remark = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) __Entity(ctx context.Context, sel ast.SelectionSet, obj fedruntime.Entity) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case models.Area:
		return ec._Area(ctx, sel, &obj)
	case *models.Area:
		if obj == nil {
			return graphql.Null
		}
		return ec._Area(ctx, sel, obj)
	case models.ChatGroup:
		return ec._ChatGroup(ctx, sel, &obj)
	case *models.ChatGroup:
		if obj == nil {
			return graphql.Null
		}
		return ec._ChatGroup(ctx, sel, obj)
	case models.LevelRights:
		return ec._LevelRights(ctx, sel, &obj)
	case *models.LevelRights:
		if obj == nil {
			return graphql.Null
		}
		return ec._LevelRights(ctx, sel, obj)
	case models.Matching:
		return ec._Matching(ctx, sel, &obj)
	case *models.Matching:
		if obj == nil {
			return graphql.Null
		}
		return ec._Matching(ctx, sel, obj)
	case models.MatchingQuota:
		return ec._MatchingQuota(ctx, sel, &obj)
	case *models.MatchingQuota:
		if obj == nil {
			return graphql.Null
		}
		return ec._MatchingQuota(ctx, sel, obj)
	case models.Topic:
		return ec._Topic(ctx, sel, &obj)
	case *models.Topic:
		if obj == nil {
			return graphql.Null
		}
		return ec._Topic(ctx, sel, obj)
	case models.TopicOptionConfig:
		return ec._TopicOptionConfig(ctx, sel, &obj)
	case *models.TopicOptionConfig:
		if obj == nil {
			return graphql.Null
		}
		return ec._TopicOptionConfig(ctx, sel, obj)
	case models.User:
		return ec._User(ctx, sel, &obj)
	case *models.User:
		if obj == nil {
			return graphql.Null
		}
		return ec._User(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var areaImplementors = []string{"Area", "_Entity"}

func (ec *executionContext) _Area(ctx context.Context, sel ast.SelectionSet, obj *models.Area) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, areaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Area")
		case "code":
			out.Values[i] = ec._Area_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var availableMotionOfferImplementors = []string{"AvailableMotionOffer"}

func (ec *executionContext) _AvailableMotionOffer(ctx context.Context, sel ast.SelectionSet, obj *models.AvailableMotionOffer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, availableMotionOfferImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AvailableMotionOffer")
		case "motion":
			out.Values[i] = ec._AvailableMotionOffer_motion(ctx, field, obj)
		case "nextQuotaTime":
			out.Values[i] = ec._AvailableMotionOffer_nextQuotaTime(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var calendarEventImplementors = []string{"CalendarEvent"}

func (ec *executionContext) _CalendarEvent(ctx context.Context, sel ast.SelectionSet, obj *models.CalendarEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, calendarEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CalendarEvent")
		case "topicId":
			out.Values[i] = ec._CalendarEvent_topicId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "matchedAt":
			out.Values[i] = ec._CalendarEvent_matchedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "finishedAt":
			out.Values[i] = ec._CalendarEvent_finishedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "chatGroupCreatedAt":
			out.Values[i] = ec._CalendarEvent_chatGroupCreatedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var chatGroupImplementors = []string{"ChatGroup", "_Entity"}

func (ec *executionContext) _ChatGroup(ctx context.Context, sel ast.SelectionSet, obj *models.ChatGroup) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chatGroupImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChatGroup")
		case "id":
			out.Values[i] = ec._ChatGroup_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cityToTopicMatchingImplementors = []string{"CityToTopicMatching"}

func (ec *executionContext) _CityToTopicMatching(ctx context.Context, sel ast.SelectionSet, obj *models.CityToTopicMatching) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cityToTopicMatchingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CityToTopicMatching")
		case "cityId":
			out.Values[i] = ec._CityToTopicMatching_cityId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topics":
			out.Values[i] = ec._CityToTopicMatching_topics(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "city":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CityToTopicMatching_city(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cityTopicsImplementors = []string{"CityTopics"}

func (ec *executionContext) _CityTopics(ctx context.Context, sel ast.SelectionSet, obj *models.CityTopics) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cityTopicsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CityTopics")
		case "cityId":
			out.Values[i] = ec._CityTopics_cityId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topicIds":
			out.Values[i] = ec._CityTopics_topicIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._CityTopics_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topics":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CityTopics_topics(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "city":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CityTopics_city(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createMotionOfferResultImplementors = []string{"CreateMotionOfferResult"}

func (ec *executionContext) _CreateMotionOfferResult(ctx context.Context, sel ast.SelectionSet, obj *models.CreateMotionOfferResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createMotionOfferResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateMotionOfferResult")
		case "chatGroupId":
			out.Values[i] = ec._CreateMotionOfferResult_chatGroupId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var discoverMotionImplementors = []string{"DiscoverMotion"}

func (ec *executionContext) _DiscoverMotion(ctx context.Context, sel ast.SelectionSet, obj *models.Motion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, discoverMotionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DiscoverMotion")
		case "id":
			out.Values[i] = ec._DiscoverMotion_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userId":
			out.Values[i] = ec._DiscoverMotion_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topicId":
			out.Values[i] = ec._DiscoverMotion_topicId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "properties":
			out.Values[i] = ec._DiscoverMotion_properties(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cityId":
			out.Values[i] = ec._DiscoverMotion_cityId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "areaIds":
			out.Values[i] = ec._DiscoverMotion_areaIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "gender":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscoverMotion_gender(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "dayRange":
			out.Values[i] = ec._DiscoverMotion_dayRange(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "preferredPeriods":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscoverMotion_preferredPeriods(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "remark":
			out.Values[i] = ec._DiscoverMotion_remark(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "likeCount":
			out.Values[i] = ec._DiscoverMotion_likeCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "viewCount":
			out.Values[i] = ec._DiscoverMotion_viewCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "thumbsUpCount":
			out.Values[i] = ec._DiscoverMotion_thumbsUpCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._DiscoverMotion_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "liked":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscoverMotion_liked(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "submitted":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscoverMotion_submitted(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "thumbsUp":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscoverMotion_thumbsUp(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "topic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscoverMotion_topic(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "topicOptionConfig":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscoverMotion_topicOptionConfig(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscoverMotion_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "city":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscoverMotion_city(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "areas":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscoverMotion_areas(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var discoverMotionResultImplementors = []string{"DiscoverMotionResult"}

func (ec *executionContext) _DiscoverMotionResult(ctx context.Context, sel ast.SelectionSet, obj *models.DiscoverMotionResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, discoverMotionResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DiscoverMotionResult")
		case "motions":
			out.Values[i] = ec._DiscoverMotionResult_motions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nextToken":
			out.Values[i] = ec._DiscoverMotionResult_nextToken(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var durationConstraintImplementors = []string{"DurationConstraint"}

func (ec *executionContext) _DurationConstraint(ctx context.Context, sel ast.SelectionSet, obj *models.DurationConstraint) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, durationConstraintImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DurationConstraint")
		case "userId":
			out.Values[i] = ec._DurationConstraint_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._DurationConstraint_startDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stopDate":
			out.Values[i] = ec._DurationConstraint_stopDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalMotionQuota":
			out.Values[i] = ec._DurationConstraint_totalMotionQuota(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "remainMotionQuota":
			out.Values[i] = ec._DurationConstraint_remainMotionQuota(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._DurationConstraint_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var entityImplementors = []string{"Entity"}

func (ec *executionContext) _Entity(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, entityImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Entity",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Entity")
		case "findLevelRightsByLevel":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entity_findLevelRightsByLevel(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findMatchingByID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entity_findMatchingByID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findMatchingQuotaByUserID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entity_findMatchingQuotaByUserID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findTopicByID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entity_findTopicByID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findUserByID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entity_findUserByID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var evaluatorResultImplementors = []string{"EvaluatorResult"}

func (ec *executionContext) _EvaluatorResult(ctx context.Context, sel ast.SelectionSet, obj *matcher.EvaluatorResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, evaluatorResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EvaluatorResult")
		case "score":
			out.Values[i] = ec._EvaluatorResult_score(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "timeScore":
			out.Values[i] = ec._EvaluatorResult_timeScore(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "properties":
			out.Values[i] = ec._EvaluatorResult_properties(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "failedReason":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EvaluatorResult_failedReason(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hotTopicsInAreaImplementors = []string{"HotTopicsInArea"}

func (ec *executionContext) _HotTopicsInArea(ctx context.Context, sel ast.SelectionSet, obj *models.HotTopicsInArea) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hotTopicsInAreaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HotTopicsInArea")
		case "cityId":
			out.Values[i] = ec._HotTopicsInArea_cityId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._HotTopicsInArea_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topicMetrics":
			out.Values[i] = ec._HotTopicsInArea_topicMetrics(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "city":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._HotTopicsInArea_city(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var levelRightsImplementors = []string{"LevelRights", "_Entity"}

func (ec *executionContext) _LevelRights(ctx context.Context, sel ast.SelectionSet, obj *models.LevelRights) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, levelRightsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LevelRights")
		case "level":
			out.Values[i] = ec._LevelRights_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "matchingQuota":
			out.Values[i] = ec._LevelRights_matchingQuota(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "matchingDurationConstraint":
			out.Values[i] = ec._LevelRights_matchingDurationConstraint(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchingImplementors = []string{"Matching", "_Entity"}

func (ec *executionContext) _Matching(ctx context.Context, sel ast.SelectionSet, obj *models.Matching) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Matching")
		case "id":
			out.Values[i] = ec._Matching_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topicId":
			out.Values[i] = ec._Matching_topicId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userId":
			out.Values[i] = ec._Matching_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "areaIds":
			out.Values[i] = ec._Matching_areaIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cityId":
			out.Values[i] = ec._Matching_cityId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "gender":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Matching_gender(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "state":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Matching_state(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "rejectedUserIds":
			out.Values[i] = ec._Matching_rejectedUserIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "inChatGroup":
			out.Values[i] = ec._Matching_inChatGroup(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "remark":
			out.Values[i] = ec._Matching_remark(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "dayRange":
			out.Values[i] = ec._Matching_dayRange(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "preferredPeriods":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Matching_preferredPeriods(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "properties":
			out.Values[i] = ec._Matching_properties(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "startMatchingAt":
			out.Values[i] = ec._Matching_startMatchingAt(ctx, field, obj)
		case "deadline":
			out.Values[i] = ec._Matching_deadline(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Matching_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Matching_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchingResult":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Matching_matchingResult(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "reviewed":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Matching_reviewed(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Matching_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "topic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Matching_topic(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "areas":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Matching_areas(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "city":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Matching_city(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchingDurationConstraintImplementors = []string{"MatchingDurationConstraint"}

func (ec *executionContext) _MatchingDurationConstraint(ctx context.Context, sel ast.SelectionSet, obj *models.MatchingDurationConstraint) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchingDurationConstraintImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MatchingDurationConstraint")
		case "startDate":
			out.Values[i] = ec._MatchingDurationConstraint_startDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stopDate":
			out.Values[i] = ec._MatchingDurationConstraint_stopDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._MatchingDurationConstraint_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "remain":
			out.Values[i] = ec._MatchingDurationConstraint_remain(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._MatchingDurationConstraint_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchingInvitationImplementors = []string{"MatchingInvitation"}

func (ec *executionContext) _MatchingInvitation(ctx context.Context, sel ast.SelectionSet, obj *models.MatchingInvitation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchingInvitationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MatchingInvitation")
		case "id":
			out.Values[i] = ec._MatchingInvitation_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userId":
			out.Values[i] = ec._MatchingInvitation_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "inviteeId":
			out.Values[i] = ec._MatchingInvitation_inviteeId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topicId":
			out.Values[i] = ec._MatchingInvitation_topicId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "remark":
			out.Values[i] = ec._MatchingInvitation_remark(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cityId":
			out.Values[i] = ec._MatchingInvitation_cityId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "areaIds":
			out.Values[i] = ec._MatchingInvitation_areaIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchingResultId":
			out.Values[i] = ec._MatchingInvitation_matchingResultId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchingIds":
			out.Values[i] = ec._MatchingInvitation_matchingIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "confirmState":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingInvitation_confirmState(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "confirmedAt":
			out.Values[i] = ec._MatchingInvitation_confirmedAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._MatchingInvitation_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._MatchingInvitation_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "invitee":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingInvitation_invitee(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "topic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingInvitation_topic(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "areas":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingInvitation_areas(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "city":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingInvitation_city(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingInvitation_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "matchingResult":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingInvitation_matchingResult(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchingOfTopicImplementors = []string{"MatchingOfTopic"}

func (ec *executionContext) _MatchingOfTopic(ctx context.Context, sel ast.SelectionSet, obj *models.Matching) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchingOfTopicImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MatchingOfTopic")
		case "userId":
			out.Values[i] = ec._MatchingOfTopic_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "gender":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingOfTopic_gender(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "remark":
			out.Values[i] = ec._MatchingOfTopic_remark(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "areaIds":
			out.Values[i] = ec._MatchingOfTopic_areaIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cityId":
			out.Values[i] = ec._MatchingOfTopic_cityId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._MatchingOfTopic_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingOfTopic_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "city":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingOfTopic_city(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "areas":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingOfTopic_areas(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchingPreviewImplementors = []string{"MatchingPreview"}

func (ec *executionContext) _MatchingPreview(ctx context.Context, sel ast.SelectionSet, obj *models.Matching) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchingPreviewImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MatchingPreview")
		case "userId":
			out.Values[i] = ec._MatchingPreview_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "remark":
			out.Values[i] = ec._MatchingPreview_remark(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "properties":
			out.Values[i] = ec._MatchingPreview_properties(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "dayRange":
			out.Values[i] = ec._MatchingPreview_dayRange(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "preferredPeriods":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingPreview_preferredPeriods(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "topicOptionConfig":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingPreview_topicOptionConfig(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingPreview_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchingPropertyImplementors = []string{"MatchingProperty"}

func (ec *executionContext) _MatchingProperty(ctx context.Context, sel ast.SelectionSet, obj *models.MatchingProperty) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchingPropertyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MatchingProperty")
		case "id":
			out.Values[i] = ec._MatchingProperty_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "values":
			out.Values[i] = ec._MatchingProperty_values(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchingQuotaImplementors = []string{"MatchingQuota", "_Entity"}

func (ec *executionContext) _MatchingQuota(ctx context.Context, sel ast.SelectionSet, obj *models.MatchingQuota) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchingQuotaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MatchingQuota")
		case "userId":
			out.Values[i] = ec._MatchingQuota_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "remain":
			out.Values[i] = ec._MatchingQuota_remain(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._MatchingQuota_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "matchingNum":
			out.Values[i] = ec._MatchingQuota_matchingNum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._MatchingQuota_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._MatchingQuota_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchingResultImplementors = []string{"MatchingResult"}

func (ec *executionContext) _MatchingResult(ctx context.Context, sel ast.SelectionSet, obj *models.MatchingResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchingResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MatchingResult")
		case "id":
			out.Values[i] = ec._MatchingResult_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchingIds":
			out.Values[i] = ec._MatchingResult_matchingIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "motionIds":
			out.Values[i] = ec._MatchingResult_motionIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topicId":
			out.Values[i] = ec._MatchingResult_topicId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userIds":
			out.Values[i] = ec._MatchingResult_userIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "confirmStates":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingResult_confirmStates(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "userConfirmStates":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingResult_userConfirmStates(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "chatGroupId":
			out.Values[i] = ec._MatchingResult_chatGroupId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "chatGroupState":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingResult_chatGroupState(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updatedAt":
			out.Values[i] = ec._MatchingResult_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._MatchingResult_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchingScore":
			out.Values[i] = ec._MatchingResult_matchingScore(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "closed":
			out.Values[i] = ec._MatchingResult_closed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "finishedAt":
			out.Values[i] = ec._MatchingResult_finishedAt(ctx, field, obj)
		case "createdBy":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingResult_createdBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "users":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingResult_users(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "discoverMotion":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingResult_discoverMotion(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "matchingPreviews":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingResult_matchingPreviews(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "topic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingResult_topic(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "chatGroup":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingResult_chatGroup(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "matchingDegree":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MatchingResult_matchingDegree(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var matchingResultConfirmActionImplementors = []string{"MatchingResultConfirmAction"}

func (ec *executionContext) _MatchingResultConfirmAction(ctx context.Context, sel ast.SelectionSet, obj *models.MatchingResultConfirmAction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchingResultConfirmActionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MatchingResultConfirmAction")
		case "id":
			out.Values[i] = ec._MatchingResultConfirmAction_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "matchingResultId":
			out.Values[i] = ec._MatchingResultConfirmAction_matchingResultId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userId":
			out.Values[i] = ec._MatchingResultConfirmAction_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "confirmed":
			out.Values[i] = ec._MatchingResultConfirmAction_confirmed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._MatchingResultConfirmAction_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var motionImplementors = []string{"Motion"}

func (ec *executionContext) _Motion(ctx context.Context, sel ast.SelectionSet, obj *models.Motion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, motionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Motion")
		case "id":
			out.Values[i] = ec._Motion_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userId":
			out.Values[i] = ec._Motion_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cityId":
			out.Values[i] = ec._Motion_cityId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "remark":
			out.Values[i] = ec._Motion_remark(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "active":
			out.Values[i] = ec._Motion_active(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "inOfferNum":
			out.Values[i] = ec._Motion_inOfferNum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "outOfferNum":
			out.Values[i] = ec._Motion_outOfferNum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "pendingInNum":
			out.Values[i] = ec._Motion_pendingInNum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "pendingOutNum":
			out.Values[i] = ec._Motion_pendingOutNum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "activeNum":
			out.Values[i] = ec._Motion_activeNum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "discoverable":
			out.Values[i] = ec._Motion_discoverable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "relatedMatchingId":
			out.Values[i] = ec._Motion_relatedMatchingId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "properties":
			out.Values[i] = ec._Motion_properties(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "dayRange":
			out.Values[i] = ec._Motion_dayRange(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "preferredPeriods":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Motion_preferredPeriods(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "gender":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Motion_gender(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createdAt":
			out.Values[i] = ec._Motion_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "liked":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Motion_liked(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "viewCount":
			out.Values[i] = ec._Motion_viewCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "likeCount":
			out.Values[i] = ec._Motion_likeCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "thumbsUpCount":
			out.Values[i] = ec._Motion_thumbsUpCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "thumbsUp":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Motion_thumbsUp(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "topic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Motion_topic(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "topicOptionConfig":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Motion_topicOptionConfig(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Motion_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "city":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Motion_city(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "areas":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Motion_areas(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var motionOfferRecordImplementors = []string{"MotionOfferRecord"}

func (ec *executionContext) _MotionOfferRecord(ctx context.Context, sel ast.SelectionSet, obj *models.MotionOfferRecord) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, motionOfferRecordImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MotionOfferRecord")
		case "id":
			out.Values[i] = ec._MotionOfferRecord_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "toMotionId":
			out.Values[i] = ec._MotionOfferRecord_toMotionId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "motionId":
			out.Values[i] = ec._MotionOfferRecord_motionId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "state":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MotionOfferRecord_state(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createdAt":
			out.Values[i] = ec._MotionOfferRecord_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "reactAt":
			out.Values[i] = ec._MotionOfferRecord_reactAt(ctx, field, obj)
		case "remark":
			out.Values[i] = ec._MotionOfferRecord_remark(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "chatChance":
			out.Values[i] = ec._MotionOfferRecord_chatChance(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "reviewed":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MotionOfferRecord_reviewed(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "toMotion":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MotionOfferRecord_toMotion(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "motion":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MotionOfferRecord_motion(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var motionPropertyImplementors = []string{"MotionProperty"}

func (ec *executionContext) _MotionProperty(ctx context.Context, sel ast.SelectionSet, obj *models.MotionProperty) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, motionPropertyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MotionProperty")
		case "id":
			out.Values[i] = ec._MotionProperty_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "values":
			out.Values[i] = ec._MotionProperty_values(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "refreshTopicMetrics":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_refreshTopicMetrics(ctx, field)
			})
		case "updateDurationConstraint":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateDurationConstraint(ctx, field)
			})
		case "createMatchingInvitation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMatchingInvitation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cancelMatchingInvitation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelMatchingInvitation(ctx, field)
			})
		case "confirmMatchingInvitation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_confirmMatchingInvitation(ctx, field)
			})
		case "updateMatchingInvitation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateMatchingInvitation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createMatching":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMatching(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createMatchingV2":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMatchingV2(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateMatching":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateMatching(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateMatchingQuota":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateMatchingQuota(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateMatchingDurationConstraint":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateMatchingDurationConstraint(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "confirmMatchingResult":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_confirmMatchingResult(ctx, field)
			})
		case "confirmMatchingResultV2":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_confirmMatchingResultV2(ctx, field)
			})
		case "cancelMatching":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelMatching(ctx, field)
			})
		case "startMatching":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_startMatching(ctx, field)
			})
		case "finishMatching":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_finishMatching(ctx, field)
			})
		case "reviewMatching":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_reviewMatching(ctx, field)
			})
		case "updateRecentMatching":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateRecentMatching(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addMatchingToRecent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addMatchingToRecent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "getMatchingScore":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_getMatchingScore(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "getAvailableMotionOffer":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_getAvailableMotionOffer(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createMotionOffer":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMotionOffer(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cancelMotionOffer":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelMotionOffer(ctx, field)
			})
		case "acceptMotionOffer":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_acceptMotionOffer(ctx, field)
			})
		case "rejectMotionOffer":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_rejectMotionOffer(ctx, field)
			})
		case "sendChatInOffer":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_sendChatInOffer(ctx, field)
			})
		case "finishMotionOffer":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_finishMotionOffer(ctx, field)
			})
		case "notifyNewMotionOffer":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_notifyNewMotionOffer(ctx, field)
			})
		case "sendMotionOfferAcceptMessage":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_sendMotionOfferAcceptMessage(ctx, field)
			})
		case "createMotion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMotion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateMotion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateMotion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userUpdateMotion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_userUpdateMotion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "closeMotion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_closeMotion(ctx, field)
			})
		case "reviewMotionOffer":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_reviewMotionOffer(ctx, field)
			})
		case "createCityTopics":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createCityTopics(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateCityTopics":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateCityTopics(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateHotTopicsInArea":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateHotTopicsInArea(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateUserJoinTopic":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateUserJoinTopic(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createUserJoinTopic":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createUserJoinTopic(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "likeMotion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_likeMotion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unlikeMotion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unlikeMotion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "thumbsUpMotion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_thumbsUpMotion(ctx, field)
			})
		case "cancelThumbsUpMotion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelThumbsUpMotion(ctx, field)
			})
		case "thumbsUpMotions":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_thumbsUpMotions(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "thumbsUpMotionsCount":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_thumbsUpMotionsCount(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "chatGroupByResultId":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_chatGroupByResultId(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userDurationConstraint":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userDurationConstraint(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "yesterdayMatchingCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_yesterdayMatchingCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "motionSummary":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_motionSummary(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "matchingInvitations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_matchingInvitations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "matchingInvitationsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_matchingInvitationsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "invitations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_invitations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "invitation":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_invitation(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "invitationsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_invitationsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "matching":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_matching(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userMatchingQuota":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userMatchingQuota(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userMatchingCalendar":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userMatchingCalendar(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userMatchingsInTheDay":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userMatchingsInTheDay(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "matchingResultByChatGroupId":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_matchingResultByChatGroupId(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "matchings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_matchings(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "matchingsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_matchingsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "matchingResult":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_matchingResult(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "matchingResults":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_matchingResults(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "matchingResultsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_matchingResultsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userMatchings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userMatchings(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "unconfirmedUserMatchings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_unconfirmedUserMatchings(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userMatchingsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userMatchingsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "previewMatchingsOfTopic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_previewMatchingsOfTopic(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "unconfirmedInvitations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_unconfirmedInvitations(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "unconfirmedInvitationCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_unconfirmedInvitationCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "recentMatchings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_recentMatchings(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "recentMatchingsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_recentMatchingsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "recentMatching":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_recentMatching(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "topicDistribution":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_topicDistribution(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "cityDistribution":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cityDistribution(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "matchingDurationConstraints":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_matchingDurationConstraints(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "discoverCategoryMotions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_discoverCategoryMotions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "discoverLatestCategoryMotions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_discoverLatestCategoryMotions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getDiscoverMotion":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getDiscoverMotion(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "outMotionOffers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_outMotionOffers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "inMotionOffers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_inMotionOffers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMotionOffer":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMotionOffer(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "motion":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_motion(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userMotions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userMotions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userMotionsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userMotionsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "activeMotions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_activeMotions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "motions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_motions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "motionsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_motionsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "cityTopics":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cityTopics(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "citiesTopics":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_citiesTopics(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "citiesTopicsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_citiesTopicsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "hotTopicsInArea":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hotTopicsInArea(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "hotTopics":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hotTopics(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "hotTopicsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hotTopicsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userJoinTopics":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userJoinTopics(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userJoinTopicsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userJoinTopicsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userJoinTopic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userJoinTopic(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "likedMotions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_likedMotions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "likedMotionsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_likedMotionsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "_entities":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__entities(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "_service":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__service(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var recentMatchingImplementors = []string{"RecentMatching"}

func (ec *executionContext) _RecentMatching(ctx context.Context, sel ast.SelectionSet, obj *models.RecentMatching) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, recentMatchingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RecentMatching")
		case "id":
			out.Values[i] = ec._RecentMatching_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cityId":
			out.Values[i] = ec._RecentMatching_cityId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topicId":
			out.Values[i] = ec._RecentMatching_topicId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchingIds":
			out.Values[i] = ec._RecentMatching_matchingIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._RecentMatching_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._RecentMatching_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RecentMatching_topic(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "city":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RecentMatching_city(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "matchings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RecentMatching_matchings(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var simpleAvatarUserImplementors = []string{"SimpleAvatarUser"}

func (ec *executionContext) _SimpleAvatarUser(ctx context.Context, sel ast.SelectionSet, obj *models.SimpleAvatarUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, simpleAvatarUserImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SimpleAvatarUser")
		case "avatar":
			out.Values[i] = ec._SimpleAvatarUser_avatar(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nickname":
			out.Values[i] = ec._SimpleAvatarUser_nickname(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var summaryImplementors = []string{"Summary"}

func (ec *executionContext) _Summary(ctx context.Context, sel ast.SelectionSet, obj *models.Summary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, summaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Summary")
		case "count":
			out.Values[i] = ec._Summary_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var topicImplementors = []string{"Topic", "_Entity"}

func (ec *executionContext) _Topic(ctx context.Context, sel ast.SelectionSet, obj *models.Topic) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, topicImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Topic")
		case "id":
			out.Values[i] = ec._Topic_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "recentUsers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Topic_recentUsers(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "matchingNum":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Topic_matchingNum(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "fuzzyMatchingNum":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Topic_fuzzyMatchingNum(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var topicMetricsImplementors = []string{"TopicMetrics"}

func (ec *executionContext) _TopicMetrics(ctx context.Context, sel ast.SelectionSet, obj *models.TopicMetrics) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, topicMetricsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TopicMetrics")
		case "id":
			out.Values[i] = ec._TopicMetrics_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matched":
			out.Values[i] = ec._TopicMetrics_matched(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matching":
			out.Values[i] = ec._TopicMetrics_matching(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "heat":
			out.Values[i] = ec._TopicMetrics_heat(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TopicMetrics_topic(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var topicOptionConfigImplementors = []string{"TopicOptionConfig", "_Entity"}

func (ec *executionContext) _TopicOptionConfig(ctx context.Context, sel ast.SelectionSet, obj *models.TopicOptionConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, topicOptionConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TopicOptionConfig")
		case "topicId":
			out.Values[i] = ec._TopicOptionConfig_topicId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var topicToMatchingImplementors = []string{"TopicToMatching"}

func (ec *executionContext) _TopicToMatching(ctx context.Context, sel ast.SelectionSet, obj *models.TopicToMatching) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, topicToMatchingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TopicToMatching")
		case "topicId":
			out.Values[i] = ec._TopicToMatching_topicId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchingIds":
			out.Values[i] = ec._TopicToMatching_matchingIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TopicToMatching_topic(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User", "_Entity"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *models.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "matchingQuota":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_matchingQuota(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userConfirmStateImplementors = []string{"UserConfirmState"}

func (ec *executionContext) _UserConfirmState(ctx context.Context, sel ast.SelectionSet, obj *models.UserConfirmState) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userConfirmStateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserConfirmState")
		case "userId":
			out.Values[i] = ec._UserConfirmState_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "state":
			out.Values[i] = ec._UserConfirmState_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userJoinTopicImplementors = []string{"UserJoinTopic"}

func (ec *executionContext) _UserJoinTopic(ctx context.Context, sel ast.SelectionSet, obj *models.UserJoinTopic) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userJoinTopicImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserJoinTopic")
		case "id":
			out.Values[i] = ec._UserJoinTopic_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topicId":
			out.Values[i] = ec._UserJoinTopic_topicId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cityId":
			out.Values[i] = ec._UserJoinTopic_cityId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userId":
			out.Values[i] = ec._UserJoinTopic_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "latestMatchingId":
			out.Values[i] = ec._UserJoinTopic_latestMatchingId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._UserJoinTopic_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._UserJoinTopic_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "topic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserJoinTopic_topic(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "city":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserJoinTopic_city(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserJoinTopic_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "matching":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserJoinTopic_matching(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userLikeMotionImplementors = []string{"UserLikeMotion"}

func (ec *executionContext) _UserLikeMotion(ctx context.Context, sel ast.SelectionSet, obj *models.UserLikeMotion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userLikeMotionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserLikeMotion")
		case "toMotionId":
			out.Values[i] = ec._UserLikeMotion_toMotionId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "toUserId":
			out.Values[i] = ec._UserLikeMotion_toUserId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userId":
			out.Values[i] = ec._UserLikeMotion_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._UserLikeMotion_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "motion":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserLikeMotion_motion(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userThumbsUpMotionImplementors = []string{"UserThumbsUpMotion"}

func (ec *executionContext) _UserThumbsUpMotion(ctx context.Context, sel ast.SelectionSet, obj *models.UserThumbsUpMotion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userThumbsUpMotionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserThumbsUpMotion")
		case "userId":
			out.Values[i] = ec._UserThumbsUpMotion_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "toMotionId":
			out.Values[i] = ec._UserThumbsUpMotion_toMotionId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._UserThumbsUpMotion_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var _ServiceImplementors = []string{"_Service"}

func (ec *executionContext) __Service(ctx context.Context, sel ast.SelectionSet, obj *fedruntime.Service) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, _ServiceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("_Service")
		case "sdl":
			out.Values[i] = ec.__Service_sdl(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNArea2whalepkgmodelsArea(ctx context.Context, sel ast.SelectionSet, v models.Area) graphql.Marshaler {
	return ec._Area(ctx, sel, &v)
}

func (ec *executionContext) marshalNArea2whalepkgmodelsArea(ctx context.Context, sel ast.SelectionSet, v []*models.Area) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNArea2whalepkgmodelsArea(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNArea2whalepkgmodelsArea(ctx context.Context, sel ast.SelectionSet, v *models.Area) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Area(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAreaCode2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAreaCode2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNAvailableMotionOffer2whalepkgmodelsAvailableMotionOffer(ctx context.Context, sel ast.SelectionSet, v models.AvailableMotionOffer) graphql.Marshaler {
	return ec._AvailableMotionOffer(ctx, sel, &v)
}

func (ec *executionContext) marshalNAvailableMotionOffer2whalepkgmodelsAvailableMotionOffer(ctx context.Context, sel ast.SelectionSet, v *models.AvailableMotionOffer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AvailableMotionOffer(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCalendarEvent2whalepkgmodelsCalendarEvent(ctx context.Context, sel ast.SelectionSet, v []*models.CalendarEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCalendarEvent2whalepkgmodelsCalendarEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCalendarEvent2whalepkgmodelsCalendarEvent(ctx context.Context, sel ast.SelectionSet, v *models.CalendarEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CalendarEvent(ctx, sel, v)
}

func (ec *executionContext) marshalNChatGroup2whalepkgmodelsChatGroup(ctx context.Context, sel ast.SelectionSet, v models.ChatGroup) graphql.Marshaler {
	return ec._ChatGroup(ctx, sel, &v)
}

func (ec *executionContext) marshalNChatGroup2whalepkgmodelsChatGroup(ctx context.Context, sel ast.SelectionSet, v *models.ChatGroup) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChatGroup(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChatGroupState2whalepkgmodelsChatGroupState(ctx context.Context, v interface{}) (models.ChatGroupState, error) {
	var res models.ChatGroupState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChatGroupState2whalepkgmodelsChatGroupState(ctx context.Context, sel ast.SelectionSet, v models.ChatGroupState) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCityToTopicMatching2whalepkgmodelsCityToTopicMatching(ctx context.Context, sel ast.SelectionSet, v []*models.CityToTopicMatching) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCityToTopicMatching2whalepkgmodelsCityToTopicMatching(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCityToTopicMatching2whalepkgmodelsCityToTopicMatching(ctx context.Context, sel ast.SelectionSet, v *models.CityToTopicMatching) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CityToTopicMatching(ctx, sel, v)
}

func (ec *executionContext) marshalNCityTopics2whalepkgmodelsCityTopics(ctx context.Context, sel ast.SelectionSet, v models.CityTopics) graphql.Marshaler {
	return ec._CityTopics(ctx, sel, &v)
}

func (ec *executionContext) marshalNCityTopics2whalepkgmodelsCityTopics(ctx context.Context, sel ast.SelectionSet, v []*models.CityTopics) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCityTopics2whalepkgmodelsCityTopics(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCityTopics2whalepkgmodelsCityTopics(ctx context.Context, sel ast.SelectionSet, v *models.CityTopics) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CityTopics(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateCityTopicParam2whalepkgmodelsCreateCityTopicParam(ctx context.Context, v interface{}) (models.CreateCityTopicParam, error) {
	res, err := ec.unmarshalInputCreateCityTopicParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateMatchingInvitationParam2whalepkgmodelsCreateMatchingInvitationParam(ctx context.Context, v interface{}) (models.CreateMatchingInvitationParam, error) {
	res, err := ec.unmarshalInputCreateMatchingInvitationParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateMatchingParam2whalepkgmodelsCreateMatchingParam(ctx context.Context, v interface{}) (models.CreateMatchingParam, error) {
	res, err := ec.unmarshalInputCreateMatchingParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateMatchingParamV22whalepkgmodelsCreateMatchingParamV2(ctx context.Context, v interface{}) (models.CreateMatchingParamV2, error) {
	res, err := ec.unmarshalInputCreateMatchingParamV2(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateMotionOfferResult2whalepkgmodelsCreateMotionOfferResult(ctx context.Context, sel ast.SelectionSet, v models.CreateMotionOfferResult) graphql.Marshaler {
	return ec._CreateMotionOfferResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateMotionOfferResult2whalepkgmodelsCreateMotionOfferResult(ctx context.Context, sel ast.SelectionSet, v *models.CreateMotionOfferResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateMotionOfferResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateMotionParam2whalepkgmodelsCreateMotionParam(ctx context.Context, v interface{}) (models.CreateMotionParam, error) {
	res, err := ec.unmarshalInputCreateMotionParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateUserJoinTopicParam2whalepkgmodelsCreateUserJoinTopicParam(ctx context.Context, v interface{}) (models.CreateUserJoinTopicParam, error) {
	res, err := ec.unmarshalInputCreateUserJoinTopicParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDatePeriod2whalepkgmodelsDatePeriod(ctx context.Context, v interface{}) (models.DatePeriod, error) {
	var res models.DatePeriod
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDatePeriod2whalepkgmodelsDatePeriod(ctx context.Context, sel ast.SelectionSet, v models.DatePeriod) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDatePeriod2whalepkgmodelsDatePeriod(ctx context.Context, v interface{}) ([]models.DatePeriod, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]models.DatePeriod, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDatePeriod2whalepkgmodelsDatePeriod(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNDatePeriod2whalepkgmodelsDatePeriod(ctx context.Context, sel ast.SelectionSet, v []models.DatePeriod) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDatePeriod2whalepkgmodelsDatePeriod(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDiscoverMotion2whalepkgmodelsMotion(ctx context.Context, sel ast.SelectionSet, v models.Motion) graphql.Marshaler {
	return ec._DiscoverMotion(ctx, sel, &v)
}

func (ec *executionContext) marshalNDiscoverMotion2whalepkgmodelsMotion(ctx context.Context, sel ast.SelectionSet, v []*models.Motion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDiscoverMotion2whalepkgmodelsMotion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDiscoverMotion2whalepkgmodelsMotion(ctx context.Context, sel ast.SelectionSet, v *models.Motion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DiscoverMotion(ctx, sel, v)
}

func (ec *executionContext) marshalNDiscoverMotionResult2whalepkgmodelsDiscoverMotionResult(ctx context.Context, sel ast.SelectionSet, v models.DiscoverMotionResult) graphql.Marshaler {
	return ec._DiscoverMotionResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNDiscoverMotionResult2whalepkgmodelsDiscoverMotionResult(ctx context.Context, sel ast.SelectionSet, v *models.DiscoverMotionResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DiscoverMotionResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDiscoverTopicCategoryMotionFilter2whalepkgmodelsDiscoverTopicCategoryMotionFilter(ctx context.Context, v interface{}) (models.DiscoverTopicCategoryMotionFilter, error) {
	res, err := ec.unmarshalInputDiscoverTopicCategoryMotionFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDurationConstraint2whalepkgmodelsDurationConstraint(ctx context.Context, sel ast.SelectionSet, v models.DurationConstraint) graphql.Marshaler {
	return ec._DurationConstraint(ctx, sel, &v)
}

func (ec *executionContext) marshalNDurationConstraint2whalepkgmodelsDurationConstraint(ctx context.Context, sel ast.SelectionSet, v *models.DurationConstraint) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DurationConstraint(ctx, sel, v)
}

func (ec *executionContext) marshalNEvaluatorResult2whalepkgmatcherEvaluatorResult(ctx context.Context, sel ast.SelectionSet, v matcher.EvaluatorResult) graphql.Marshaler {
	return ec._EvaluatorResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNEvaluatorResult2whalepkgmatcherEvaluatorResult(ctx context.Context, sel ast.SelectionSet, v *matcher.EvaluatorResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EvaluatorResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFieldSet2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFieldSet2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNGender2whalepkgmodelsGender(ctx context.Context, v interface{}) (models.Gender, error) {
	var res models.Gender
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGender2whalepkgmodelsGender(ctx context.Context, sel ast.SelectionSet, v models.Gender) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNHotTopicsInArea2whalepkgmodelsHotTopicsInArea(ctx context.Context, sel ast.SelectionSet, v models.HotTopicsInArea) graphql.Marshaler {
	return ec._HotTopicsInArea(ctx, sel, &v)
}

func (ec *executionContext) marshalNHotTopicsInArea2whalepkgmodelsHotTopicsInArea(ctx context.Context, sel ast.SelectionSet, v []*models.HotTopicsInArea) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHotTopicsInArea2whalepkgmodelsHotTopicsInArea(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNHotTopicsInArea2whalepkgmodelsHotTopicsInArea(ctx context.Context, sel ast.SelectionSet, v *models.HotTopicsInArea) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HotTopicsInArea(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) ([]int, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInvitationConfirmState2whalepkgmodelsInvitationConfirmState(ctx context.Context, v interface{}) (models.InvitationConfirmState, error) {
	var res models.InvitationConfirmState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInvitationConfirmState2whalepkgmodelsInvitationConfirmState(ctx context.Context, sel ast.SelectionSet, v models.InvitationConfirmState) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNLevelRights2whalepkgmodelsLevelRights(ctx context.Context, sel ast.SelectionSet, v models.LevelRights) graphql.Marshaler {
	return ec._LevelRights(ctx, sel, &v)
}

func (ec *executionContext) marshalNLevelRights2whalepkgmodelsLevelRights(ctx context.Context, sel ast.SelectionSet, v *models.LevelRights) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LevelRights(ctx, sel, v)
}

func (ec *executionContext) marshalNMatching2whalepkgmodelsMatching(ctx context.Context, sel ast.SelectionSet, v models.Matching) graphql.Marshaler {
	return ec._Matching(ctx, sel, &v)
}

func (ec *executionContext) marshalNMatching2whalepkgmodelsMatching(ctx context.Context, sel ast.SelectionSet, v []*models.Matching) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatching2whalepkgmodelsMatching(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMatching2whalepkgmodelsMatching(ctx context.Context, sel ast.SelectionSet, v *models.Matching) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Matching(ctx, sel, v)
}

func (ec *executionContext) marshalNMatchingDurationConstraint2whalepkgmodelsMatchingDurationConstraint(ctx context.Context, sel ast.SelectionSet, v models.MatchingDurationConstraint) graphql.Marshaler {
	return ec._MatchingDurationConstraint(ctx, sel, &v)
}

func (ec *executionContext) marshalNMatchingDurationConstraint2whalepkgmodelsMatchingDurationConstraint(ctx context.Context, sel ast.SelectionSet, v *models.MatchingDurationConstraint) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MatchingDurationConstraint(ctx, sel, v)
}

func (ec *executionContext) marshalNMatchingInvitation2whalepkgmodelsMatchingInvitation(ctx context.Context, sel ast.SelectionSet, v models.MatchingInvitation) graphql.Marshaler {
	return ec._MatchingInvitation(ctx, sel, &v)
}

func (ec *executionContext) marshalNMatchingInvitation2whalepkgmodelsMatchingInvitation(ctx context.Context, sel ast.SelectionSet, v []*models.MatchingInvitation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatchingInvitation2whalepkgmodelsMatchingInvitation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMatchingInvitation2whalepkgmodelsMatchingInvitation(ctx context.Context, sel ast.SelectionSet, v *models.MatchingInvitation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MatchingInvitation(ctx, sel, v)
}

func (ec *executionContext) marshalNMatchingOfTopic2whalepkgmodelsMatching(ctx context.Context, sel ast.SelectionSet, v []*models.Matching) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatchingOfTopic2whalepkgmodelsMatching(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMatchingOfTopic2whalepkgmodelsMatching(ctx context.Context, sel ast.SelectionSet, v *models.Matching) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MatchingOfTopic(ctx, sel, v)
}

func (ec *executionContext) marshalNMatchingPreview2whalepkgmodelsMatching(ctx context.Context, sel ast.SelectionSet, v []*models.Matching) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatchingPreview2whalepkgmodelsMatching(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMatchingPreview2whalepkgmodelsMatching(ctx context.Context, sel ast.SelectionSet, v *models.Matching) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MatchingPreview(ctx, sel, v)
}

func (ec *executionContext) marshalNMatchingProperty2whalepkgmodelsMatchingProperty(ctx context.Context, sel ast.SelectionSet, v models.MatchingProperty) graphql.Marshaler {
	return ec._MatchingProperty(ctx, sel, &v)
}

func (ec *executionContext) marshalNMatchingProperty2whalepkgmodelsMatchingProperty(ctx context.Context, sel ast.SelectionSet, v []models.MatchingProperty) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatchingProperty2whalepkgmodelsMatchingProperty(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMatchingPropertyParam2whalepkgmodelsMatchingPropertyParam(ctx context.Context, v interface{}) ([]*models.MatchingPropertyParam, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.MatchingPropertyParam, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMatchingPropertyParam2whalepkgmodelsMatchingPropertyParam(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMatchingPropertyParam2whalepkgmodelsMatchingPropertyParam(ctx context.Context, v interface{}) (*models.MatchingPropertyParam, error) {
	res, err := ec.unmarshalInputMatchingPropertyParam(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMatchingQuota2whalepkgmodelsMatchingQuota(ctx context.Context, sel ast.SelectionSet, v models.MatchingQuota) graphql.Marshaler {
	return ec._MatchingQuota(ctx, sel, &v)
}

func (ec *executionContext) marshalNMatchingQuota2whalepkgmodelsMatchingQuota(ctx context.Context, sel ast.SelectionSet, v *models.MatchingQuota) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MatchingQuota(ctx, sel, v)
}

func (ec *executionContext) marshalNMatchingResult2whalepkgmodelsMatchingResult(ctx context.Context, sel ast.SelectionSet, v models.MatchingResult) graphql.Marshaler {
	return ec._MatchingResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNMatchingResult2whalepkgmodelsMatchingResult(ctx context.Context, sel ast.SelectionSet, v []*models.MatchingResult) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatchingResult2whalepkgmodelsMatchingResult(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMatchingResult2whalepkgmodelsMatchingResult(ctx context.Context, sel ast.SelectionSet, v *models.MatchingResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MatchingResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMatchingResultConfirmState2whalepkgmodelsMatchingResultConfirmState(ctx context.Context, v interface{}) (models.MatchingResultConfirmState, error) {
	var res models.MatchingResultConfirmState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMatchingResultConfirmState2whalepkgmodelsMatchingResultConfirmState(ctx context.Context, sel ast.SelectionSet, v models.MatchingResultConfirmState) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMatchingResultConfirmState2whalepkgmodelsMatchingResultConfirmState(ctx context.Context, v interface{}) ([]models.MatchingResultConfirmState, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]models.MatchingResultConfirmState, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMatchingResultConfirmState2whalepkgmodelsMatchingResultConfirmState(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNMatchingResultConfirmState2whalepkgmodelsMatchingResultConfirmState(ctx context.Context, sel ast.SelectionSet, v []models.MatchingResultConfirmState) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatchingResultConfirmState2whalepkgmodelsMatchingResultConfirmState(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMatchingState2whalepkgmodelsMatchingState(ctx context.Context, v interface{}) (models.MatchingState, error) {
	var res models.MatchingState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMatchingState2whalepkgmodelsMatchingState(ctx context.Context, sel ast.SelectionSet, v models.MatchingState) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNMotion2whalepkgmodelsMotion(ctx context.Context, sel ast.SelectionSet, v models.Motion) graphql.Marshaler {
	return ec._Motion(ctx, sel, &v)
}

func (ec *executionContext) marshalNMotion2whalepkgmodelsMotion(ctx context.Context, sel ast.SelectionSet, v []*models.Motion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMotion2whalepkgmodelsMotion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMotion2whalepkgmodelsMotion(ctx context.Context, sel ast.SelectionSet, v *models.Motion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Motion(ctx, sel, v)
}

func (ec *executionContext) marshalNMotionOfferRecord2whalepkgmodelsMotionOfferRecord(ctx context.Context, sel ast.SelectionSet, v models.MotionOfferRecord) graphql.Marshaler {
	return ec._MotionOfferRecord(ctx, sel, &v)
}

func (ec *executionContext) marshalNMotionOfferRecord2whalepkgmodelsMotionOfferRecord(ctx context.Context, sel ast.SelectionSet, v []*models.MotionOfferRecord) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMotionOfferRecord2whalepkgmodelsMotionOfferRecord(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMotionOfferRecord2whalepkgmodelsMotionOfferRecord(ctx context.Context, sel ast.SelectionSet, v *models.MotionOfferRecord) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MotionOfferRecord(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMotionOfferState2whalepkgmodelsMotionOfferState(ctx context.Context, v interface{}) (models.MotionOfferState, error) {
	var res models.MotionOfferState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMotionOfferState2whalepkgmodelsMotionOfferState(ctx context.Context, sel ast.SelectionSet, v models.MotionOfferState) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNMotionProperty2whalepkgmodelsMotionProperty(ctx context.Context, sel ast.SelectionSet, v models.MotionProperty) graphql.Marshaler {
	return ec._MotionProperty(ctx, sel, &v)
}

func (ec *executionContext) marshalNMotionProperty2whalepkgmodelsMotionProperty(ctx context.Context, sel ast.SelectionSet, v []models.MotionProperty) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMotionProperty2whalepkgmodelsMotionProperty(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMotionPropertyParam2whalepkgmodelsMotionPropertyParam(ctx context.Context, v interface{}) ([]*models.MotionPropertyParam, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.MotionPropertyParam, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMotionPropertyParam2whalepkgmodelsMotionPropertyParam(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMotionPropertyParam2whalepkgmodelsMotionPropertyParam(ctx context.Context, v interface{}) (*models.MotionPropertyParam, error) {
	res, err := ec.unmarshalInputMotionPropertyParam(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRecentMatching2whalepkgmodelsRecentMatching(ctx context.Context, sel ast.SelectionSet, v models.RecentMatching) graphql.Marshaler {
	return ec._RecentMatching(ctx, sel, &v)
}

func (ec *executionContext) marshalNRecentMatching2whalepkgmodelsRecentMatching(ctx context.Context, sel ast.SelectionSet, v []*models.RecentMatching) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRecentMatching2whalepkgmodelsRecentMatching(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRecentMatching2whalepkgmodelsRecentMatching(ctx context.Context, sel ast.SelectionSet, v *models.RecentMatching) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RecentMatching(ctx, sel, v)
}

func (ec *executionContext) unmarshalNResultCreatedBy2whalepkgmodelsResultCreatedBy(ctx context.Context, v interface{}) (models.ResultCreatedBy, error) {
	var res models.ResultCreatedBy
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNResultCreatedBy2whalepkgmodelsResultCreatedBy(ctx context.Context, sel ast.SelectionSet, v models.ResultCreatedBy) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNReviewMatchingParam2whalepkgmodelsReviewMatchingParam(ctx context.Context, v interface{}) (models.ReviewMatchingParam, error) {
	res, err := ec.unmarshalInputReviewMatchingParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNReviewMotionParam2whalepkgmodelsReviewMotionParam(ctx context.Context, v interface{}) (models.ReviewMotionParam, error) {
	res, err := ec.unmarshalInputReviewMotionParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSimpleAvatarUser2whalepkgmodelsSimpleAvatarUser(ctx context.Context, sel ast.SelectionSet, v []*models.SimpleAvatarUser) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSimpleAvatarUser2whalepkgmodelsSimpleAvatarUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSimpleAvatarUser2whalepkgmodelsSimpleAvatarUser(ctx context.Context, sel ast.SelectionSet, v *models.SimpleAvatarUser) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SimpleAvatarUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSummary2whalepkgmodelsSummary(ctx context.Context, sel ast.SelectionSet, v models.Summary) graphql.Marshaler {
	return ec._Summary(ctx, sel, &v)
}

func (ec *executionContext) marshalNSummary2whalepkgmodelsSummary(ctx context.Context, sel ast.SelectionSet, v *models.Summary) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Summary(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTopic2whalepkgmodelsTopic(ctx context.Context, sel ast.SelectionSet, v models.Topic) graphql.Marshaler {
	return ec._Topic(ctx, sel, &v)
}

func (ec *executionContext) marshalNTopic2whalepkgmodelsTopic(ctx context.Context, sel ast.SelectionSet, v []*models.Topic) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTopic2whalepkgmodelsTopic(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTopic2whalepkgmodelsTopic(ctx context.Context, sel ast.SelectionSet, v *models.Topic) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Topic(ctx, sel, v)
}

func (ec *executionContext) marshalNTopicMetrics2whalepkgmodelsTopicMetrics(ctx context.Context, sel ast.SelectionSet, v models.TopicMetrics) graphql.Marshaler {
	return ec._TopicMetrics(ctx, sel, &v)
}

func (ec *executionContext) marshalNTopicMetrics2whalepkgmodelsTopicMetrics(ctx context.Context, sel ast.SelectionSet, v []models.TopicMetrics) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTopicMetrics2whalepkgmodelsTopicMetrics(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTopicToMatching2whalepkgmodelsTopicToMatching(ctx context.Context, sel ast.SelectionSet, v []*models.TopicToMatching) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTopicToMatching2whalepkgmodelsTopicToMatching(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTopicToMatching2whalepkgmodelsTopicToMatching(ctx context.Context, sel ast.SelectionSet, v *models.TopicToMatching) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TopicToMatching(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateCityTopicParam2whalepkgmodelsUpdateCityTopicParam(ctx context.Context, v interface{}) (models.UpdateCityTopicParam, error) {
	res, err := ec.unmarshalInputUpdateCityTopicParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateDurationConstraintParam2whalepkgmodelsUpdateDurationConstraintParam(ctx context.Context, v interface{}) (models.UpdateDurationConstraintParam, error) {
	res, err := ec.unmarshalInputUpdateDurationConstraintParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateHotTopicMetricsParam2whalepkgmodelsUpdateHotTopicMetricsParam(ctx context.Context, v interface{}) ([]*models.UpdateHotTopicMetricsParam, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.UpdateHotTopicMetricsParam, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUpdateHotTopicMetricsParam2whalepkgmodelsUpdateHotTopicMetricsParam(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNUpdateHotTopicMetricsParam2whalepkgmodelsUpdateHotTopicMetricsParam(ctx context.Context, v interface{}) (*models.UpdateHotTopicMetricsParam, error) {
	res, err := ec.unmarshalInputUpdateHotTopicMetricsParam(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateHotTopicParam2whalepkgmodelsUpdateHotTopicParam(ctx context.Context, v interface{}) (models.UpdateHotTopicParam, error) {
	res, err := ec.unmarshalInputUpdateHotTopicParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateMatchingDurationConstraintParam2whalepkgmodelsUpdateMatchingDurationConstraintParam(ctx context.Context, v interface{}) (models.UpdateMatchingDurationConstraintParam, error) {
	res, err := ec.unmarshalInputUpdateMatchingDurationConstraintParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateMatchingInvitationParam2whalepkgmodelsUpdateMatchingInvitationParam(ctx context.Context, v interface{}) (models.UpdateMatchingInvitationParam, error) {
	res, err := ec.unmarshalInputUpdateMatchingInvitationParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateMatchingParam2whalepkgmodelsUpdateMatchingParam(ctx context.Context, v interface{}) (models.UpdateMatchingParam, error) {
	res, err := ec.unmarshalInputUpdateMatchingParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateMatchingQuotaParam2whalepkgmodelsUpdateMatchingQuotaParam(ctx context.Context, v interface{}) (models.UpdateMatchingQuotaParam, error) {
	res, err := ec.unmarshalInputUpdateMatchingQuotaParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateMotionParam2whalepkgmodelsUpdateMotionParam(ctx context.Context, v interface{}) (models.UpdateMotionParam, error) {
	res, err := ec.unmarshalInputUpdateMotionParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateRecentMatchingParam2whalepkgmodelsUpdateRecentMatchingParam(ctx context.Context, v interface{}) (models.UpdateRecentMatchingParam, error) {
	res, err := ec.unmarshalInputUpdateRecentMatchingParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateUserJoinTopicParam2whalepkgmodelsUpdateUserJoinTopicParam(ctx context.Context, v interface{}) (models.UpdateUserJoinTopicParam, error) {
	res, err := ec.unmarshalInputUpdateUserJoinTopicParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2whalepkgmodelsUser(ctx context.Context, sel ast.SelectionSet, v models.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2whalepkgmodelsUser(ctx context.Context, sel ast.SelectionSet, v []*models.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2whalepkgmodelsUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUser2whalepkgmodelsUser(ctx context.Context, sel ast.SelectionSet, v *models.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalNUserConfirmState2whalepkgmodelsUserConfirmState(ctx context.Context, sel ast.SelectionSet, v []*models.UserConfirmState) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserConfirmState2whalepkgmodelsUserConfirmState(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUserConfirmState2whalepkgmodelsUserConfirmState(ctx context.Context, sel ast.SelectionSet, v *models.UserConfirmState) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserConfirmState(ctx, sel, v)
}

func (ec *executionContext) marshalNUserJoinTopic2whalepkgmodelsUserJoinTopic(ctx context.Context, sel ast.SelectionSet, v models.UserJoinTopic) graphql.Marshaler {
	return ec._UserJoinTopic(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserJoinTopic2whalepkgmodelsUserJoinTopic(ctx context.Context, sel ast.SelectionSet, v []*models.UserJoinTopic) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserJoinTopic2whalepkgmodelsUserJoinTopic(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUserJoinTopic2whalepkgmodelsUserJoinTopic(ctx context.Context, sel ast.SelectionSet, v *models.UserJoinTopic) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserJoinTopic(ctx, sel, v)
}

func (ec *executionContext) marshalNUserLikeMotion2whalepkgmodelsUserLikeMotion(ctx context.Context, sel ast.SelectionSet, v []*models.UserLikeMotion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserLikeMotion2whalepkgmodelsUserLikeMotion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUserLikeMotion2whalepkgmodelsUserLikeMotion(ctx context.Context, sel ast.SelectionSet, v *models.UserLikeMotion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserLikeMotion(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserMatchingCalenderParam2whalepkgmodelsUserMatchingCalenderParam(ctx context.Context, v interface{}) (models.UserMatchingCalenderParam, error) {
	res, err := ec.unmarshalInputUserMatchingCalenderParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUserMatchingInTheDayParam2whalepkgmodelsUserMatchingInTheDayParam(ctx context.Context, v interface{}) (models.UserMatchingInTheDayParam, error) {
	res, err := ec.unmarshalInputUserMatchingInTheDayParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserThumbsUpMotion2whalepkgmodelsUserThumbsUpMotion(ctx context.Context, sel ast.SelectionSet, v []*models.UserThumbsUpMotion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserThumbsUpMotion2whalepkgmodelsUserThumbsUpMotion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUserThumbsUpMotion2whalepkgmodelsUserThumbsUpMotion(ctx context.Context, sel ast.SelectionSet, v *models.UserThumbsUpMotion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserThumbsUpMotion(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserUpdateMotionParam2whalepkgmodelsUserUpdateMotionParam(ctx context.Context, v interface{}) (models.UserUpdateMotionParam, error) {
	res, err := ec.unmarshalInputUserUpdateMotionParam(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalN_Any2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN_Any2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN_Any2map(ctx context.Context, v interface{}) ([]map[string]interface{}, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]map[string]interface{}, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN_Any2map(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN_Any2map(ctx context.Context, sel ast.SelectionSet, v []map[string]interface{}) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalN_Any2map(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN_Entity2githubcom99designsgqlgenpluginfederationfedruntimeEntity(ctx context.Context, sel ast.SelectionSet, v []fedruntime.Entity) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalO_Entity2githubcom99designsgqlgenpluginfederationfedruntimeEntity(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalN_Service2githubcom99designsgqlgenpluginfederationfedruntimeService(ctx context.Context, sel ast.SelectionSet, v fedruntime.Service) graphql.Marshaler {
	return ec.__Service(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOChatGroup2whalepkgmodelsChatGroup(ctx context.Context, sel ast.SelectionSet, v *models.ChatGroup) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ChatGroup(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCitiesTopicsFilter2whalepkgmodelsCitiesTopicsFilter(ctx context.Context, v interface{}) (*models.CitiesTopicsFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCitiesTopicsFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalODatePeriod2whalepkgmodelsDatePeriod(ctx context.Context, v interface{}) ([]models.DatePeriod, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]models.DatePeriod, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDatePeriod2whalepkgmodelsDatePeriod(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalODatePeriod2whalepkgmodelsDatePeriod(ctx context.Context, sel ast.SelectionSet, v []models.DatePeriod) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDatePeriod2whalepkgmodelsDatePeriod(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalODiscoverTopicCategoryMotionFilter2whalepkgmodelsDiscoverTopicCategoryMotionFilter(ctx context.Context, v interface{}) (*models.DiscoverTopicCategoryMotionFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDiscoverTopicCategoryMotionFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGender2whalepkgmodelsGender(ctx context.Context, v interface{}) (*models.Gender, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(models.Gender)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGender2whalepkgmodelsGender(ctx context.Context, sel ast.SelectionSet, v *models.Gender) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOGraphQLPaginator2githubcomletjoyclubmidatoolgraphqlutilGraphQLPaginator(ctx context.Context, v interface{}) (*graphqlutil.GraphQLPaginator, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGraphQLPaginator(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOHotTopicsFilter2whalepkgmodelsHotTopicsFilter(ctx context.Context, v interface{}) (*models.HotTopicsFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputHotTopicsFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	return res
}

func (ec *executionContext) unmarshalOMatchingFilter2whalepkgmodelsMatchingFilter(ctx context.Context, v interface{}) (*models.MatchingFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMatchingFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMatchingInvitation2whalepkgmodelsMatchingInvitation(ctx context.Context, sel ast.SelectionSet, v []*models.MatchingInvitation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatchingInvitation2whalepkgmodelsMatchingInvitation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOMatchingInvitationFilter2whalepkgmodelsMatchingInvitationFilter(ctx context.Context, v interface{}) (*models.MatchingInvitationFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMatchingInvitationFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMatchingResult2whalepkgmodelsMatchingResult(ctx context.Context, sel ast.SelectionSet, v *models.MatchingResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MatchingResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMatchingResultFilter2whalepkgmodelsMatchingResultFilter(ctx context.Context, v interface{}) (*models.MatchingResultFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMatchingResultFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMatchingState2whalepkgmodelsMatchingState(ctx context.Context, v interface{}) ([]models.MatchingState, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]models.MatchingState, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMatchingState2whalepkgmodelsMatchingState(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOMatchingState2whalepkgmodelsMatchingState(ctx context.Context, sel ast.SelectionSet, v []models.MatchingState) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatchingState2whalepkgmodelsMatchingState(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOMatchingState2whalepkgmodelsMatchingState(ctx context.Context, v interface{}) (*models.MatchingState, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(models.MatchingState)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMatchingState2whalepkgmodelsMatchingState(ctx context.Context, sel ast.SelectionSet, v *models.MatchingState) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOMotion2whalepkgmodelsMotion(ctx context.Context, sel ast.SelectionSet, v *models.Motion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Motion(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMotionFilter2whalepkgmodelsMotionFilter(ctx context.Context, v interface{}) (*models.MotionFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMotionFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMotionPropertyParam2whalepkgmodelsMotionPropertyParam(ctx context.Context, v interface{}) ([]*models.MotionPropertyParam, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.MotionPropertyParam, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMotionPropertyParam2whalepkgmodelsMotionPropertyParam(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalONotifyNewMotionOfferMessageParam2whalepkgmodelsNotifyNewMotionOfferMessageParam(ctx context.Context, v interface{}) (*models.NotifyNewMotionOfferMessageParam, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNotifyNewMotionOfferMessageParam(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalORecentMatchingFilter2whalepkgmodelsRecentMatchingFilter(ctx context.Context, v interface{}) (*models.RecentMatchingFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRecentMatchingFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOTopicOptionConfig2whalepkgmodelsTopicOptionConfig(ctx context.Context, sel ast.SelectionSet, v *models.TopicOptionConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TopicOptionConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserJoinTopicFilter2whalepkgmodelsUserJoinTopicFilter(ctx context.Context, v interface{}) (*models.UserJoinTopicFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserJoinTopicFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUserMatchingFilter2whalepkgmodelsUserMatchingFilter(ctx context.Context, v interface{}) (*models.UserMatchingFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserMatchingFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalO_Entity2githubcom99designsgqlgenpluginfederationfedruntimeEntity(ctx context.Context, sel ast.SelectionSet, v fedruntime.Entity) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.__Entity(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************

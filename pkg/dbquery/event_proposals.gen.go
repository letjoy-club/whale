// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dbquery

import (
	"context"
	"whale/pkg/models"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newEventProposal(db *gorm.DB, opts ...gen.DOOption) eventProposal {
	_eventProposal := eventProposal{}

	_eventProposal.eventProposalDo.UseDB(db, opts...)
	_eventProposal.eventProposalDo.UseModel(&models.EventProposal{})

	tableName := _eventProposal.eventProposalDo.TableName()
	_eventProposal.ALL = field.NewAsterisk(tableName)
	_eventProposal.ID = field.NewString(tableName, "id")
	_eventProposal.TopicID = field.NewString(tableName, "topic_id")
	_eventProposal.CityID = field.NewString(tableName, "city_id")
	_eventProposal.Address = field.NewString(tableName, "address")
	_eventProposal.Images = field.NewField(tableName, "images")
	_eventProposal.Latitude = field.NewFloat64(tableName, "latitude")
	_eventProposal.Longitude = field.NewFloat64(tableName, "longitude")
	_eventProposal.MaxNum = field.NewInt(tableName, "max_num")
	_eventProposal.JoinNum = field.NewInt(tableName, "join_num")
	_eventProposal.Title = field.NewString(tableName, "title")
	_eventProposal.Desc = field.NewString(tableName, "desc")
	_eventProposal.ChatGroupID = field.NewString(tableName, "chat_group_id")
	_eventProposal.UserID = field.NewString(tableName, "user_id")
	_eventProposal.Active = field.NewBool(tableName, "active")
	_eventProposal.Deadline = field.NewTime(tableName, "deadline")
	_eventProposal.StartAt = field.NewTime(tableName, "start_at")
	_eventProposal.CreatedAt = field.NewTime(tableName, "created_at")

	_eventProposal.fillFieldMap()

	return _eventProposal
}

type eventProposal struct {
	eventProposalDo eventProposalDo

	ALL         field.Asterisk
	ID          field.String
	TopicID     field.String
	CityID      field.String
	Address     field.String
	Images      field.Field
	Latitude    field.Float64
	Longitude   field.Float64
	MaxNum      field.Int
	JoinNum     field.Int
	Title       field.String
	Desc        field.String
	ChatGroupID field.String
	UserID      field.String
	Active      field.Bool
	Deadline    field.Time
	StartAt     field.Time
	CreatedAt   field.Time

	fieldMap map[string]field.Expr
}

func (e eventProposal) Table(newTableName string) *eventProposal {
	e.eventProposalDo.UseTable(newTableName)
	return e.updateTableName(newTableName)
}

func (e eventProposal) As(alias string) *eventProposal {
	e.eventProposalDo.DO = *(e.eventProposalDo.As(alias).(*gen.DO))
	return e.updateTableName(alias)
}

func (e *eventProposal) updateTableName(table string) *eventProposal {
	e.ALL = field.NewAsterisk(table)
	e.ID = field.NewString(table, "id")
	e.TopicID = field.NewString(table, "topic_id")
	e.CityID = field.NewString(table, "city_id")
	e.Address = field.NewString(table, "address")
	e.Images = field.NewField(table, "images")
	e.Latitude = field.NewFloat64(table, "latitude")
	e.Longitude = field.NewFloat64(table, "longitude")
	e.MaxNum = field.NewInt(table, "max_num")
	e.JoinNum = field.NewInt(table, "join_num")
	e.Title = field.NewString(table, "title")
	e.Desc = field.NewString(table, "desc")
	e.ChatGroupID = field.NewString(table, "chat_group_id")
	e.UserID = field.NewString(table, "user_id")
	e.Active = field.NewBool(table, "active")
	e.Deadline = field.NewTime(table, "deadline")
	e.StartAt = field.NewTime(table, "start_at")
	e.CreatedAt = field.NewTime(table, "created_at")

	e.fillFieldMap()

	return e
}

func (e *eventProposal) WithContext(ctx context.Context) IEventProposalDo {
	return e.eventProposalDo.WithContext(ctx)
}

func (e eventProposal) TableName() string { return e.eventProposalDo.TableName() }

func (e eventProposal) Alias() string { return e.eventProposalDo.Alias() }

func (e *eventProposal) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := e.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (e *eventProposal) fillFieldMap() {
	e.fieldMap = make(map[string]field.Expr, 17)
	e.fieldMap["id"] = e.ID
	e.fieldMap["topic_id"] = e.TopicID
	e.fieldMap["city_id"] = e.CityID
	e.fieldMap["address"] = e.Address
	e.fieldMap["images"] = e.Images
	e.fieldMap["latitude"] = e.Latitude
	e.fieldMap["longitude"] = e.Longitude
	e.fieldMap["max_num"] = e.MaxNum
	e.fieldMap["join_num"] = e.JoinNum
	e.fieldMap["title"] = e.Title
	e.fieldMap["desc"] = e.Desc
	e.fieldMap["chat_group_id"] = e.ChatGroupID
	e.fieldMap["user_id"] = e.UserID
	e.fieldMap["active"] = e.Active
	e.fieldMap["deadline"] = e.Deadline
	e.fieldMap["start_at"] = e.StartAt
	e.fieldMap["created_at"] = e.CreatedAt
}

func (e eventProposal) clone(db *gorm.DB) eventProposal {
	e.eventProposalDo.ReplaceConnPool(db.Statement.ConnPool)
	return e
}

func (e eventProposal) replaceDB(db *gorm.DB) eventProposal {
	e.eventProposalDo.ReplaceDB(db)
	return e
}

type eventProposalDo struct{ gen.DO }

type IEventProposalDo interface {
	gen.SubQuery
	Debug() IEventProposalDo
	WithContext(ctx context.Context) IEventProposalDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IEventProposalDo
	WriteDB() IEventProposalDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IEventProposalDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IEventProposalDo
	Not(conds ...gen.Condition) IEventProposalDo
	Or(conds ...gen.Condition) IEventProposalDo
	Select(conds ...field.Expr) IEventProposalDo
	Where(conds ...gen.Condition) IEventProposalDo
	Order(conds ...field.Expr) IEventProposalDo
	Distinct(cols ...field.Expr) IEventProposalDo
	Omit(cols ...field.Expr) IEventProposalDo
	Join(table schema.Tabler, on ...field.Expr) IEventProposalDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IEventProposalDo
	RightJoin(table schema.Tabler, on ...field.Expr) IEventProposalDo
	Group(cols ...field.Expr) IEventProposalDo
	Having(conds ...gen.Condition) IEventProposalDo
	Limit(limit int) IEventProposalDo
	Offset(offset int) IEventProposalDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IEventProposalDo
	Unscoped() IEventProposalDo
	Create(values ...*models.EventProposal) error
	CreateInBatches(values []*models.EventProposal, batchSize int) error
	Save(values ...*models.EventProposal) error
	First() (*models.EventProposal, error)
	Take() (*models.EventProposal, error)
	Last() (*models.EventProposal, error)
	Find() ([]*models.EventProposal, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.EventProposal, err error)
	FindInBatches(result *[]*models.EventProposal, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*models.EventProposal) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IEventProposalDo
	Assign(attrs ...field.AssignExpr) IEventProposalDo
	Joins(fields ...field.RelationField) IEventProposalDo
	Preload(fields ...field.RelationField) IEventProposalDo
	FirstOrInit() (*models.EventProposal, error)
	FirstOrCreate() (*models.EventProposal, error)
	FindByPage(offset int, limit int) (result []*models.EventProposal, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IEventProposalDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (e eventProposalDo) Debug() IEventProposalDo {
	return e.withDO(e.DO.Debug())
}

func (e eventProposalDo) WithContext(ctx context.Context) IEventProposalDo {
	return e.withDO(e.DO.WithContext(ctx))
}

func (e eventProposalDo) ReadDB() IEventProposalDo {
	return e.Clauses(dbresolver.Read)
}

func (e eventProposalDo) WriteDB() IEventProposalDo {
	return e.Clauses(dbresolver.Write)
}

func (e eventProposalDo) Session(config *gorm.Session) IEventProposalDo {
	return e.withDO(e.DO.Session(config))
}

func (e eventProposalDo) Clauses(conds ...clause.Expression) IEventProposalDo {
	return e.withDO(e.DO.Clauses(conds...))
}

func (e eventProposalDo) Returning(value interface{}, columns ...string) IEventProposalDo {
	return e.withDO(e.DO.Returning(value, columns...))
}

func (e eventProposalDo) Not(conds ...gen.Condition) IEventProposalDo {
	return e.withDO(e.DO.Not(conds...))
}

func (e eventProposalDo) Or(conds ...gen.Condition) IEventProposalDo {
	return e.withDO(e.DO.Or(conds...))
}

func (e eventProposalDo) Select(conds ...field.Expr) IEventProposalDo {
	return e.withDO(e.DO.Select(conds...))
}

func (e eventProposalDo) Where(conds ...gen.Condition) IEventProposalDo {
	return e.withDO(e.DO.Where(conds...))
}

func (e eventProposalDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IEventProposalDo {
	return e.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (e eventProposalDo) Order(conds ...field.Expr) IEventProposalDo {
	return e.withDO(e.DO.Order(conds...))
}

func (e eventProposalDo) Distinct(cols ...field.Expr) IEventProposalDo {
	return e.withDO(e.DO.Distinct(cols...))
}

func (e eventProposalDo) Omit(cols ...field.Expr) IEventProposalDo {
	return e.withDO(e.DO.Omit(cols...))
}

func (e eventProposalDo) Join(table schema.Tabler, on ...field.Expr) IEventProposalDo {
	return e.withDO(e.DO.Join(table, on...))
}

func (e eventProposalDo) LeftJoin(table schema.Tabler, on ...field.Expr) IEventProposalDo {
	return e.withDO(e.DO.LeftJoin(table, on...))
}

func (e eventProposalDo) RightJoin(table schema.Tabler, on ...field.Expr) IEventProposalDo {
	return e.withDO(e.DO.RightJoin(table, on...))
}

func (e eventProposalDo) Group(cols ...field.Expr) IEventProposalDo {
	return e.withDO(e.DO.Group(cols...))
}

func (e eventProposalDo) Having(conds ...gen.Condition) IEventProposalDo {
	return e.withDO(e.DO.Having(conds...))
}

func (e eventProposalDo) Limit(limit int) IEventProposalDo {
	return e.withDO(e.DO.Limit(limit))
}

func (e eventProposalDo) Offset(offset int) IEventProposalDo {
	return e.withDO(e.DO.Offset(offset))
}

func (e eventProposalDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IEventProposalDo {
	return e.withDO(e.DO.Scopes(funcs...))
}

func (e eventProposalDo) Unscoped() IEventProposalDo {
	return e.withDO(e.DO.Unscoped())
}

func (e eventProposalDo) Create(values ...*models.EventProposal) error {
	if len(values) == 0 {
		return nil
	}
	return e.DO.Create(values)
}

func (e eventProposalDo) CreateInBatches(values []*models.EventProposal, batchSize int) error {
	return e.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (e eventProposalDo) Save(values ...*models.EventProposal) error {
	if len(values) == 0 {
		return nil
	}
	return e.DO.Save(values)
}

func (e eventProposalDo) First() (*models.EventProposal, error) {
	if result, err := e.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*models.EventProposal), nil
	}
}

func (e eventProposalDo) Take() (*models.EventProposal, error) {
	if result, err := e.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*models.EventProposal), nil
	}
}

func (e eventProposalDo) Last() (*models.EventProposal, error) {
	if result, err := e.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*models.EventProposal), nil
	}
}

func (e eventProposalDo) Find() ([]*models.EventProposal, error) {
	result, err := e.DO.Find()
	return result.([]*models.EventProposal), err
}

func (e eventProposalDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.EventProposal, err error) {
	buf := make([]*models.EventProposal, 0, batchSize)
	err = e.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (e eventProposalDo) FindInBatches(result *[]*models.EventProposal, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return e.DO.FindInBatches(result, batchSize, fc)
}

func (e eventProposalDo) Attrs(attrs ...field.AssignExpr) IEventProposalDo {
	return e.withDO(e.DO.Attrs(attrs...))
}

func (e eventProposalDo) Assign(attrs ...field.AssignExpr) IEventProposalDo {
	return e.withDO(e.DO.Assign(attrs...))
}

func (e eventProposalDo) Joins(fields ...field.RelationField) IEventProposalDo {
	for _, _f := range fields {
		e = *e.withDO(e.DO.Joins(_f))
	}
	return &e
}

func (e eventProposalDo) Preload(fields ...field.RelationField) IEventProposalDo {
	for _, _f := range fields {
		e = *e.withDO(e.DO.Preload(_f))
	}
	return &e
}

func (e eventProposalDo) FirstOrInit() (*models.EventProposal, error) {
	if result, err := e.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*models.EventProposal), nil
	}
}

func (e eventProposalDo) FirstOrCreate() (*models.EventProposal, error) {
	if result, err := e.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*models.EventProposal), nil
	}
}

func (e eventProposalDo) FindByPage(offset int, limit int) (result []*models.EventProposal, count int64, err error) {
	result, err = e.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = e.Offset(-1).Limit(-1).Count()
	return
}

func (e eventProposalDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = e.Count()
	if err != nil {
		return
	}

	err = e.Offset(offset).Limit(limit).Scan(result)
	return
}

func (e eventProposalDo) Scan(result interface{}) (err error) {
	return e.DO.Scan(result)
}

func (e eventProposalDo) Delete(models ...*models.EventProposal) (result gen.ResultInfo, err error) {
	return e.DO.Delete(models)
}

func (e *eventProposalDo) withDO(do gen.Dao) *eventProposalDo {
	e.DO = *do.(*gen.DO)
	return e
}
